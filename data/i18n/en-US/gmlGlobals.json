{
    "abs": {
        "desc": "This function returns the absolute value of the input argument, so if it's a positive value then it will remain the same, but if it's negative it will be multiplied by -1 to make it positive.",
        "val": "The number to turn absolute."
    },
    "achievement_available": {
        "desc": "This function will return true if the user is currently connected to the internet and the chosen leaderboard and achievement system is available, otherwise it will return false."
    },
    "achievement_event": {
        "desc": "",
        "stringid": ""
    },
    "achievement_get_challenges": {
        "desc": "This function will send a request to the server for information on all current challenges and will trigger a callback  Social Asynchronous Event which contains the **async_load** map populated with the relevant key/value pairs. The **id** key of this *ds_map* is used to identify the correct callback (there can be more than one trigger function for any given asynchronous event), and will be paired with the constant **achievement_challenge_list_received** as well as a number of other key/value pairs for each challenge. The exact contents of the map are shown below: \n\n - \"id\": For this function it should be **achievement_challenge_list_received**\n\n - \"numchallenges\": The number of challenges (local and remote) currently available.\n\n - \"ChallengeNplayerid\": The player id for the challenge, where \"N\" is an integer, EG: \"Challenge5playerid\" is the player id for the fifth challenge in the list.\n\n - \"ChallengeNissuerid\": The id of the person that issued the challenge, where \"N\" is an integer, EG: \"Challenge2issuerid\" is the issuer id for the second challenge in the list.\n\n - \"ChallengeNstate\": The state of the challenge \"N\", which will have a value of 0: 3 (as a string) for invalid, pending, completed or declined.\n\n - \"ChallengeNmessage\": The text message for challenge \"N\".\n\n - \"ChallengeNissueddate\": The issue date for challenge \"N\".\n\n - \"ChallengeNcompleteddate\": The completion date for challenge \"N\".\n\n - \"ChallengeNtype\": The type of challenge given. Can be one of two constants:\n\n - **achievement_type_score_challenge**: A challenge based on the score value.\n\n - **achievement_type_achievement_challenge**: A challenge based on an achievement.\n\n - \"ChallengeNidentifier\": The identifying string for the challenge.\n\n - \"ChallengeNscore\": The score tied in with the challenge."
    },
    "achievement_get_info": {
        "desc": "",
        "userid": ""
    },
    "achievement_get_pic": {
        "desc": "This function will send a request to the server for the image of a player or a friend and will trigger a callback Social Asynchronous Event which contains the **async_load** map populated with the relevant key/value pairs. The **id** key of this *ds_map* is used to identify the correct callback (there can be more than one trigger function for any given asynchronous event), and will be paired with the constant **achievement_pic_loaded** as well as a number of other key/value pairs. The exact contents of the map are shown below: \n\n - \"id\": For this function it should be **achievement_pic_loaded**\n\n - \"playerid\": The id of the player or friend that we are receiving the image of.\n\n - \"spriteid\": The sprite id for the image that can then be used to draw it on-screen using any of the draw sprite functions.\n\n**NOTE:** This function is for iOS only. \n\nWARNING: This function creates sprites and as such, their ids should be stored in variables and then removed from memory using the sprite_delete function otherwise repeated use will give you a memory leak that will eventually slow down or crash your game.\n\n**Returns:** N/A ",
        "char": "The id of the person to get the image of (either from a friends list or a leaderboard)"
    },
    "achievement_increment": {
        "desc": "Google Play permit Android games to have achievements with no completion value and you can use this function to increment those achievement by a given amount.",
        "achievement_name": "The name of the achievement. ",
        "value": "The value to be sent."
    },
    "achievement_load_friends": {
        "desc": "This function will send a request to the server for information on all the logged in users friends and will trigger a callback Social Asynchronous Event which contains the **async_load** map populated with the relevant key/value pairs. The **id** key of this *ds_map* is used to identify the correct callback (there can be more than one trigger function for any given asynchronous event), and will be paired with the constant **achievement_friends_info** as well as a number of other key/value pairs for each friend. The exact contents of the map are shown below: \n\n - \"id\": For this function it should be **achievement_friends_info**\n\n - \"FriendN\": The name of the friend, where \"N\" is an integer value corresponding to their position within the friends list.\n\n - \"FriendidN\": The unique user id of the friend, \"N\".\n\n**NOTE:** This function is for iOS only.\n\n**Returns:** N/A "
    },
    "achievement_load_leaderboard": {
        "desc": "This function will send a request to the server for information on the given leaderboard. The leaderboard must have been created previously on the developer dashboard for your game and the ID given is that which you must supply as the first argument of the function. It will trigger a callback  Social Asynchronous Event which contains the **async_load** map populated with the relevant key/value pairs. The **id** key of this *ds_map* is used to identify the correct callback (there can be more than one trigger function for any given asynchronous event), and will be paired with the constant **achievement_leaderboard_info** as well as a number of other key/value pairs for each player. The exact contents of the map are shown below: \n\n - \"id\": For this function it should be **achievement_leaderboard_info**\n\n - \"leaderboardid\": The unique ID for the leaderboard as defined on the provider dashboard.\n\n - \"numentries\": The number of entries in the leaderboard that you have received.\n\n - \"PlayerN\": The name of the player, where \"N\" is an integer value corresponding to their position within the leaderboard entries list.\n\n - \"PlayeridN\": The unique user id of the player, \"N\". \n\n - \"RankN\": The rank of the player \"N\" within the leaderboard.\n\n - \"ScoreN\": The score of the player \"N\". \n\nYou can specify the exact portion of the leaderboard to show by giving a minimum and maximum index value, as well as request that the results be filtered to retrieve only those scores by your friends or those posted by all players using the following filter constants: \n\n - **achievement_filter_friends_only**: Get only the scores of the players friends.\n\n - **achievement_filter_all_players**: Get all scores for all players.\n\n**NOTE:** this function does not work on the Android platform.\n\n**Returns:** N/A ",
        "ident": "The unique ID of the leaderboard as shown on the developer dashboard.",
        "minindex": "The starting index value to get the leaderboard data from.",
        "maxindex": "The maximum index value to get the leaderboard data from.",
        "filter": "Whether to filter the results to those that are on your friends list or to all players (see the Description below)"
    },
    "achievement_load_progress": {
        "desc": "This function will send a request to the server for information on all available achievements. It will trigger a callback Social Asynchronous Event which contains the **async_load** map populated with the relevant key/value pairs. The **id** key of this *ds_map* is used to identify the correct callback (there can be more than one trigger function for any given asynchronous event), and will be paired with the constant **achievement_achievement_info** as well as a number of other key/value pairs for each player. The exact contents of the map are shown below: \n\n - \"id\": For this function it should be **achievement_achievement_info.**\n\n - \"numentries\": The number of achievements in the list.\n\n - \"AchN\": The name of the achievement, where \"N\" is an integer value corresponding to its place in the entries list. \n\n - \"AchCompN\": How complete the achievement \"N\" is as a percentage value from 0 to 100 (a string).\n\n**NOTE:** This function is for iOS only.\n\n**Returns:** N/A "
    },
    "achievement_login": {
        "desc": "This function logs the user into appropriate leaderboard and achievement service. If the service is **not** available, the user is logged into a \"pretend\" game centre and all achievements and scores are stored on the device so that when the actual service is available, these details can be uploaded. The function will trigger a callback  Social Asynchronous Event which contains the **async_load** map populated with the relevant key/value pairs. The **id** key of this *ds_map* is used to identify the correct callback (there can be more than one trigger function for any given asynchronous event), and will be paired with the constant **achievement_our_info** as well as a number of other key/value pairs for each challenge. The exact contents of the map are shown below: \n\n - \"id\": For this function it should be **achievement_our_info**\n\n - \"name\": The name of the user that is currently logged in.\n\n - \"playerid\": The unique player id for the user that is currently logged in.\n\n**Returns:** N/A "
    },
    "achievement_login_status": {
        "desc": "This function is currently only useful for Google Play on the Android platform. It will check to see if the user is already logged into Google services, in which case it will return *true*, or not, returning *false*. If it returns true there is no need to call the **achievement_login** function."
    },
    "achievement_logout": {
        "desc": "This function logs the user out of the chosen leaderboard and achievement service. This will stop all further achievements and scores from being recorded."
    },
    "achievement_post": {
        "desc": "You can use this function to send your achievements to the chosen leaderboard and achievement service. You send the name of the achievement (this is the name you assigned to it when you set up the account for your app) and the percentage that you have completed towards getting the achievement (0: None, 100: Completed).",
        "achievement_name": "The name of the achievement.",
        "percent": "The percentage of the achievement completed."
    },
    "achievement_post_score": {
        "desc": "You can use this function to send your score to the chosen leaderboard and achievement service. You send the name of the score table (the \"leaderboard\" name that you assigned to your game when you set up the account) and the actual score value).",
        "score_name": "The name of the score table (or \"Leaderboard\").",
        "score": "The score to be sent."
    },
    "achievement_reset": {
        "desc": "This function will reset all achievements back to their initial values for the game. This function is provided as a debug function and it is **not** recommended that you permit the end-user to do this in your games. "
    },
    "achievement_send_challenge": {
        "desc": "This function will send a challenge across the network to the chosen player. You can get the **playerid** using the **achievement_load_friends** or the **achievement_load_leaderboard** functions and you must also supply the challengeid which is the unique value given the challenge when you created it on your iTunes Connect or Google Play dashboard. You must also supply a score, and a short text message as well as set the challenge **type**. This can be one of the following constants:\n\n - **achievement_type_score_challenge**: A challenge based on the score value.\n\n - **achievement_type_achievement_challenge**: A challenge based on an achievement.\n\nThis function will trigger a callback Social Asynchronous Event for the player that is to receive the challenge, and in this event you will have a ds_map referenced in the variable **async_load**. The **id** key of this *ds_map* is used to identify the correct callback (there can be more than one trigger function for any given asynchronous event), and will be paired with the constant **achievement_challenge_received** as well as a number of other key/value pairs for each player. The exact contents of the map are shown below: \n\n**NOTE:** that the user can also receive toast notifications for challenges received, but this will depend on the values you have chosen using the function **achievement_show_challenge_notifications**. \n\n - \"id\": For this function it should be achievement_leaderboard_info\n\n - \"playerid\": The player ID for the challenge.\n\n - \"issuerid\": The issuer ID for the challenge.\n\n - \"state\": The state of the challenge, which will have a value of 0: 3 (as a string) for invalid, pending, completed or declined.\n\n - \"message\": The text message for challenge.\n\n - \"completeddate\": The completion date for challenge.\n\n - \"issueddate\": The issue date for challenge. \n\n - \"type\": The type of challenge given. Can be one of two constants:\n\n - **achievement_type_score_challenge**: A challenge based on the score value.\n\n - **achievement_type_achievement_challenge**: A challenge based on an achievement.\n\n - \"identifier\": The identifying string for the challenge, as set on the provider dashboard.\n\n - \"score\": The score tied in with the challenge (if applicable).",
        "to": "The unique ID of the player to challenge. ",
        "challengeid": "The unique challenge ID (as found on the provider dashboard).",
        "score": "The score to beat. ",
        "type": "The type of challenge to be issued: one of two constants given below.",
        "msg": "The message to attach to the challenge."
    },
    "achievement_show": {
        "desc": "",
        "type": "",
        "val": ""
    },
    "achievement_show_achievements": {
        "desc": "This function will open the achievements page for the chosen platform. Please note that this is an **asynchronous function**, ie: your game will continue to run in the background while the achievements page is being shown. As such, you should be careful where you use this and make sure to pause the game or only permit it to be shown in areas of your game where it will not interfere with the game-play."
    },
    "achievement_show_challenge_notifications": {
        "desc": "With this function you can show, or suppress, the various different \"toast\" pop-up notifications relating to challenges. When the arguments are set to *true* these messages will appear, informing the player of any local or remote challenges received as well as those challenges that have been completed, while setting them to *false* will suppress these notifications.",
        "receive_challenge": "Show challenges received pop-up (true) or not (false).",
        "local_complete": "Show completed local challenges pop-up (true) or not (false).",
        "remote_complete": "Show completed remote challenges pop-up (true) or not (false)."
    },
    "achievement_show_leaderboards": {
        "desc": "This function will open the leaderboards page for the chosen platform. Please note that this is an **asynchronous function**, ie: your game will continue to run in the background while the leaderboards page is being shown. As such, you should be careful where you use this and make sure to pause the game or only permit it to be shown in areas of your game where it will not interfere with the game-play."
    },
    "alarm_get": {
        "desc": "This function can be used to get the current value of the given alarm. You supply the alarm number from 0 to 11 and this function will return the value that the alarm is currently on. This is an alternative method to getting the alarm array value directly.",
        "index": "The alarm index to get, from 0 to 11."
    },
    "alarm_set": {
        "desc": "This function can be used to set an alarm. You supply the alarm number from 0 to 11, and then the value to set the alarm to. The value must be an integer value, and you can set it to -1 to stop the alarm. This is an alternative method to setting the alarm array directly.",
        "index": "The alarm index to set, from 0 to 11.",
        "count": "The value (an integer) to set the alarm to."
    },
    "angle_difference": {
        "desc": "This function will return the smallest angle difference between two angles as a value between -180 and 180 degrees (where a positive angle is anti-clockwise and a negative angle clockwise).",
        "ang1": "The first angle to use.",
        "ang2": "The second angle to use."
    },
    "ansi_char": {
        "desc": "This function returns a string containing the character with raw BYTE value set. This will not, and should not, be displayed, but it will save correctly to disk for use in encoding.",
        "val": "The raw byte value."
    },
    "application_get_position": {
        "desc": "When you have \"maintain aspect ratio\" ticked in the Global Game Settings for a target platform, GameMaker: Studio will automatically set the draw position for the application surface so that it is displayed correctly centered and scaled on the given display. However if you are manipulating this surface and wish to draw it yourself, then this function gives you an easy way to find exactly where within the display or window that the surface was being drawn so that you can then draw it there yourself, or align GUI images or post draw images to it. \n\nThe function will return an array with four keys, where key 0 and 1 are the x and y position of the top lefthand corner of the surface, and keys 2 and 3 are the x and y of the bottom righthand corner of the surface, all relative to the size of the display or window."
    },
    "application_surface_draw_enable": {
        "desc": "You can use this function to enable or disable the automatic drawing of the application surface. By default this is enabled, but in many cases you will want to take over when and how the surface is drawn (when using shaders for example), in which case you would use this function to set it to false so that you can draw it yourself when and how you require.",
        "flag": "The flag will be either *true* (enabled, the default value) or *false* (disabled)."
    },
    "application_surface_enable": {
        "desc": "With this function you can enable or disable the application surface. By default the application surface is enabled and all drawing for the Draw events will be done to that and the surface drawn to the screen. However on some older devices and specific chipsets this may result in poorer performance. In those cases you can switch off drawing to the application surface and all Draw event drawing will then be done directly to the screen buffer.\n\nYou can use this function to enable or disable the application surface at any time in your game, but you should note that it requires at least one frame (step) for the changes to take effect. Switching it off will switch off all aspect ratio correction, as set in the Global Game Settings for the target platform. This means that you should have some method in place that scales the game to the required device, window or screen dimensions. If you switch it back on again, then the Global Game Settings will take effect again the next step. \n\nIt is recommended that you use this function carefully as it will impact on how everything is drawn to the screen. In general you would want to have it as an option in a menu of your game, or call it only once at the start of your game and write your code around whether you have it enabled or disabled.",
        "enable": "Set to enable (true) or disable (false) the application surface."
    },
    "application_surface_is_enabled": {
        "desc": "This function will return *true* if the application surface is being used for drawing, or *false* if the screen buffer is being used."
    },
    "arccos": {
        "desc": "Returns the inverse cosine of x, in that if cos(val)=n, arccos(n)=val, and the resulting number will be between pi and 0. \n\n**NOTE:** This will only accept a number between -1 and 1 (anything else will throw an error).",
        "x": "The angle (in radians) to return the inverse cosine of."
    },
    "arcsin": {
        "desc": "Returns the inverse sine of x, in that if sin(x)=n, arcsin(n)=x, and the resulting number will be between -pi/2 and pi/2. \n\n**NOTE:** This will only accept a value between -1 and 1 (anything else will throw an error).",
        "x": "The angle (in radians) to return the inverse sine of."
    },
    "arctan": {
        "desc": "Returns the inverse tangent of x. This will accept any number as, unlike tan, arctans asymptotes are on the y axis so it just means you'll never get returned a number greater than pi/2 or less than -pi/2.",
        "x": "The angle (in radians) to return the inverse tangent of."
    },
    "arctan2": {
        "desc": "This function returns the inverse tangent of an angle y/x, where y = Opposite side of triangle and x = Adjacent side of triangle. Unlike arctan(x) the function arctan2(y, x) is valid for all angles and so may be used to convert a vector to an angle without risking division by zero, and it also returns a result in the correct quadrant.",
        "y": "The y coordinate to calculate.",
        "x": "The x coordinate to calculate."
    },
    "array_copy": {
        "desc": "With this function you can copy all or part of one array into another array at any position. You need to supply both the source and the destination arrays (both need to have been created previously), as well as a position within the source array to copy from and a position within the destination array to copy to. Finally you need to specify the length of the array (or the length of the part that you want) to copy. If the data being copied exceeds the length of the destination array, the array will be extended to accept the data.",
        "dest": "The ID of the array to copy to.",
        "dest_index": "The index within the array to copy to.",
        "src": "The ID of the array to copy from.",
        "src_index": "The index with the array to start copying from.",
        "length": "The length (number of array indices) to copy."
    },
    "array_create": {
        "desc": "With this function you can create an array of a given size. You tell the function the length of the array to create, and it will return the \"handle\" for the array which you can then assign to a variable. Arrays created in this way will have each entry initialised to 0 unless you specify an (optional) initialisation value. If you do supply the extra value for initialising the array, then all indices within the new array will be set to that instead of 0, but note that the function will take longer to run.",
        "size": "The size of the array to create.",
        "value": "The value to use to initialise all array indices (optional)."
    },
    "array_equals": {
        "desc": "With this function you can check to see if two arrays are equal (equivalent or the same). You give the two arrays to check, and the function will return *true* if they are equal (either equivalent or the same) or *false* if they are not. Note that this is not the same as checking if two arrays are the same using ==, which will not check to see if the two arrays hold equivalent values, but only to see if the arrays are referencing the same initial array.",
        "var1": "The index of the first array.",
        "var2": " The index of the second array. "
    },
    "array_height_2d": {
        "desc": "With this function you can get the height (number of entries) of a the first dimension of a 2D array. You supply the array to check and the output from the function tells you how many initial entries it contains. You can get the number of entries for the second dimension of the array using the function **array_length_2d**.",
        "array": "The array to check."
    },
    "array_length_1d": {
        "desc": "With this function you can get the length (number of entries) of a 1D array. For 2D arrays you should be using the **array_height_2d** and **array_length_2d** functions. \n\nWARNING!: If the array has over 32,000 entries this function will return an erroneous value and should not be used.",
        "array": "The array to check."
    },
    "array_length_2d": {
        "desc": "With this function you can get the length (number of entries) of a the second dimension of an array. You supply the entry number for the first dimension and the function will return the number of second dimension entries that the array has (to find the length of the first dimension use the function **array_height_2d**). The function will return 0 if the variable given is not an array or 1 if the variable is a 1D array (as there is still 1 row).",
        "array": "The array to check.",
        "n": " The entry of the array to get the length of. "
    },
    "asset_get_index": {
        "desc": "You can use this function to get the unique identifying index for a game asset from its name. If the asset is not found, the function will return a value of -1, otherwise it will return the unique index id for the asset being checked. This id can then be used in other functions as you would any other index value, like the **sprite_index** or **the path_index**, for example. Please note that although this function can be used to reference assets from strings (see example below) you should always make sure that the asset exists before using it otherwise you may get errors that will crash your game.",
        "name": "The name of the game asset to get the index of (a string)."
    },
    "asset_get_type": {
        "desc": "With this function you can get the type of asset being referenced from it s name (a string).",
        "name": "The name of the game asset to get the type of (a string)."
    },
    "audio_channel_num": {
        "desc": "With this function you can set how many audio channels are available for playing audio in GameMaker: Studio. What this basically means is that you give the number of simultaneous sounds that can be played at any one time, and if the number exceeds the amount, those sounds with a lower priority are stopped to free up a channel for the sounds with a higher priority. You can use this function to optimise your game for devices as the lower the number of channels for audio the better the performance, but bear in mind that this may also cause noticeable cut off of certain sounds if many are played at once.",
        "numchannels": "Number of available audio channels (default is 128)."
    },
    "audio_create_buffer_sound": {
        "desc": "With this function you can create a new sound from the contents of a buffer. The buffer will have been created previously (see the buffer functions for details on how to do this), and have had data added or loaded into it. You then pass it to this function with the data format (only **buffer_u8** or **buffer_s16** are currently supported), the sample rate (which can be between 1000hz and 48000hz), and an offset into the buffer to get the data from. You also need to supply the number of samples in the buffer and the channels that the sound requires. \n\nNote that after you have created a sound, you should free the pointer index associated with it when it is no longer required using the function **audio_free_buffer_sound()**. If you fail to do this and then re-assign the variable or change rooms etc... the sound ID will be lost and you will have a memory leak. Also note that you cannot delete the buffer if any sound has been created from it and the sound has not been freed up first. So you would free the sound (or sounds) first, then delete the buffer. It is also worth noting that adding anything to the buffer, or changing the buffer size, after it has had a sound created from it will give unexpected results and it is not recommended: once you have started creating sounds from any buffer you should not manipulate it in any other way afterwards.",
        "bufferId": "The ID of the buffer to use.",
        "format": "The format of the data in the buffer (**buffer_u8** or **buffer_s16**).",
        "rate": "The sample rate of the data in the buffer.",
        "offset": "The offset into the buffer to read the sample data from (in bytes).",
        "length": "The length of the buffer (the number of the samples in the buffer).",
        "channels": " The channels to use from one of the constants listed below. "
    },
    "audio_create_play_queue": {
        "desc": "This function prepares a buffer queue for audio. You pass data format (only **buffer_u8** or **buffer_s16** are currently supported), the sample rate (which can be between 1000hz and 48000hz). \n\nNote that you should free up any audio queues created with this function when no longer required to prevent memory leaks using the function **audio_free_play_queue()**. \n\nThis function will trigger an Audio Playback Asynchronous Event when the queue has reached the end, and in this event a special ds_map will be created in the variable **async_load** with the following key/value pairs: \n\n  •\"queue_id\": the queue that has finished playing data \n\n  •\"buffer_id\": the buffer that is no longer being played from \n\n  •\"queue_shutdown\": this is set to 0 during normal playback and 1 when the event is received because **audio_free_play_queue** has been called. When this is set to 1, you don't want to queue up any further data.",
        "queueFormat": "The format of the buffer data to use (**buffer_u8** or **buffer_s16**).",
        "sampleRate": "The sample rate of the data in the buffer queue.",
        "channels": "The channels to use from one of the constants listed below."
    },
    "audio_create_stream": {
        "desc": "With this function you can create a new sound index which can then be used in the regular audio functions to stream audio directly from an external OGG file source. The function requires the filename (which can be an included file, for example) and will return the new sound index for use. Note that after you no longer need the sound you should call the function **audio_destroy_stream()** with the sound index to remove it from memory otherwise you may get a memory leak which will slow down and eventually crash your game.",
        "filename": " The file (OGG only) to stream the audio from."
    },
    "audio_create_sync_group": {
        "desc": "Creates a sync group and returns a unique ID value for it which should then be used in all further audio function calls for this group. If you want the group to loop then pass in true, otherwise pass in false, but note that if you want them to loop, all the tracks added later need to be the same length. Note that when you create a sync group, you will need to free the memory and sounds associated with it when not in use using the **audio_destroy_sync_group()** function: for example, in the Room End or Destroy events.",
        "looping": "Whether the tracks in the group should loop (true) or not (false)."
    },
    "audio_debug": {
        "desc": "This function can be used to display debug information about the audio system, with true switching it on and false to switch it off.When you are debugging audio in this way, the overlay will show the following information:![](https://docs.yoyogames.com/source/dadiospice/002_reference/game%20assets/sounds/audio_debug.png)\n\nFor synchronised groups of audio, you also have the function **audio_sync_group_debug()**. \n\n**NOTE:** This function does not work on the HTML5 target platform.",
        "enable": "Enable (set to true) or disable (false) audio debugging."
    },
    "audio_destroy_stream": {
        "desc": "If you have previously created an audio stream from a file using the function **audio_create_stream()** and no longer need that sound, you can call this function to delete it from memory. Any further calls to the sound index after it has been destroyed will give an error.",
        "filename": " The file to stream the audio from. "
    },
    "audio_destroy_sync_group": {
        "desc": "Audio sync groups need to be destroyed when not in use to free up the memory and sound resources associated with them using this function. It takes the group index as returned when the group was created using the **function audio_create_sync_group()**, and frees all resources used by the group.",
        "group_index": " The group index to be destroyed. "
    },
    "audio_emitter_create": {
        "desc": "This function creates a new audio emitter and returns the index for it. This index should be stored in a variable for all further functions that relate to this emitter, and then when it is no longer needed it should be removed from memory using the function **audio_emitter_free** to prevent memory leaks which may eventually crash your game."
    },
    "audio_emitter_exists": {
        "desc": "This function returns whether an audio emitter exists (true) or not (false). Note that if the index you search for has not been initialised previously, this function will cause an error as it is searching for non-existent indices.",
        "index": "The index of the emitter to check the existence of."
    },
    "audio_emitter_falloff": {
        "desc": "With this function you can set the fall-off distance for an emitter. This is the distance from the listener the emitter has to be before the sound will have \"fallen off\" to a volume of 0. The default value for this is 100, but beware of setting this to any value lower than 1 as that will make any sound played through this emitter inaudible to the listener, however any other value will cause the sound to fade away the further that the emitter is from the listener. \n\nHow the sound itself is heard will depend on the falloff reference (which is the distance under which the volume for the source would normally drop by half) and the roll off factor (which affects the sound past the falloff reference distance only). The default factor is normally 1, and the effect of the different falloff values will depend on the model chosen. \n\nFor a complete guide to the different falloff models and how these values are used, please see the function **audio_falloff_set_model**\n\n**Returns:** N/A ",
        "emitterid": "The index of the emitter to change.",
        "falloff_ref_dist": "The falloff reference relative to the listener (clamp).",
        "falloff_max_dist": "The maximum falloff distance relative to the listener.",
        "falloff_factor": "The falloff factor (default 1)."
    },
    "audio_emitter_free": {
        "desc": "With this function you can remove the given emitter from memory. This should always be done whenever the emitter is not going to be used further in the room or the game, ie: in the Destroy Event of the instance or in the Room End Event, otherwise you may end up with a memory leak that will slow down and eventually crash your game.",
        "emitterid": "The index of the emitter to free."
    },
    "audio_emitter_gain": {
        "desc": "This function sets the maximum gain (volume) for the sound. The perceived volume for a sound can change depending on the fall-off value and the position it has relative to the listener, but by setting the gain with this function, the full volume will never exceed the specified gain value.The image below illustrates how gain affects the volume of the emitter when fall-off is greater than 0:![](https://docs.yoyogames.com/source/dadiospice/002_reference/game%20assets/sounds/audio_gain.png)\n\nThis function will change the volume of the sound while it is being played as well all subsequent sounds played through the given emitter. \n\n**NOTE:** the final volume will also be influenced by the global audio gain that has been set by the function **audio_master_gain**.",
        "emitterid": "The index of the emitter to change.",
        "gain": "The maximum gain (default 1)."
    },
    "audio_emitter_get_gain": {
        "desc": "This function returns the current gain (volume) set for the given audio emitter, a value between 0 and 1.",
        "emitterid": "The index of the emitter to use."
    },
    "audio_emitter_get_listener_mask": {
        "desc": "This function will return the bit-mask data that defines which audio listeners an emitter should play sounds from.",
        "emitterid": "The unique ID of the emitter to get the mask of"
    },
    "audio_emitter_get_pitch": {
        "desc": "This function returns the current pitch value set for the given audio emitter.",
        "emitterid": "The index of the emitter to use."
    },
    "audio_emitter_get_vx": {
        "desc": "This function returns the current velocity along the x axis for the given audio emitter.",
        "emitterid": "The index of the emitter to use."
    },
    "audio_emitter_get_vy": {
        "desc": "This function returns the current velocity along the y axis for the given audio emitter.",
        "emitterid": "The index of the emitter to use."
    },
    "audio_emitter_get_vz": {
        "desc": "This function returns the current velocity along the z axis for the given audio emitter. ",
        "emitterid": "The index of the emitter to use."
    },
    "audio_emitter_get_x": {
        "desc": "This function returns the current x position of the given audio emitter.",
        "emitterid": " The index of the emitter to use. "
    },
    "audio_emitter_get_y": {
        "desc": "This function returns the current y position of the given audio emitter.",
        "emitterid": "This function returns the current y position of the given audio emitter. "
    },
    "audio_emitter_get_z": {
        "desc": "This function returns the current z position of the given audio emitter.",
        "emitterid": "The index of the emitter to use."
    },
    "audio_emitter_pitch": {
        "desc": "This function can be used to change the pitch of all sounds emitted from the given emitter. It is a pitch multiplier, in that the input value multiplies the current pitch by that amount, so the default value of 1 is no pitch change, while a value of less than 1 will lower the pitch and greater than 1 will raise the pitch. It is best to use small increments for this function as any value under 0 or over 5 may not be audible anyway. \n\n**NOTE:** If a sound is being looped through the emitter, the change in pitch will not be detected unless the sound is stopped and looped again!",
        "emitterid": "The index of the emitter to change.",
        "pitch": "The pitch multiplier (default 1)."
    },
    "audio_emitter_position": {
        "desc": "With this function you can change the position of an audio emitter within the 3D audio space. The position will affect the sound in different ways depending on where the listener is positioned within the audio space too (default position is (0, 0, 0). See **audio_listener_position** for more information), so for example if the emitter position is set to (100, 0, 0) and the current listener is at (200, 0, 0) the audio streamed from the emitter will appear to be on the left of the audio field.The image below shows a visual representation of emitters and their relative positions to the listener:![](https://docs.yoyogames.com/source/dadiospice/002_reference/game%20assets/sounds/audio_emitters.png)\n\n**Returns:** N/A ",
        "emitterid": "The index of the emitter to change.",
        "x": "The x position. ",
        "y": "The y position.",
        "z": "The z position."
    },
    "audio_emitter_set_listener_mask": {
        "desc": "This function can be used to set the the bit-mask for an emitter so that all sounds played through the emitter will play only from those listeners specified. You can create a bit-mask by using the **audio_get_listener_info()** and then using the bitwise or (\"|\") to create a custom mask with those listeners that you require the sound to play from, and then apply this custom mask to the emitter. This mask will over-ride the default mask or that which you may have set using the function **audio_set_listener_mask()**.\n\n**Returns:** N/A",
        "emitterid": "The unique ID of the emitter to set the mask of",
        "mask": "The bitmask data to set for the sound"
    },
    "audio_emitter_velocity": {
        "desc": "This function can be used to give an emitter doppler effects and simulate audio motion based on the vector that is resolved from the given relative x, y and z positions (for more information on vectors, please see Maths: Vectors). If the emitter itself is not ever going to move you would normally not need to set these values, but, for example, if you are making a scrolling shooter game where the enemies come from the right and scroll to the left, you would set this to have a velocity of (hspeed, 0, 0) in the create event of the enemies (and update the emitter of each instance in the step event using **audio_emitter_position**) to give any sounds emitted by the enemy instances the correct doppler as they pass the player instance (which in turn would be using the function **audio_listener_position** to set the listener to the correct position).",
        "emitterid": "The index of the emitter to change.",
        "vx": "The x vector value (default 0).",
        "vy": "The y vector value (default 0).",
        "vz": "The z vector value (default 0)."
    },
    "audio_exists": {
        "desc": "This function returns whether a sound exists (true) or not (false). Note that if the index you search for has not been initialised previously, this function will cause an error as it is searching for non-existent asset indices. The sound to check can either be a single instance of a sound (the index for individual sounds being played can be stored in a variable when using the **audio_play_sound** or **audio_play_sound_at** functions) or a sound asset.",
        "index": "The index of the sound to check the existence of."
    },
    "audio_falloff_set_model": {
        "desc": "To add more versatility to the audio engine, GameMaker: Studio permits you to select the falloff model that suits your game. This model will be used for all the audio functions in the game or app, and so you should make sure that the model you choose is the correct one, as each one will affect how the listener perceives the sounds you play through emitters or with the function **audio_play_sound_at**. \n\nWhen setting falloff in your game with the appropriate functions there are three arguments that you will need to set, and each one is appropriate to a specific, model and will affect the way the final sound is \"heard\" by the player depending on the distance that the listener is from the source. The three arguments are: \n\n - reference distance: this is the distance from the listener the distance under which the volume for the sound playing would normally drop by half before being influenced by rolloff factor or the specified maximum distance.\n - maximum distance: this sets the distance where there will no longer be any attenuation of the source sound. This can be the point at which the sound is no longer heard or the point at which the sound volume no longer decreases below the minimum threshold defined by the model chosen.\n - falloff factor: The falloff factor is used in distance attenuation based on the inverse distance model and sets the final minimum threshold for a sound with falloff.\n\nThe following graphs are visual representations of how the above constants work and affect the sound being played:![](https://docs.yoyogames.com/source/dadiospice/002_reference/game%20assets/sounds/distance_models.png)\n\n**Returns:** N/A ",
        "falloffmodel": "The constant used to set the falloff model."
    },
    "audio_free_buffer_sound": {
        "desc": "With this function you can free up the pointer index value associated with the sound ID. Freed sounds will not be available for playing, and if multiple instances of the sound are being played they will all be stopped. Note that before you can delete the buffer itself, you must first free all sound ID's associated with it.\n\n**Returns:** N/A",
        "index": "The index of the buffered sound to free."
    },
    "audio_free_play_queue": {
        "desc": "This function is used to free up the memory associated with the given audio queue. The queue index is the value returned when you created the queue using the function **audio_create_play_queue()**, and this function should be called when the queue is no longer required to prevent memory leaks. Freeing the queue will stop any sound that is be playing, and you cannot delete the buffer that a sound is being streamed from until the queue it is assigned to has been freed. This function will trigger an Audio Playback Asynchronous Event, and in this event a special *ds_map* will be created in the variable **async_load** with the following key/value pairs:\n\n  \"queue_id\": the queue that has finished playing data\n\n  \"buffer_id\": the buffer that is no longer being played from\n\n  \"queue_shutdown\": this is set to 0 during normal playback and 1 when the event is received because you have freed the queue with this function. When this is set to 1, you don't want to queue up any further data.\n\n**Returns:** N/A",
        "queueIndex": "The index of the queue to free."
    },
    "audio_get_listener_count": {
        "desc": "Certain target platforms permit more than one listener, so it is important that you know how many the target has before changing or using different listeners. This function will return the number of listeners available.\n\n**Returns:** Real"
    },
    "audio_get_listener_info": {
        "desc": "This function will create a ds_map and populate it with information for the given listener.\n\n**NOTE:** You are responsible for the destruction of the returned ds_map using the appropriate function.\n\nThe ds_map will contain the following keys:\n\n    \"name\": The name of the listener, as a string, with \"default\" being the standard listener name on most target platforms\n\n    \"mask\": The bit-mask for the listener\n\n    \"index\": The unique index value of the listener\n\nThe mask value can be used to set a sound or emitter to play from multiple listeners at once, simply using the bitwise or \"|\" to generate a mask for the sound (see the example code below), while the index is used to set the properties like position or velocity for a given listener using functions like **audio_listener_set_position()**.\n\n**Returns:** ds_map",
        "num": "The listener number to get the data for."
    },
    "audio_get_listener_mask": {
        "desc": "This function will return the bit-mask data that defines the current default (global) mask for the audio listeners.\n\n**Returns:** Real"
    },
    "audio_get_master_gain": {
        "desc": "With this function you can get the absolute value for the global volume of all sounds and music for a specific listener. The default listener index is 0, but you can use the function **audio_get_listener_info** to get the different indices available for the target platform. The gain value returned is based on a linear scale from 0 (silent) to 1 (full volume).\n\n**Returns:** Real",
        "listenerIndex": "The index of the listener to get the gain of."
    },
    "audio_get_name": {
        "desc": "This function will return the name of a given audio resource as a string. The \"index\" value can be that of the resource itself (as seen in the resource tree) or the unique ID value that is given when you play the sound using, for example, **audio_play_sound()**. \n\nNote that the string returned is not the same as the resource ID and cannot be used to access the resource itself, so should only be used for displaying or error checking.\n\n**Returns:** String",
        "index": "The index of the sound to check."
    },
    "audio_get_recorder_count": {
        "desc": "This function will return the number of audio recording sources (like microphones, etc...) currently available to your game. So, if you have a return value of, for example, four, then you will have audio input on the sources 0, 1, 2 and 3, with one of these values being that which you use to start recording from using the function **audio_start_recording()**. This value can change at any time as people plug/unplug microphones or other input sources to the device. Note that you can use the function **audio_get_recorder_info** to get information on each device connected.\n\n**Returns:** Integer"
    },
    "audio_get_recorder_info": {
        "desc": "This function will return a *ds_map* with information about the given recorder source index. You can find out how many recorder sources are available using the function **audio_get_recorder_count**, and the map returned will contain the following key/value pairs:\n\n - \"name\": a name to describe the device\n\n - \"index\": the index to be used to record\n\n - \"data_format\": the format data will be returned in (this is currently always **buffer_s16** but other formats may be supported in the future)\n\n - \"sample_rate\": the sample rate (in Hz) of the data returned (currently clamped to 16000hz but this may change in future)\n\n - \"channels\": the constant audio_mono (further constants for stereo and 3D may be supported in the future)\n\nnote that while the function creates a *ds_map* for you, it does not remove it again later and so you should be destroying the map yourself when it is no longer needed to prevent any memory leaks.\n\n**NOTE:** Most platforms support recording audio in some form, but that does not mean that all devices will permit it, even if the platform does, so you should always check that the audio_get_recorder_count() function returns a value greater than 0 to verify that recording devices are available before using the rest of the recording functions.\n\n**Returns:** ds_map",
        "recorder_index": "The index of the recorder source to get the information from."
    },
    "audio_get_type": {
        "desc": "When adding audio to GameMaker: Studio it can be either streamed or in memory. If you need to know whether a given sound index is for streamed audio or not you can use this function which will return 1 for streamed, 0 for sound in memory, and -1 if there is any error or the index does not point to a valid sound resource.\n\n**Returns:** Real",
        "index": "The index of the sound to check."
    },
    "audio_group_is_loaded": {
        "desc": "This function will check a specific audio group to see if it has been loaded into memory, ready for use.\n\n**Returns:** Boolean",
        "groupId": "The index of the audio group to check (as defined in the Global Game Settings Audio Groups Tab)"
    },
    "audio_group_load": {
        "desc": "This function will load all the sounds that are flagged as belonging to the given Audio Group into memory. The function will return *true* if loading is initiated and *false* if the group ID is invalid, or it has already been flagged for loading. The function is asynchronous so your game will continue to run while the audio is loaded in the background. This means that it will also trigger an Asynchronous Load/Save Event to inform you that the whole group has been loaded into memory and the sounds can now be used.\n\n**Returns:** Boolean",
        "groupId": "The index of the audio group to load (as defined in the Global Game Settings Audio Groups Tab)"
    },
    "audio_group_load_progress": {
        "desc": "This function will check the loading progress for an audio group and return an (approximate) value between 0 and 100.\n\n**Returns:** Real",
        "groupId": "The index of the audio group to check (as defined in the Global Game Settings Audio Groups Tab)"
    },
    "audio_group_name": {
        "desc": "This function will return a string containing the name of the given audio group for displaying or checking. When you define an audio group in the Global Game Settings, you give it a unique \"name\" which is really a constant to use as an ID value for the group. All this function does is take the ID and return a string of the ID name you gave.\n\n**Returns:** String",
        "groupId": "The index value constant of the audio group to check (as defined in the Global Game Settings Audio Groups Tab)\n\n**Returns:** String"
    },
    "audio_group_set_gain": {
        "desc": "With this function you can fade a group of sounds in or out over a given length of time, or it can be used to set the group gain instantly. The time is measured in milliseconds, and the function requires that you input a final level of gain for the group to have reached by the end of that time. This gain can be between 0 (silent) and 1 (full volume) and the scale is linear, such that a value of 0.5 would be half volume. To instantly change the gain, simply set the time argument to 0.\n\n**Returns:** N/A",
        "groupId": "The index of the audio group to stop (as defined in the Global Game Settings Audio Groups Tab)",
        "volume": "The final value for the group volume.",
        "time": "The length of the change in gain in milliseconds."
    },
    "audio_group_stop": {
        "desc": "This function will stop all sounds from the given audio group that are currently playing.\n\n**Returns:** N/A",
        "groupId": "The index of the audio group to stop (as defined in the Global Game Settings Audio Groups Tab)"
    },
    "audio_group_unload": {
        "desc": "This function will unload all the sounds that are flagged as belonging to the given Audio Group into memory. The function will return true if unloading is initiated and false if the group ID is invalid, or it has already been flagged for unloading. Note that any audio currently being played when this function is called will be stopped.\n\n**Returns:** Boolean",
        "groupId": "The index of the audio group to unload (as defined in the Global Game Settings Audio Groups Tab)"
    },
    "audio_is_paused": {
        "desc": "This function will check the given sound to see if it is currently paused. The sound can either be a single instance of a sound (the index for individual sounds being played can be stored in a variable when using the **audio_play_sound** or **audio_play_sound_at** functions) or a sound asset, in which case all instances of the given sound will be checked and if any of them are paused the function will return true otherwise it will return false.\n\n**Returns:** Boolean",
        "index": "The index of the sound to check."
    },
    "audio_is_playing": {
        "desc": "This function will check the given sound to see if it is currently playing. The sound can either be a single instance of a sound (the index for individual sounds being played can be stored in a variable when using the **audio_play_sound** or **audio_play_sound_at** functions) or a sound asset, in which case all instances of the given sound will be checked and if any of them are playing the function will return true otherwise it will return false. Note that this function will still return true if the sound being checked has previously been paused using the **audio_pause_sound** function.\n\n**Returns:** Boolean",
        "index": "The index of the sound to check."
    },
    "audio_listener_get_data": {
        "desc": "This function will create a *ds_map* and populate it with the position, velocity and orientation values for the given listener. The default listener index is 0, but you can use the function **audio_get_listener_info** to get the different indices available for the target platform. If you provide an incorrect listener index then the function will return -1.\n\n**NOTE:** You are responsible for the destruction of the returned *ds_map* using the appropriate function.\n\nThe *ds_map* will contain the following keys:\n\n - \"x\": The x position of the listener\n\n - \"y\": The y position of the listener\n\n - \"z\": The z position of the listener\n\n - \"vx\": The x axis velocity of the listener\n\n - \"vy\": The y axis velocity of the listener\n\n - \"vz\": The z axis velocity of the listener\n\n - \"lookat_x\": The x component of the look at vector of the listener\n\n - \"lookat_y\": The y component of the look at vector of the listener\n\n - \"lookat_z\": The z component of the look at vector of the listener\n\n - \"up_x\": The x component of the up vector of the listener\n\n - \"up_y\": The y component of the up vector of the listener\n\n - \"up_z\": The z component of the up vector of the listener\n\n**Returns:** ds_map",
        "index": "The listener to get the data for (default 0)."
    },
    "audio_listener_orientation": {
        "desc": "With this function you can change the orientation of the listener within the 3D audio space. The look at direction and up direction are based on the vectors that are resolved from the given relative x, y and z positions (for more information on vectors, please see Maths - Vectors), and default to (0, 0, 1000) for the look at direction and (0, 1, 0) for the up direction, as shown in the illustration below: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/game%20assets/sounds/audio_orientation_base.png)\n\n**NOTE:** if you have multiple listeners you should use the function **audio_listener_set_orientation**.\n\nChanging the listener orientation with this function will change how sound created by audio emitters around the game room are perceived by the player of your game. In the example below, sounds created by the emitter when the listener is at the default position would appear to be coming from below and to the right of the listener, but with the new position and orientation of the listener they will now be perceived as coming from above and to the right. ![](https://docs.yoyogames.com/source/dadiospice/002_reference/game%20assets/sounds/audio_orientation_example.png)\n\n**Returns:** N/A",
        "lookat_x": "The x look vector (default 0).",
        "lookat_y": "The y look vector (default 0).",
        "lookat_z": "The z look vector (default 1000).",
        "up_x": "The x up vector (default 0).",
        "up_y": "The y up vector (default 1).",
        "up_z": "The z up vector (default 0)."
    },
    "audio_listener_position": {
        "desc": "With this function you can change the position of the listener within the 3D audio space. The example image below shows the default position for the listener in the audio space: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/game%20assets/sounds/audio_listener.png)\n\n**NOTE:** if you have multiple listeners you should use the function **audio_listener_set_position**.\n\nAs you can see, the default position is (0, 0, 0) but you would normally use this function to move the listener around with the player object within your game and so change the way audio created by emitters is heard by the player, for example, in the image below of a top down game, the player instance sets the listener which will cause the audio from the various emitters to \"change\" as the player moves around the level: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/game%20assets/sounds/audio_game.png)\n\n**Returns:** N/A",
        "x": "The x position of the listener (default 0).",
        "y": "The y position of the listener (default 0).",
        "z": "The z position of the listener (default 0)."
    },
    "audio_listener_set_orientation": {
        "desc": "With this function you can change the orientation of the given listener within the 3D audio space. The default listener index is 0, but you can use the function **audio_get_listener_info** to get the different indices available for the target platform.\n\nThe look at direction and up direction are based on the vectors that are resolved from the given relative x, y and z positions (for more information on vectors, please see Maths - Vectors), and default to (0, 0, 1000) for the look at direction and (0, 1, 0) for the up direction, as shown in the illustration below: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/game%20assets/sounds/audio_orientation_base.png)\n\nChanging the given listener orientation with this function will change how sound created by audio emitters around the game room are perceived by the player of your game. In the example below, sounds created by the emitter when the listener is at the default position would appear to be coming from below and to the right of the listener, but with the new position and orientation of the listener they will now be perceived as coming from above and to the right. ![](https://docs.yoyogames.com/source/dadiospice/002_reference/game%20assets/sounds/audio_orientation_example.png)\n\n**Returns:** N/A",
        "index": "The listener to get the data for (default 0).",
        "lookat_x": "The x look vector (default 0).",
        "lookat_y": "The y look vector (default 0).",
        "lookat_z": "The z look vector (default 1000).",
        "up_x": "The x up vector (default 0).",
        "up_y": "The y up vector (default 1).",
        "up_z": "The z up vector (default 0)."
    },
    "audio_listener_set_position": {
        "desc": "With this function you can change the position of a given listener within the 3D audio space. The default listener index is 0, but you can use the function **audio_get_listener_info** to get the different indices available for the target platform. The example image below shows the default position for the listener in the audio space: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/game%20assets/sounds/audio_listener.png)\n\nAs you can see, the default position is (0, 0, 0) but you would normally use this function to move the listener around with the player object within your game and so change the way audio created by emitters is heard by the player, for example, in the image below of a top down game, the player instance sets the listener which will cause the audio from the various emitters to \"change\" as the player moves around the level: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/game%20assets/sounds/audio_game.png)\n\n**Returns:** N/A",
        "index": "The listener to get the data for (default 0).",
        "x": "The x position of the listener (default 0).",
        "y": "The y position of the listener (default 0).",
        "z": "The z position of the listener (default 0)."
    },
    "audio_listener_set_velocity": {
        "desc": "This function can be used to give the given listener doppler effects and simulate audio motion based on the vector that is resolved from the given relative x, y and z positions (for more information on vectors, please see Maths - Vectors). The default listener index is 0, but you can use the function **audio_get_listener_info** to get the different indices available for the target platform.\n\nIf the given listener is not ever going to move, or the movement is not a constant motion, you would normally not need to set these values, but, for example, if you are making a scrolling game where the player has a constant bottom to top movement and the enemies a constant top to bottom movement, you would set the listener and emitter velocities (for emitters you would use **audio_emitter_velocity**) to the appropriate vectors to simulate the correct doppler effect as they move past the player instance.\n\nThe image below shows how this could be setup for the example game given above: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/game%20assets/sounds/audio_listener_velocity.png)\n\n**Returns:** N/A",
        "index": "The listener to get the data for (default 0).",
        "vx": "The x velocity of the listener (default 0).",
        "vy": "The y velocity of the listener (default 0).",
        "vz": "The z velocity of the listener (default 0)."
    },
    "audio_listener_velocity": {
        "desc": "This function can be used to give the listener doppler effects and simulate audio motion based on the vector that is resolved from the given relative x, y and z positions (for more information on vectors, please see Maths - Vectors). If the listener itself is not ever going to move, or the movement is not a constant motion, you would normally not need to set these values, but, for example, if you are making a scrolling game where the player has a constant bottom to top movement and the enemies a constant top to bottom movement, you would set the listener and emitter velocities (for emitters you would use **audio_emitter_velocity**) to the appropriate vectors to simulate the correct doppler effect as they move past the player instance.\n\n**NOTE:** if you have multiple listeners you should use the function **audio_listener_set_velocity**.\n\nThe image below shows how this could be setup for the example game given above: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/game%20assets/sounds/audio_listener_velocity.png)\n\n**Returns:** N/A",
        "vx": "The x velocity component of the listener (default 0).",
        "vy": "The y velocity component of the listener (default 0).",
        "vz": "The z velocity component of the listener (default 0)."
    },
    "audio_master_gain": {
        "desc": "With this function you can set the absolute value for the global volume of all sounds and music. It is based on a linear scale from 0 (silent) to 1 (full volume) and will affect the relative volume of all sounds and music played from within your game.\n\n**Returns:** N/A",
        "gain": "Value for the global volume (0 to 1)."
    },
    "audio_pause_all": {
        "desc": "With this function you can pause all sounds that are currently playing.\n\n**Returns:** N/A"
    },
    "audio_pause_sound": {
        "desc": "With this function you can pause any sound that is currently playing. The sound can either be a single instance of a sound (the index for individual sounds being played can be stored in a variable when using the **audio_play_sound** or **audio_play_sound_at** functions) or a sound asset, in which case all instances of the given sound will be paused.\n\n**Returns:** N/A",
        "index": "The index of the sound to pause."
    },
    "audio_pause_sync_group": {
        "desc": "This function will pause the given sync group if it is playing, with the group index being the value returned when you created the group using the function **audio_create_sync_group()**. This does not stop the sound, and calling **audio_resume_sync_group()**, will start it playing from the same position it was paused at again.\n\n**Returns:** N/A",
        "group_index": "The group index to pause."
    },
    "audio_play_in_sync_group": {
        "desc": "With this function you can assign a sound to a previously create sync group. The group index is the value returned when you created the group using the function **audio_create_sync_group()**, and the sound index is the index of any compressed sound (*.ogg or *.mp3) from the resource tree. This function only adds the sound to the group, but it does not play the sound. The function returns a unique ID value for the sound that has been added (distinct to the sound index) which can then be used as usual in all the other audio functions.\n\n**Returns:** Index",
        "group_index": "The group index to assign the sound to.",
        "sound_index": "The sound index to be assigned to the group."
    },
    "audio_play_sound": {
        "desc": "With this function you can play any sound resource in your game. You provide the sound index and assign it a priority, which is then used to determine how sounds are dealt with when the number of sounds playing is over the limit set by the function **audio_channel_num**. Lower priority sounds will be stopped in favour of higher priority sounds, and the priority value can be any real number (the actual value is arbitrary, and can be from 0 to 1 or 0 to 100, as GameMaker: Studio will prioritize them the same). The final argument is for making the sound loop and setting it to true will make the sound loop until it is stopped and setting it to false will play the sound once only.\n\nThis function will also return a unique index number for the sound being played which can then be stored in a variable so that you can then pause it or stop it with the appropriate functions. This means that if you have multiple instances of the same sound playing at any one time you can target just one instance of that sound to deal with using the audio functions.\n\n**Returns:** Index",
        "index": "The index of the sound to play.",
        "priority": "Set the channel priority for the sound.",
        "loops": "Sets the sound to loop or not."
    },
    "audio_play_sound_at": {
        "desc": "With this function you can play any sound resource at a given position within the audio space. You provide the sound index and then assign it a position within the 3D space. The default listener position is (0, 0, 0) so this means that if the listener has not been moved and you want the sound to come from the left (for example), you should set the x position to a negative value (for more information on setting the listener position see **audio_listener_position**).\n\nYou can also set a fall-off distance (0 will make the sound silent, default is 100) which will make the sound fade out as it gets further from the listener position. How the fade itself is heard will depend on the falloff reference (which is the distance under which the volume for the source would normally drop by half) and the roll off factor (which affects the sound past the falloff reference distance only). The default factor is normally 1, and the effect of the different falloff values will depend on the model chosen (for a complete guide to the different falloff models and how these values are used, please see the function **audio_falloff_set_model**).\n\nThe last two arguments are to set the sound is to loop or not and, finally, for assigning a priority to the sound. This priority is then used to determine how sounds are dealt with when the number of sounds playing is over the limit set by the function **audio_channel_num**. Lower priority sounds will be stopped in favour of higher priority sounds, and the priority value can be any real number (the actual value is arbitrary, and can be from 0 to 1 or 0 to 100, as GameMaker: Studio will prioritize them the same).\n\nThis function will return a unique index number for the sound being played which can then be stored in a variable so that you can then pause it or stop it with the appropriate functions. This means that if you have multiple instances of the same sound playing at any one time you can target just one instance of that sound to deal with using the audio functions.\n\n**Returns:** Index",
        "index": "The index of the sound to play.",
        "x": "The x position.",
        "y": "The y position.",
        "z": "The z position.",
        "falloff_ref_dist": "The falloff reference relative to the listener (clamp).",
        "falloff_max_dist": "The maximum falloff distance relative to the listener.",
        "falloff_factor": "The falloff factor (default 1).",
        "loops": "Flags the sound as looping or not.",
        "priority": "Set the channel priority for the sound."
    },
    "audio_play_sound_on": {
        "desc": "With this function you can play any sound resource through an emitter, with any changes to the emitter gain, position, pitch or velocity affecting how the user hears the final sound being played. You provide the emitter index to use, the sound index of the sound to be played and then specify whether the sound is to loop or not. Finally you can assign a priority, which is then used to determine how sounds are dealt with when the number of sounds playing is over the limit set by the function **audio_channel_num**. Lower priority sounds will be stopped in favour of higher priority sounds, and the priority value can be any real number (the actual value is arbitrary, and can be from 0 to 1 or 0 to 100, as GameMaker: Studio will prioritize them the same).\n\nThis function will also return a unique index number for the sound being played which can then be stored in a variable so that you can then pause it or stop it with the appropriate functions. This means that if you have multiple instances of the same sound playing at any one time you can target just one instance of that sound to deal with using the audio functions.\n\n**Returns:** Index",
        "emitterid": "The index of the emitter to use.",
        "sound": "The index of the sound to use.",
        "priority": "Flags the sound as looping or not.",
        "loops": "Set the channel priority for the sound."
    },
    "audio_queue_sound": {
        "desc": "This function will add the data from a buffer into the audio queue that you previously created using the function **audio_create_play_queue**. You specify the queue index to add to, and the buffer ID to get the data from as well as the position (offset) within the buffer and the number of bytes to add. Once you have added audio from a buffer to a queue, the buffer cannot be deleted until you have first freed the queue using the function **audio_free_play_queue**, and the buffer properties should match those of the the queue that you are adding the sound to.\n\n**Returns:** N/A",
        "queueid": "The index of the queue to add to.",
        "buffer_id": "The buffer to add to the queue.",
        "offset": "The offset within the source buffer to start from.",
        "length": "The length of the buffer (the number of the bytes in the buffer)."
    },
    "audio_resume_all": {
        "desc": "With this function you can resume all sounds that have been paused previously.\n\n**Returns:** N/A"
    },
    "audio_resume_sound": {
        "desc": "With this function you can resume any sound that is currently paused (after using the function **audio_pause_sound**). The sound can either be a single instance of a sound (the index for individual sounds being played can be stored in a variable when using the **audio_play_sound** or **audio_play_sound_at** functions) or a sound asset, in which case all instances of the given sound will be re-started.\n\n**Returns:** N/A",
        "index": "The index of the sound to resume."
    },
    "audio_resume_sync_group": {
        "desc": "This function will resume the given sync group if it is playing and has previously been paused (using the function **audio_pause_sync_group**). The group index is the value returned when you created the group using the function **audio_create_sync_group()**.\n\n**Returns:** N/A",
        "group_index": "The group index to resume."
    },
    "audio_set_listener_mask": {
        "desc": "When using multiple listeners on a system, you can set the bit-mask for a sound and have it heard from the flagged listener only. However, you can also set the global mask using this function and all sounds played normally will be heard from the listeners flagged by this mask, without the need to set the mask for each sound individually.\n\n**Returns:** N/A",
        "mask": "The bitmask data to set for the listeners"
    },
    "audio_set_master_gain": {
        "desc": "With this function you can set the absolute value for the global volume of all sounds and music for a specific listener. The default listener index is 0, but you can use the function **audio_get_listener_info** to get the different indices available for the target platform. The gain value is based on a linear scale from 0 (silent) to 1 (full volume) and will affect the relative volume of all sounds and music played from within your game through that listener.\n\n**Returns:** N/A",
        "listenerIndex": "The index of the listener to set the gain on.",
        "gain": "Value for the global volume (0 to 1)."
    },
    "audio_sound_gain": {
        "desc": "With this function you can fade a sound in or out over a given length of time, or it can be used to set the sound gain instantly. The time is measured in milliseconds, and the function requires that you input a final level of gain for the sound to have reached by the end of that time. This gain can be between 0 (silent) and 1 (full volume) and the scale is linear, such that a value of 0.5 would be half volume. To instantly change the gain, simply set the time argument to 0.\n\nThis function will affect all instances of the sound that are playing currently in the room if the index is a sound resource, and the final volume will be the volume at which all further instances of the sound will be played. However if you have used the index returned from a function like **audio_play_sound** it will only affect that one instance of the sound.\n\n**Returns:** N/A",
        "index": "The index of the sound to set the gain for.",
        "volume": "Value for the music volume.",
        "time": "The length for the change in gain in milliseconds."
    },
    "audio_sound_get_gain": {
        "desc": "This function will return the current gain value for the given sound. The sound can either be one referenced from an index for an individual sound being played which has been stored in a variable when using the **audio_play_sound** or **audio_play_sound_at** functions, or an actual sound asset from the resource tree.\n\n**Returns:** N/A",
        "index": "The index of the sound to get the gain of."
    },
    "audio_sound_get_listener_mask": {
        "desc": "This function will return the bit-mask data that defines which audio listeners a sound should be played from.\n\n**Returns:** Real",
        "soundID": "The unique ID of the sound to get the mask of"
    },
    "audio_sound_get_pitch": {
        "desc": "This function can be used to get the get pitch of a given sound. The sound can either be one referenced from an index for an individual sound being played which has been stored in a variable when using the **audio_play_sound** or **audio_play_sound_at** functions, or an actual sound asset from the resource tree.\n\n**Returns:** Real",
        "index": "The index of the sound to get the pitch of."
    },
    "audio_sound_get_track_position": {
        "desc": "This function will get the position (in seconds) within the sound file for the sound to play from. The sound can only be a single instance of a sound (the index for individual sounds being played can be stored in a variable when using the **audio_play_sound** or **audio_play_sound_at** functions).\n\n**Returns:** Real",
        "index": "The index of the sound to get the play position of."
    },
    "audio_sound_length": {
        "desc": "This function will return the length of the given sound in seconds. The sound can either be a referenced from index for an individual sound being played which has been stored in a variable when using the **audio_play_sound** or **audio_play_sound_at** functions, or an actual sound asset from the resource tree.",
        "index": "The index of the sound to check."
    },
    "audio_sound_pitch": {
        "desc": "This function can be used to change the pitch of a given sound. The sound can either be one referenced from an index for an individual sound being played which has been stored in a variable when using the **audio_play_sound** or **audio_play_sound_at** functions, or an actual sound asset from the resource tree. If it is an index of a playing sound, then only that instance will be changed, however when using a sound asset from the resource tree, all further instances being played of that sound will be changed.\n\nThe pitch argument is a pitch multiplier, in that the input value multiplies the current pitch by that amount, so the default value of 1 is no pitch change, while a value of less than 1 will lower the pitch and greater than 1 will raise the pitch. It is best to use small increments for this function as any value under 0 or over 5 may not be audible anyway. It is worth noting that the total pitch change permitted is clamped to (1/256) - 256 octaves, so any value over or under this will not be registered.\n\n**NOTE:** The clamped value given above is what GameMaker: Studio attempts to clamp the range to, but this value is not guaranteed on all target platforms. iOS, for example, clamps to (1/256) - 8, so you may need to experiment on each target platform and have different versions of a sound resource, each one pre-shifted, should you require higher or lower octave values.\n\n**Returns:** N/A",
        "index": "The index of the sound to change.",
        "pitch": "The pitch multiplier (default 1)."
    },
    "audio_sound_set_listener_mask": {
        "desc": "This function can be used to set the the bit-mask for a sound so that it will play only from those listeners specified. You can create a bit-mask by using the **audio_get_listener_info()** and then using the bitwise or (\"|\") to create a custom mask with those listeners that you require the sound to play from, and then apply this custom mask to the sound after you have played it. This mask will over-ride the default mask or that which you may have set using the function **audio_set_listener_mask()**.\n\n**NOTE:** This function can only be used on a sound after it has been set to play and requires the soundID as returned by the function used to play the sound.\n\n**Returns:** N/A",
        "soundID": "The unique ID of the sound to set the mask of",
        "mask": "The bitmask data to set for the sound"
    },
    "audio_sound_set_track_position": {
        "desc": "This function will set the position (in seconds) within the sound file for the sound to play from. The sound can either be a single instance of a sound (the index for individual sounds being played can be stored in a variable when using the **audio_play_sound** or **audio_play_sound_at** functions) or a sound asset. If it is a unique sound ID that you use, then the position will change immediately to the new time given, and if it is a resource tree asset then all further plays of the given sound will start at the new time. The function will ignore any value given that is longer than the length of the sound given for the \"index\" value.\n\n**Returns:** N/A",
        "index": "The index of the sound to change.",
        "time": "The time (in seconds) to set the start point to."
    },
    "audio_start_recording": {
        "desc": "This function will start recording audio from the recorder source indexed. You can get the number of recorder sources using the function **audio_get_recorder_count()**, and once you start recording the audio will be stored in a temporary buffer and start triggering an Audio Recording Asynchronous Event. This event is triggered every step that recording takes place and will create the special ds_map in the variable async_load with the following key/value pairs:\n - \"buffer_id\": the ID of the temporary buffer you can use to retrieve the audio data\n - \"channel_index\": the recording channel index (as returned by the function) this data came from\n - \"data_len\": the length of data (in bytes) you've received\n\nNote that after the asynchronous event has been triggered, the audio in the temporary buffer will be wiped, so you should be copying it's data into a custom buffer that you have previously created.\n\n**NOTE:** Most platforms support recording audio in some form, but that does not mean that all devices will permit it, even if the platform does, so you should always check that the **audio_get_recorder_count()** function returns a value greater than 0 to verify that recording devices are available before using the rest of the recording functions.\n\n**Returns:** Index",
        "recorder_index": "The index of the recorder source to use."
    },
    "audio_start_sync_group": {
        "desc": "With this function you can strat a previously create sync group playing. The group index is the value returned when you created the group using the function **audio_create_sync_group()**.\n\n**Returns:** N/A",
        "group_index": "The group index to play."
    },
    "audio_stop_all": {
        "desc": "This function will stop all sounds that are currently playing.\n\n**Returns:** N/A"
    },
    "audio_stop_recording": {
        "desc": "This function will stop recording on the given recorder channel (the channel index is returned when you call the function **audio_start_recording**). When you stop recording, no further Audio Recording Asynchronous Events will be triggered for the given recorder channel, so you would normally use this function in the actual asynchronous event to ensure that you have captured all the data.\n\n**NOTE:** Most platforms support recording audio in some form, but that does not mean that all devices will permit it, even if the platform does, so you should always check that the **audio_get_recorder_count()** function returns a value greater than 0 to verify that recording devices are available before using the rest of the recording functions.\n\n**Returns:** N/A",
        "channel_index": "The index of the recorder channel to stop."
    },
    "audio_stop_sound": {
        "desc": "This function will stop the given sound if it is currently playing. The sound can either be a single instance of a sound (the index for individual sounds being played can be stored in a variable when using the **audio_play_sound** or **audio_play_sound_at** functions) or a sound asset, in which case all instances of the given sound will be stopped.",
        "index": "The index of the sound to stop."
    },
    "audio_stop_sync_group": {
        "desc": "This function will stop the given sync group if it is playing, with the group index being the value returned when you created the group using the function **audio_create_sync_group()**.",
        "group_index": "The group index to stop playing."
    },
    "audio_sync_group_debug": {
        "desc": "This function can be used to display debug information about any given sync group (the group index is the value returned when the group was created using the function **audio_create_sync_group()**). You can call the function with a value of -1 to switch off the overlay.\n\nWhen you are debugging the audio sync groups, the overlay will show Which sync groups is debugging\n\n - How many channels are in it\n\n - How many times the sync group has failed (this means it's tried to do too much work)\n\n - A list of the channels\n    - Red means this channel is not currently doing any work\n    - Yellow means the channel is in initial state (not yet decoding or playing)\n    - Green means the track is currently seeking/decoding\n    - Purple means the channel has run out of data\n\n - A profiling bar that shows what work the decoding thread is doing\n    - blue means a file is being read for the first time\n    - red means the thread is reading a file to find out where to read from\n    - green means the thread is decoding data\n    - purple means the thread is sleeping until it needs to work\n\nNote that for general debugging of audio, you also have the function **audio_debug()**.\n\n**Returns:** N/A",
        "group_index": "The group index to debug, or -1 to switch off the debugging."
    },
    "audio_sync_group_get_track_pos": {
        "desc": "This function returns the current play position of the given sync group. The group index is the value returned when you created the group using the function **audio_create_sync_group()**, and the return value is the time in seconds that the tracks have been playing.\n\n**Returns:** Real",
        "group_index": "The group index to get the position of."
    },
    "audio_sync_group_is_playing": {
        "desc": "This function can be used to check if any audio in a synchronised group is playing. You are required to supply the synch group ID as returned by the function **audio_create_sync_group()**.",
        "group_index": "The group index to check."
    },
    "audio_system": {
        "desc": "This function returns whether the current sound system is the legacy or the normal one.\n\nThis function is important only if you are using the HTML5 target module, as some browsers are not compatible with the new audio system, and so GameMaker: Studio will automatically switch back to the legacy audio.\n\n**Returns:** Constant"
    },
    "base64_decode": {
        "desc": "This function will convert a string encoded previously using base64 format, into standard text. Base64 is a commonly used encoding scheme that is often used for any media that needs to be stored or transferred over the internet as text, and renders the output unreadable to the human eye.\n\n**Returns:** String",
        "string": "The string to decode."
    },
    "base64_encode": {
        "desc": "This function will convert a string into a base64 format encoded string. This is a commonly used encoding scheme that is often used for any media that needs to be stored or transferred over the internet as text, and renders the output unreadable to the human eye.\n\n**Returns:** String",
        "string": "The string to encode."
    },
    "browser_input_capture": {
        "desc": "With this function you can set whether the browser window should capture all input (set it to false) or whether the game should capture the input (set it to true). Note that this function is for use with the HTML5 module only.\n\n**Returns:** N/A",
        "enable": "Turn capture on (true) or off (false)."
    },
    "buffer_async_group_begin": {
        "desc": "This function is called when you want to begin the saving out of multiple buffers to multiple files. The \"groupname\" is a string and will be used as the directory name for where the files will be saved, and should be used as part of the file path when loading the files back into the IDE later (using any of the **buffer_load** functions). This function is only for use with the **buffer_save_async()** function and you must also finish the save definition by calling **buffer_async_group_end()** function otherwise the files will not be saved out.\n\nNote that for the console platforms (like PS4 for example), the \"groupname\" will be used as the save slot description, and using this function can help you avoid having the UI show for every file that is being saved out.\n\n**Returns:** N/A",
        "groupname": "The name of the group (as a string)."
    },
    "buffer_async_group_end": {
        "desc": "This function finishes the definition of a buffer save group. You must have previously called the function **buffer_async_group_begin()** to initiate the group, then call the function **buffer_save_async()** for each file that you wish to save out. Finally you call this function, which will start the saving of the files."
    },
    "buffer_async_group_option": {
        "desc": "With this function you can set some platform specific options for the buffer group being saved. The options available are as follows:\n\n - \"subtitle\" or \"slottitle\": The value for this option would be a string, which will be shown to the user when managing their save data in the OS. This is only important when saving data, not when loading again.\n\n - \"showdialog\": The value for this option is a boolean true or false. If set to true, when you save or load GameMaker: Studio will show the System UI, otherwise it will do a quicksave/quickload with no UI shown. You normally only need this if you're supporting multiple save slots to allow the user to pick a slot, but if you just support one slot per user, set this to false.\n\n - \"savepadindex\": For this option you would specify the pad index of the player who is saving or loading and the system will write data to and read data from this player's save folder.\n\n - \"saveslotsize\": This option requires that you specify the actual size in bytes you want to save (so you can do a buffer_seek and buffer_tell to get that, for example). Note that it is not obligatory to supply this value as all saves are pre-assigned a minimum space, which is normally about 10MB or so.\n\n**IMPORTANT**: This function is currently only valid for the PlayStation target module. on all the other targets it will do nothing.",
        "optionname": "The option to set.",
        "optionvalue": "The value to set (can be string or real, depending on the option)."
    },
    "buffer_base64_decode": {
        "desc": "With this function you can decode a base64 encoded string (created using the **buffer_base64_encode** function) into a buffer. This function will create the buffer (as a 1 byte aligned \"grow\" buffer) and return the unique index for the buffer which should be used in all further function calls.\n\nNOTE: It's important that you remove any dynamically created resources like this from memory when you no longer need them to prevent memory leaks, so when you are finished with the buffer that you have created you should free it up again using **buffer_delete**.",
        "string": "The base64 encoded string to decode"
    },
    "buffer_base64_decode_ext": {
        "desc": "With this function you can decode a base64 encoded string (created using the **buffer_base64_encode()** function) into a buffer. Unlike the function **buffer_base64_decode()**, this will not create a buffer for you, but rather you should already have created the buffer (see **buffer_create**), the id of which you would then use with this function. The \"offset\" is the position within the buffer to decode the given string (in bytes).",
        "buffer": "The index of the buffer to decode the string into.",
        "string": "The base64 encoded string to decode.",
        "offset": "The data offset value."
    },
    "buffer_base64_encode": {
        "desc": "This function will convert the data from the given buffer into a base64 format encoded string. This is a commonly used encoding scheme that is often used for any media that needs to be stored or transferred over the internet as text, and renders the output unreadable to the human eye. To use this you need to specify an already created buffer, the offset value (which is the point within the buffer at which you wish to start encoding) as well as the size, in bytes, of the buffer memory to encode.",
        "buffer": "The index of the buffer to use.",
        "offset": "The data offset value.",
        "size": "The size of the buffer."
    },
    "buffer_copy": {
        "desc": "This function can be used to copy a segment (or all) of the data stored in one buffer to another. When using two buffers and copying from one to the other, both buffers must have previously been created using the **buffer_create** function (for example), and you can specify a data offset (in bytes) for the start point of the data to be copied from the source buffer relative to the start of the buffer, as well as another data offset to define the position to copy the data to in the destination buffer.\n\nNOTE: You cannot copy to the same buffer.",
        "src_buffer": "The index of the buffer to copy from.",
        "src_offset": "The data offset to start copying from (in bytes).",
        "size": "The size of the data to copy (in bytes).",
        "dest_buffer": "The index of the buffer to copy to.",
        "dest_offset": "The offset position to copy the data to (in bytes)."
    },
    "buffer_copy_from_vertex_buffer": {
        "desc": "This function can be used to copy some (or all) of the vertex data stored in one vertex buffer into a previously created regular buffer. When copying from a vertex buffer into a regular buffer with this function, both buffers must have previously been created (using the **vertex_create_buffer()** and **buffer_create** functions, for example). You can specify the range of vertex data that you wish to copy into the buffer, where the start vertex can be anywhere between 0 and the number of vertices -1, and you can give the number of vertices from that point on to copy. You can use the function **vertex_get_number()** on the vertex buffer to get the total number of vertices stored. Finally you give the buffer index to copy the vertex data into, as well as a data offset to define the position to copy the vertex data to in the destination buffer.",
        "vertex_buffer": "The index of the vertex buffer to copy from.",
        "start_vertex": "The starting vertex.",
        "num_vertices": "The total number of vertices to use.",
        "dest_buffer": "The index of the buffer to copy to.",
        "dest_offset": "The offset position to copy the data to (in bytes)."
    },
    "buffer_create": {
        "desc": "You use this function to allocate a portion of memory as a buffer in your game, with the function returning the unique buffer id that should be stored in a variable and used for all further function calls to the buffer. The buffer can then be used to store different types of data (specified when you write to the buffer using the **buffer_write** function)\n\nApart from the buffer type, you will also have to set the byte alignment for the buffer. This value will vary depending on the data that you wish to store in the buffer, and in most cases a value of 1 is perfectly fine. However, be aware that for some operations a specific alignment is essential, and an incorrect alignment may cause errors (for further details on alignment see Buffers). The following is a general guide to show which values are most appropriate for each data type (when in doubt, use an alignment of 1):\n\n - Strings should be aligned to 1 byte.\n\n - Signed or unsigned 8bit integers can be aligned to any value, but note that for a fast buffer (see **buffer_write**) it must be aligned to 1.\n\n - Signed or unsigned 16bit integers should be aligned to 2 bytes.\n\n - Signed or unsigned 32bit integers should be aligned to 4 bytes\n\n - Floats of up to 16bits should be aligned to 2 bytes. (Not currently supported!)\n\n - Floats of up to 32bits should be aligned to 4 bytes.\n\n - Floats of up to 64bits should be aligned to 8 bytes.\n\nNOTE: Byte alignment can be very important as the wrong choice may adversely affect performance.\n\nNOTE: It's important that you remove any dynamically created resources like this from memory when you no longer need them to prevent memory leaks, so when you are finished with the buffer that you have created you should free it up again using buffer_delete.",
        "size": "The size (in bytes) of the buffer.",
        "buffer_type": "The type of buffer to create (see the constants list below).",
        "alignment": "The byte alignment for the buffer"
    },
    "buffer_create_from_vertex_buffer": {
        "desc": "You use this function to allocate a portion of memory as a buffer in your game filled with the data from a previously created vertex buffer. The function returns a unique buffer id that should be stored in a variable and used for all further function calls to the buffer. The function takes the id for the vertex buffer to use (as returned by the function **vertex_create_buffer()**, for example) with the following constants being used to define the buffer type\n\nApart from the buffer type, you will also have to set the byte alignment for the buffer. This value will vary depending on the data that you wish to store in the buffer, and in most cases a value of 1 is perfectly fine. However, be aware that for some operations a specific alignment is essential, and an incorrect alignment may cause errors (for further details on alignment see Buffers). The following is a general guide to show which values are most appropriate for each data type (when in doubt, use an alignment of 1):\n\n - Strings should be aligned to 1 byte.\n\n - Signed or unsigned 8bit integers can be aligned to any value, but note that for a fast buffer (see **buffer_write**) it must be aligned to 1.\n\n - Signed or unsigned 16bit integers should be aligned to 2 bytes.\n\n - Signed or unsigned 32bit integers should be aligned to 4 bytes\n\n - Floats of up to 16bits should be aligned to 2 bytes. (Not currently supported!)\n\n - Floats of up to 32bits should be aligned to 4 bytes.\n\n - Floats of up to 64bits should be aligned to 8 bytes.\n\nNOTE: Vertex buffers are 1 byte aligned, but you can create the buffer with any alignment depending on how you want to treat the data, as the vertex data is simply a raw memory copy into the buffer.\n\nNOTE: It's important that you remove any dynamically created resources like this from memory when you no longer need them to prevent memory leaks, so when you are finished with the buffer that you have created you should free it up again using buffer_delete. Also note that the vertex buffer used to create the new buffer is not removed from memory either and you should use the function vertex_delete_buffer() when it is no longer required.",
        "vertex_buffer": "The vertex buffer index to use.",
        "type": "The type of buffer to create (see the constants list below).",
        "alignment": "The byte alignment for the buffer"
    },
    "buffer_create_from_vertex_buffer_ext": {
        "desc": "You use this function to allocate a portion of memory as a buffer in your game filled with the data from a previously created vertex buffer. The function returns a unique buffer id that should be stored in a variable and used for all further function calls to the buffer. The function takes the id for the vertex buffer to use (as returned by the function **vertex_create_buffer()**, for example) with the following constants being used to define the buffer type\n\nApart from the buffer type, you will also have to set the byte alignment for the buffer. This value will vary depending on the data that you wish to store in the buffer, and in most cases a value of 1 is perfectly fine. However, be aware that for some operations a specific alignment is essential, and an incorrect alignment may cause errors (for further details on alignment see Buffers). The following is a general guide to show which values are most appropriate for each data type (when in doubt, use an alignment of 1):\n\n - Strings should be aligned to 1 byte.\n\n - Signed or unsigned 8bit integers can be aligned to any value, but note that for a fast buffer (see **buffer_write**) it must be aligned to 1.\n\n - Signed or unsigned 16bit integers should be aligned to 2 bytes.\n\n - Signed or unsigned 32bit integers should be aligned to 4 bytes\n\n - Floats of up to 16bits should be aligned to 2 bytes. (Not currently supported!)\n\n - Floats of up to 32bits should be aligned to 4 bytes.\n\n - Floats of up to 64bits should be aligned to 8 bytes.\n\nNOTE: Vertex buffers are 1 byte aligned, but you can create the buffer with any alignment depending on how you want to treat the data, as the vertex data is simply a raw memory copy into the buffer.\n\nThe final two arguments are used to specify the range of vertex data that you wish to copy into the newly created buffer. The start vertex can be anywhere between 0 and the number of vertices -1, and then you give the number of vertices from that point to copy. You can use the function **vertex_get_number()** on the vertex buffer to get the total number of vertices stored.\n\nNOTE: It's important that you remove any dynamically created resources like this from memory when you no longer need them to prevent memory leaks, so when you are finished with the buffer that you have created you should free it up again using **buffer_delete**. Also note that the vertex buffer used to create the new buffer is not removed from memory either and you should use the function **vertex_delete_buffer()** when it is no longer required.",
        "vertex_buffer": "The vertex buffer index to use.",
        "type": "The type of buffer to create (see the constants list below).",
        "alignment": "The byte alignment for the buffer",
        "start_vertex": "The starting vertex.",
        "num_vertices": "The total number of vertices to copy."
    },
    "buffer_delete": {
        "desc": "With this function you can delete a buffer previously have created using the function **buffer_create** from memory, releasing the resources used to create it and removing any data that it may currently contain.\n\nNOTE: It's important to always remove any dynamically created resources from memory when you no longer need them to prevent memory leaks.",
        "buffer": "The index of the buffer to delete."
    },
    "buffer_exists": {
        "desc": "This function can be used to check a variable to see if it holds a valid buffer ID value or not. If it does the function will return true otherwise it will return false.",
        "buffer": "The index of the buffer to check."
    },
    "buffer_fill": {
        "desc": "This function can be used to fill a previously created buffer with a given data type and value. The data you fill the buffer with must be in agreement with the \"type\" argument of this function, meaning that you can't try to fill with a string and use the unsigned 16bit integer type, for example. The type constants are the same as those used by the **buffer_read** and **buffer_write** functions. The \"size\" is the size of the buffer (in bytes) that you wish to fill, while the offset is the offset value (also in bytes) from the start of the buffer to start the fill from.",
        "buffer": "The index of the buffer to fill.",
        "offset": "The data offset value (in bytes).",
        "type": "The type of data that is to be written to the buffer",
        "value": "The data to write.",
        "size": "The size of the buffer (in bytes) that you wish to fill."
    },
    "buffer_get_address": {
        "desc": "With this function you can get the a pointer to the raw, aligned buffer address. This is primarily for use with extensions as you can pass this value through to them, allowing them to access the buffer data. Note that there are a few things you cannot do with the buffer when accessing from an extension:\n\n - You cannot free the memory.\n\n - You cannot resize the memory.\n\n - You cannot not write past the buffer address plus the buffer size (you can use the **buffer_get_size** function for this) or you will get an out of bounds error.",
        "buffer": "The index of the buffer to use."
    },
    "buffer_get_alignment": {
        "desc": "With this function you can get the a byte alignment for the given buffer ID.",
        "buffer": "The index of the buffer to check."
    },
    "buffer_get_size": {
        "desc": "With this function you can get the size of the given buffer in bytes.",
        "index": "The index of the buffer to get the size of."
    },
    "buffer_get_surface": {
        "desc": "With this function you can write the information from a surface to a given buffer. The buffer must have been created previously and should be a 1byte aligned grow buffer of an approximate size (in bytes) of the surface you are going to write. You can choose the copy \"mode\" for the data being stored which is set by the constants listed below, as well as the offset and modulo values. Both offset and modulo are byte values, with the offset defining the start position within the buffer and modulo being the number of bytes left at the end of every line (for storing additional data). Note that the function writes each pixel of the surface to the buffer using a BGRA formatting on the Windows target, but on other targets it may be different depending on the OS or even the device.\n\n0 (Constant): Copies all data from the surface.",
        "buffer": "The index of the buffer to use.",
        "surface": "The index of the surface to use.",
        "mode": "The data to get from the surface (see the list of constants below).",
        "offset": "The data offset value.",
        "modulo": "The offset from the end of the line to the start of the next"
    },
    "buffer_get_type": {
        "desc": "With this function you retrieve the type of buffer that is beinf referenced by a buffer ID value.",
        "buffer": "The index of the buffer to check."
    },
    "buffer_load": {
        "desc": "This function will load the buffer data that was previously saved using the **buffer_save** functions into a new buffer. This new buffer is created by the function as a \"grow\" buffer with a byte alignment of 1, and the new buffer id is returned. This ID should be stored in a variable and used in all further function calls to this buffer.\n\nNOTE: It's important that you remove any dynamically created resources like this from memory when you no longer need them to prevent memory leaks, so when you are finished with the buffer that you have created you should free it up again using **buffer_delete**.",
        "filename": "The name of the file to load from."
    },
    "buffer_load_async": {
        "desc": "With this function you can load a file that you have created previously using the **buffer_save** function (or any of the other functions for saving buffers) into a buffer. The \"offset\" defines the start position within the buffer for loading (in bytes), and the \"size\" is the size of the buffer area to be loaded from that offset onwards (also in bytes).\n\nThe function returns a unique ID value which can then be used to check the asynchronous event *async_load* ID value, as shown in the extended example below. The *async_load* map in the event will have the following two key/value pairs:\n\n - \"id\": the ID of the async function as returned by the save function.\n\n - \"status\": will return true if the data was saved/loaded correctly, and false otherwise.",
        "bufferid": "The index of the buffer to load.",
        "filename": "The name of the file to load.",
        "offset": "The offset within the buffer to load to (in bytes).",
        "size": "The size of the buffer area to load (in bytes)."
    },
    "buffer_load_ext": {
        "desc": "This function will load the buffer data that was previously saved using the **buffer_save** functions into an already created buffer. You give the id of the previously created buffer to load into, then the saved buffer file to load, and finally the offset from the start of the buffer (in bytes) that you wish to load the data to.",
        "bufferid": "The index of the buffer to load into.",
        "filename": "The name of the file to load from.",
        "offset": "The offset within the buffer to load to (in bytes)."
    },
    "buffer_load_partial": {
        "desc": "",
        "bufferid": "",
        "filename": "",
        "src_offset": "",
        "src_len": "",
        "dest_offset": ""
    },
    "buffer_md5": {
        "desc": "In cryptography, MD5 (Message-Digest algorithm 5) is a widely used cryptographic hash function with a 128-bit hash value and has been employed in a wide variety of security applications. It is also commonly used to check the integrity of data. This function will take the input data from a given buffer (or part of the buffer) and return the 32-character hexadecimal MD5 hash that is unique to that data. In this way you can generate a secure key which can be stored and used to check the integrity of the information being sent to (or received from) an external server (for example). When applying this to buffers using this function you must specify the buffer id of the buffer to use, then an offset value (in bytes) for where to begin, and then a size (again in bytes) for the region to be hashed.",
        "buffer": "The index of the buffer to use.",
        "offset": "The data offset value.",
        "size": "The size of the buffer."
    },
    "buffer_peek": {
        "desc": "With the **buffer_read** function, you can read data from the given buffer at the current \"seek\" position, with each piece of data being read advancing this position by the bytes being read or written. However, it may be necessary for you to read a given piece of data without wanting to change the current seek position, and that's when you would use this function. You simply supply the function with a buffer id, and then an offset position (from the buffer start) within that buffer to read from, as well as the data type that you are wanting to read.\n\nNOTE: Using the incorrect data type for the data being read will result in erroneous values!",
        "buffer": "The index of the buffer to use.",
        "offset": "The offset position (in bytes) within the buffer to read the given data from.",
        "type": "The type of data that is to be read from the buffer"
    },
    "buffer_poke": {
        "desc": "With the buffer_write function, you can write data to the given buffer at the current \"seek\" position, with each piece of data advancing this position by the bytes being written or read. However, it may be necessary for you to change a given piece of data without wanting to change the current seek position, and that's when you would use this function. You simply supply the function with a buffer index, and then the offset position from the buffer start (in bytes) within that buffer to write to, as well as the data type and the value to be written.",
        "buffer": "The index of the buffer to use.",
        "offset": "The offset position (in bytes) within the buffer to write the given data to.",
        "type": "The type of data that is to be written to the buffer",
        "value": "The data to add to the buffer, in accordance with the type specified."
    },
    "buffer_read": {
        "desc": "This function can be used to read data from a previously created buffer. The return value will depend on the type of data that you are reading, which in itself is defined by the following constants\n\nNOTE: Using the incorrect data type for the data being read will result in erroneous values!",
        "buffer": "The index of the buffer to read from.",
        "type": "The type of data that is to be read from the buffer (see the list of constants below)."
    },
    "buffer_resize": {
        "desc": "With this function you can resize a given buffer to be the size (in bytes) that you specify.",
        "buffer": "The index of the buffer to change the size of.",
        "newsize": "The new size of the buffer (in bytes)."
    },
    "buffer_save": {
        "desc": "With this function you can save the contents of a buffer to a file, ready to be read back into memory using the **buffer_load** function.",
        "buffer": "The index of the buffer to save.",
        "filename": "The name of the file to save as."
    },
    "buffer_save_async": {
        "desc": "With this function you can save part of the contents of a buffer to a file, ready to be read back into memory using the **buffer_load** function (or any of the other functions for loading buffers). The \"offset\" defines the start position within the buffer for saving (in bytes), and the \"size\" is the size of the buffer area to be saved from that offset onwards (also in bytes). This function works asynchronously, and so the game will continue running while being saved. This function will trigger an Asynchronous Load/Save Event where you can check to ensure that the save has occurred correctly.\n\nNote that you can save out multiple buffers in one by calling this function multiple times between calls to **buffer_async_group_begin()** and **buffer_async_group_end()** (see those functions for further information on this).\n\nThe function returns a unique ID value which can then be used to check the asynchronous event *async_load* ID value, as shown in the extended example below. The *async_load* map in the event will have the following two key/value pairs:\n\n - \"id\": the ID of the async function as returned by the save function.\n\n - \"status\": will return true if the data was saved/loaded correctly, and false otherwise.",
        "buffer": "The index of the buffer to save.",
        "type": "The name of the file to save as.",
        "offset": "The offset within the buffer to save from (in bytes).",
        "size": "The size of the buffer area to save (in bytes)."
    },
    "buffer_save_ext": {
        "desc": "With this function you can save part of the contents of a buffer to a file, ready to be read back into memory using the **buffer_load** function. The \"offset\" defines the start position within the buffer for saving (in bytes), and the \"size\" is the size of the buffer area to be saved from that offset onwards (also in bytes).",
        "bufferid": "The index of the buffer to save.",
        "filename": "The name of the file to save as.",
        "offset": "The offset within the buffer to save from (in bytes).",
        "size": "The size of the buffer area to save (in bytes)."
    },
    "buffer_seek": {
        "desc": "This function can be used to move through a buffer, finding the start, the end, or a position relative to that which was last used when reading or writing data. The \"offset\" value is the offset (in bytes) to add to the given seek position, for example, if the base is relative and the offset is 4, then the buffer position will move along 4 bytes from its current position. Please note the following:\n\n - You can use negative values for the offset to seek back through the buffer as well as positive values.\n\n - If the buffer is of the \"wrap\" type and you offset past the end of the buffer, the seek position will also wrap.\n\n - If the buffer is not of the \"wrap\" type, the seek will clamp to the beginning or end of the buffer, even when the offset would take the seek outside of the buffer limits.",
        "bufferid": "The index of the buffer to use.",
        "base": "The base position to seek.",
        "offset": "The data offset value."
    },
    "buffer_set_surface": {
        "desc": "With this function you can write the information from a buffer to a given surface. Both the buffer and the surface must have been created previously. You can choose the copy \"mode\" for the data being stored which is set by the constants listed below, as well as the offset and modulo values. Both offset and modulo are byte values, with the offset defining the start position within the buffer and modulo being the number of bytes that were left at the end of every line (for storing additional data) when the buffer was written to.\n\nNOTE: This function is currently only available for the Windows and Playstation 4 target platforms.",
        "buffer": "The index of the buffer to use.",
        "surface": "The index of the surface to use.",
        "mode": "The data to get from the buffer (see the list of constants below).",
        "offset": "The data offset value.",
        "modulo": "The offset from the end of the line to the start of the next"
    },
    "buffer_sha1": {
        "desc": "In cryptography, SHA-1 is a cryptographic hash function designed by the United States National Security Agency and is employed in several widely used applications and protocols like the popular Git where it is used to check for file changes. This function will take input data from a buffer and returns a 160 bit message digest in ASCII format. In this way you can generate a secure key which can be stored and used to check the integrity of the information being sent to (or received from) an external server (for example). When applying this to buffers using this function you must specify the buffer id of the buffer to use, then an offset value (in bytes) for where to begin, and then a size (again in bytes) for the region to be hashed.",
        "bufferid": "The index of the buffer to use.",
        "offset": "The data offset value.",
        "size": "The size of the buffer."
    },
    "buffer_sizeof": {
        "desc": "This function will return the size (in bytes) of any of the given data constants.",
        "type": "The type of data that is to be checked."
    },
    "buffer_tell": {
        "desc": "When you read or write data to a buffer using the **buffer_read** or **buffer_write** the current \"seek\" position is advanced by the bytes written or read, and with this function you can get the current \"seek\" position for use in other buffer functions. For example, if your buffer alignment is set to 4 bytes and you write a single piece of data which is 1 byte in size then do a buffer_tell, you'll get an return value of 1. However, if you write another piece of data, also 1 byte in size, then do a **buffer_tell**, you'll get a return value of 5 as the alignment has \"padded\" the data to that position.",
        "buffer": "The index of the buffer to use."
    },
    "buffer_write": {
        "desc": "This function can be used to write data to a previously created buffer. The data you write must be in agreement with the \"type\" argument of this function, meaning that you can't try to write a string as an unsigned 16bit integer, for example.",
        "buffer": "The index of the buffer to write to.",
        "type": "The type of data that is to be written to the buffer",
        "value": "The data to write."
    },
    "ceil": {
        "desc": "This function takes any real number and rounds it up to the nearest integer. Care should be taken with this function as one common mistake is to use it round up a random value and expect it always to be greater than 1, ie: \n\n\n```int = ceil(random(5));```\n\nNow, you would expect this code to always give an integer between 1 and 5, but this may not always be the case as there is a very small possibility that the random function will return 0, and rounding up 0 still gives you 0. This is a remote possibility but should be taken into account when using this function.",
        "x": "The number to change."
    },
    "choose": {
        "desc": "Sometimes you want to specify something other than numbers for a random selection, or the numbers you want are not in any real order or within any set range. In these cases you would use choose() to generate a random result. For example, say you want to create an object with a random sprite at the start, then you could use this function to set the sprite index to one of a set of sprites. Note that you can have as many as you require (more arguments will mean that the function will be slower to parse).\n\nNOTE: This function will return the same value every time the game is run afresh due to the fact that GameMaker: Studio generates the same initial random seed every time to make debugging code a far easier task. To avoid this behaviour use **randomize** at the start of your game.",
        "valmax": "An input value that can be string, integer, variable or constant."
    },
    "chr": {
        "desc": "This function returns a string containing the character which relates to the input Unicode code for displaying. This character depends on the current drawing font's character set codepage and if no font is set, it will use the default code page for the machine.",
        "val": "The Unicode code to get the string from."
    },
    "clamp": {
        "desc": "With this function you can maintain an input value between a specified range.",
        "val": "The value to clamp.",
        "min": "The minimum value to clamp between.",
        "max": "The maximum value to clamp between."
    },
    "clickable_add": {
        "desc": "With this function you can create a custom, clickable, icon that acts as a \"button\" outside of the game canvas, but within the browser window itself. The function will return an id value which must be stored in a variable to be used in all further button functions that reference the new icon. This function is very useful to prevent the browser creating a pop-up window when clicking on the button as it is all done through GameMaker: Studio itself.\n\nYou must first set the position, which is relative to the (0,0) of the browser window (top left corner) and then give the texture page entry for the sprite you wish the button icon to have (see: **sprite_get_tpe**). You can then specify either a URL to open or a script (from the resource tree of GameMaker: Studio) to be opened or run. The \"target\" parameter that you specify is the same as the standard JavaScript \"name\" value when you use the open() method (be aware that all but '_self' may result in the browser blocking, or asking the user if they wish to allow it) and the \"params\" argument is the same as the JavaScript \"specs\" parameter for controlling what properties the new window/tab should display (not all browsers may support all features). If you are using the icon to run an internal script, these last two arguments can be left as empty strings \"\".\n\nIt is also worth noting that if the URL argument you pass in is the name of a script (ie: it doesn't start with \"http://\") AND the script is called gmcallback_* then you can get direct feeds into an html5 event. GameMaker: Studio function names are not obfuscated if they begin with *gmcallback_*.",
        "x": "The x position within the window.",
        "y": "The y position within the window.",
        "spritetpe": "The texture page entry for the sprite to be used (use **sprite_get_tpe**).",
        "URL": "The URL (website address) to link to, or the script to be run.",
        "target": "This is the target area to open the URL in (see description).",
        "params": "The various parameters for the icon (see description)."
    },
    "clickable_add_ext": {
        "desc": "With this function you can create a custom, clickable, icon that acts as a \"button\" outside of the game canvas, but within the browser window itself. The function will return an id value which must be stored in a variable to be used in all further button functions that reference the new icon. This function is very useful to prevent the browser creating a pop-up window when clicking on the button as it is all done through GameMaker: Studio itself.\n\nThis function works exactly the same as the **clickable_add** function, where you must set the position relative to the (0,0) of the browser window, give the texture page entry for the sprite you wish the button icon to have (see: **sprite_get_tpe**), specify either a URL to open or a script (from the resource tree of GameMaker: Studio) to be opened or run then set the target and parameters to use. However this function also has two additional options that permit you to set the icon alpha from 0 (fully transparent) to 1 (fully opaque) and the scale of the icon, which is a multiplier value applied to the sprite used. So a value of 1 is the default scale, while (for example) 0.5 would be half scale and 2 would be double.\n\nIt is also worth noting that if the URL argument you pass in is the name of a script (ie: it doesn't start with \"http://\") AND the script is called gmcallback_* then you can get direct feeds into an html5 event. GameMaker: Studio function names are not obfuscated if they begin with *gmcallback_*.",
        "x": "The x position within the window.",
        "y": "The y position within the window.",
        "spritetpe": "The texture page entry for the sprite to be used (use **sprite_get_tpe**).",
        "URL": "The URL (website address) to link to, or the script to be run.",
        "target": "This is the target area to open the URL in (see description).",
        "params": "The various parameters for the icon (see description).",
        "scale": "The scale of the icon (default 1).",
        "alpha": "The image alpha of the icon (default 1)."
    },
    "clickable_change": {
        "desc": "With this function you can change the sprite and position of a clickable icon previously created with **clickable_add**. Please note that the position is based on the window, not the canvas, (0,0) position and that the sprite must be referenced directly from the texture page (see: **sprite_get_tpe**).",
        "index": "The index of the clickable icon to change.",
        "spritetpe": "The texture page entry for the sprite to be used (use **sprite_get_tpe**).",
        "x": "The new x position within the window.",
        "y": "The new y position within the window."
    },
    "clickable_change_ext": {
        "desc": "With this function you can change the sprite and position of a clickable icon previously created with **clickable_add**. Bear in mind that the position is based on the window, not the canvas, (0,0) position and that the sprite must be referenced directly from the texture page (see: **sprite_get_tpe**). This function also permits you to change the scale of the sprite used (as a multiplier so that 1 is the default, 0.5 would be half and 2 would be double) and the alpha value from 0 (fully transparent) to 1 (fully opaque) for the final icon on the screen.",
        "index": "The index of the clickable icon to change.",
        "spritetpe": "The texture page entry for the sprite to be used (use **sprite_get_tpe**).",
        "x": "The new x position within the window.",
        "y": "The new y position within the window.",
        "scale": "The scale of the icon (default 1).",
        "alpha": "The image alpha of the icon (default 1)."
    },
    "clickable_delete": {
        "desc": "This function must be used to remove a clickable icon previously created with **clickable_add** from the game window.",
        "index": "Index of the clickable icon to remove."
    },
    "clickable_exists": {
        "desc": "This function returns whether a clickable DOM icon has been created with the specified index exists or not. Please note, that the value used for checking must have been initialised previously or else you will get an error causing GameMaker: Studio to close.",
        "index": "The index of the clickable to check."
    },
    "clickable_set_style": {
        "desc": "This function lets you set the CSS style properties for the given button via the key/value pairs in the provided ds_map. You need to have previously created the both the button element (**using clickable_add()**) and the ds_map previously and supply the stored indices as arguments.",
        "index": "The index of the clickable icon to style.",
        "map": "The index of the ds_map to set the style from."
    },
    "clipboard_get_text": {
        "desc": "This function will return a string of the text contained on the clipboard. if no text is stored it will return an empty string \"\".\n\nNOTE: This function is only valid for the **Windows** target."
    },
    "clipboard_has_text": {
        "desc": "This function will return true if the clipboard contains text or false if it does not.\n\nNOTE: This function is only valid for the **Windows** target."
    },
    "clipboard_set_text": {
        "desc": "This function will set the clipboard to hold the defined string. You can set it to an empty string \"\" to effectively clear the clipboard of text.\n\nNOTE: This function is only valid for the **Windows** target.",
        "str": "The text (as a string) to set the clipboard to hold."
    },
    "cloud_file_save": {
        "desc": "This function will commit a file to the chosen cloud service for storage. The function will return a unique id value that should then be used in the appropriate asynchronous event to identify the ds_map that is returned as a \"call back\" from the cloud service. The file should contain all the information that you need to save for your game as you can only store one single \"data blob\" to the cloud, and running this function again will overwrite any previously stored values (as will using the **cloud_string_save** function). The description should be a short string of information that describes the save, eg: \"Level2, Stage2\".\n\nFor further information on the returned asynchronous data, please see the function **cloud_synchronise**.",
        "filename": "The file to be uploaded (as a string).",
        "description": "A brief description of the data being stored."
    },
    "cloud_string_save": {
        "desc": "This function will commit a string to the chosen cloud service for storage. The function will return a unique id value that should then be used in the appropriate asynchronous event to identify the ds_map that is returned as a \"call back\" from the cloud service. The string should contain all the information that you need to save for your game as you can only store one single \"data blob\" to the cloud, and running this function again will overwrite any previously stored values (as will using the **cloud_file_save** function). The description should be a short string of information that describes the save, eg: \"Level2, Stage2\".\n\nFor further information on the returned asynchronous data, please see the function **cloud_synchronise**.",
        "data": "The data string to be uploaded.",
        "description": "A brief description of the data being stored."
    },
    "cloud_synchronise": {
        "desc": "This function would normally be called at the start of a new game and is used to retrieve the current status of the cloud service at game start up. The function returns a unique id value which would then be used in the Asynchronous Cloud Event to retrieve the relevant information from the ds_map that is created.\n\nThis function will send off to the cloud for data, which will then trigger the appropriate asynchronous event. In this event, you can check the returned *async_load* **ds_map** for the following values:\n\n - \"status\": This holds the status code, where a negative value denotes an error, a description of which will be contained in the “errorString”. A value of 0 (or a positive value) indicates a success(see below for exact values), and the “resultString” will contain the returned data or a success message.\n\n - \"id\": The id which was returned from the called function. If you fire off a series of cloud_ requests then you need to know which one you are getting the reply to, and so you would use this value to compare to the value you stored when you originally sent the request to find the right one.\n\n - \"description\": The description of the last uploaded file.\n\n - \"resultString\": This holds a string which is the data blob returned from the cloud.\n\n - \"errorString\": returns an Error String for any error.\n\nThe exact meaning of the returned \"status\" map entry is explained in the following table: ![](https://gmlsupport.liaronce.win/images-in-intellisense/1.png)"
    },
    "code_is_compiled": {
        "desc": "This function will return true if the platform compiles outside of the virtual machine, such as for the YYC and JS platforms."
    },
    "collision_circle": {
        "desc": "Collision circle creates a circular zone of the radius given by the user around the points x1,y1 and then checks that zone for a collision with any instance of the object specified by the argument \"obj\". This check can be either precise or not, but for precise collisions to be enabled, the object or instance that you are checking for must also have precise collisions enabled for their sprite. If not, the default check is based on bounding boxes. The following image illustrates how this works: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/movement%20and%20collisions/collisions/collision_circle_illustration.png)\n\nHere, the instance in the middle is using a collision circle to check for ball objects. Now, the blue ones do not have a precise bounding box and as you can see, even if the sprite is not actually touching the circle, the collision can still happen (even if you set the precise option in the function to true) as the bounding box of that sprite over-laps the circular area defined by collision_circle. On the other hand, the green balls will only be considered in collision if the actual sprite over-laps with the defined circle. Remember, for precise collisions to be considered both the object sprite and the collision function must have precise marked as on. It should also be noted that the return value of the function can be the id of any one of the instances considered to be in collision.",
        "x1": "The x coordinate of the center of the circle to check.",
        "y1": "The y coordinate of the center of the circle to check.",
        "radius": "The radius (distance in pixels from its center to its edge).",
        "obj": "The object to check for instance collisions.",
        "prec": "Whether the check is based on pixel-perfect collisions (true = slow) or its bounding box in general (false = fast).",
        "notme": "Whether the calling instance, if relevant, should be excluded (true) or not (false)."
    },
    "collision_ellipse": {
        "desc": "Collision_ellipse uses the first four arguments (x1,y1,x2,y2) to define the width and height of an ellipse within the current room and then checks to see if any object that is defined by the \"obj\" argument is in collision with that area. This collision can be checked as precise or not, and you may also choose to check for the instance running the code itself or not. Consider this image: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/movement%20and%20collisions/collisions/collision_ellipse_illustration.png)\n\nHere, the instance in the middle is using a collision ellipse to check for ball objects. Now, the blue ones do not have a precise bounding box and as you can see, even if the sprite is not actually touching the ellipse, the collision can still happen (even if you set the precise option in the function to true) as the bounding box of that sprite over-laps the elliptical area defined by collision_circle. On the other hand, the green balls will only be considered in collision if the actual sprite over-laps the defined ellipse. Remember, for precise collisions to be considered both the object sprite and the collision function must have precise marked as on. It should also be noted that the return value of the function can be the id of any one of the instances considered to be in collision.n\nReturns: Instance id or **noone**",
        "x1": "The x coordinate of the left side of the ellipse to check.",
        "y1": "The y coordinate of the top side of the ellipse to check.",
        "x2": "The x coordinate of the right side of the ellipse to check.",
        "y2": "The y coordinate of the bottom side of the ellipse to check.",
        "obj": "The object to check for instance collisions.",
        "prec": "Whether the check is based on pixel-perfect collisions (true = slow) or its bounding box in general (false = fast).",
        "notme": "relevant, should be excluded (true) or not (false)."
    },
    "collision_line": {
        "desc": "Collision line checks along a line from point x1,y1 to point x2,y2 for a collision with any instance of the object specified by the argument \"obj\". this check can be either precise or not, but for precise collisions to be enabled, the object or instance that you are checking for must also have precise collisions enabled for their sprite. If not, the default check is based on bounding boxes. The following image illustrates how this works: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/movement%20and%20collisions/collisions/collision_line_illustration.png)\n\nRemember, for precise collisions to be considered both the object sprite and the collision function must have precise marked as on. It should also be noted that the return value of the function can be the id of any one of the instances considered to be in collision along the line, so if three instance overlap the defined line, any one of their ids could be the return value of the function.",
        "x1": "The x coordinate of the start of the line.",
        "y1": "The y coordinate of the start of the line.",
        "x2": "The x coordinate of the end of the line.",
        "y2": "The y coordinate of the end of the line.",
        "obj": "The object to check for instance collisions.",
        "prec": "Whether the check is based on pixel-perfect collisions (true = slow) or its bounding box in general (false = fast).",
        "notme": "Whether the calling instance, if relevant, should be excluded (true) or not (false)."
    },
    "collision_point": {
        "desc": "Collision point checks the point specified by the arguments x1,y1 for a collision with any instance of the object specified by the argument \"obj\". this check can be either precise or not, but for precise collisions to be enabled, the object or instance that you are checking for must also have precise collisions enabled for their sprite. If not, the default check is based on bounding boxes. The following image illustrates how this works: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/movement%20and%20collisions/collisions/collision_point_illustration.png)\n\nRemember, for precise collisions to be considered both the object sprite and the collision function must have precise marked as on. It should also be noted that the return value of the function can be the id of any one of the instances considered to be in collision, so if three instance overlap at that point, any one of their ids could be the return value of the function.",
        "x": "The x coordinate of the point to check.",
        "y": "The y coordinate of the point to check.",
        "obj": "The object to check for instance collisions.",
        "prec": "Whether the check is based on pixel-perfect collisions (true = slow) or its bounding box in general (false = fast).",
        "notme": "Whether the calling instance, if relevant, should be excluded (true) or not (false)."
    },
    "collision_rectangle": {
        "desc": "Collision_rectangle uses the first four arguments (x1,y1,x2,y2) to define an area within the current room and then checks to see if any object that is defined by the \"obj\" argument is in collision with that area. This collision can be checked as precise or not, and you may also choose to check for the instance running the code itself or not. Consider this image: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/movement%20and%20collisions/collisions/collision_rectangle_illustration.png)\n\nHere, the instance in the middle is using a collision rectangle to check for ball objects. Now, the blue ones do not have a precise bounding box and as you can see, even if the sprite is not actually touching the rectangle, the collision will still happen (even if you set the precise option in the function to true) as the bounding box of that sprite over-laps the collision_rectangle. On the other hand, the green balls will only be considered in collision if the actual sprite over-laps the rectangle. Remember, for precise collisions to be considered both the object sprite and the collision function must have precise marked as on. It should also be noted that the return value of the function can be the id of any one of the instances considered to be in collision.",
        "x1": "The x coordinate of the left side of the rectangle to check.",
        "y1": "The y coordinate of the top side of the rectangle to check.",
        "x2": "The x coordinate of the right side of the rectangle to check.",
        "y2": "The y coordinate of the bottom side of the rectangle to check.",
        "obj": "The object to check for instance collisions.",
        "prec": "Whether the check is based on pixel-perfect collisions (true = slow) or its bounding box in general (false = fast).",
        "notme": "Whether the calling instance, if relevant, should be excluded (true) or not (false)."
    },
    "color_get_blue": {
        "desc": "This function returns the amount of blue used to make the given color, with the value being between 0 and 255, where 0 is no blue and 255 is all blue. The following image illustrates this: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/color%20and%20blending/get_blue.png)",
        "col": "The color to check"
    },
    "color_get_green": {
        "desc": "This function returns the amount of green used to make the given color, with the value being between 0 and 255, where 0 is no green and 255 is all green. The following image illustrates this: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/color%20and%20blending/get_green.png)",
        "col": "The color to check"
    },
    "color_get_hue": {
        "desc": "This function will return the hue of the given color. This is the \"pure\" color tone which is part of the hue, saturation and value (luminosity) method for defining a color. The following image illustrates how this value corresponds to the HSV scale of color: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/color%20and%20blending/get_hue.png)",
        "col": "The color to check"
    },
    "color_get_red": {
        "desc": "This function returns the amount of red used to make the given color, with the value being between 0 and 255, where 0 is no red and 255 is all red. The following image illustrates this: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/color%20and%20blending/get_red.png)",
        "col": "The color to check"
    },
    "color_get_saturation": {
        "desc": "This function will return the saturation of the given color. This is the amount of the color tone that is mixed into the final color and is part of the hue, saturation and value (luminosity) method for defining a color. The following image illustrates how this value corresponds to the HSV scale of color: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/color%20and%20blending/get_sat.png)",
        "col": "The color to check"
    },
    "color_get_value": {
        "desc": "This function will return the value (luminosity) of the given color. This is the amount of the \"light\" that is mixed into the final color and is part of the hue, saturation and value method for defining a color. The following image illustrates how this value corresponds to the HSV scale of color: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/color%20and%20blending/get_val.png)",
        "col": "The color to check"
    },
    "colour_get_blue": {
        "desc": "This function returns the amount of blue used to make the given colour, with the value being between 0 and 255, where 0 is no blue and 255 is all blue. The following image illustrates this: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/colour%20and%20blending/get_blue.png)",
        "col": "The colour to check"
    },
    "colour_get_green": {
        "desc": "This function returns the amount of green used to make the given colour, with the value being between 0 and 255, where 0 is no green and 255 is all green. The following image illustrates this: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/colour%20and%20blending/get_green.png)",
        "col": "The colour to check"
    },
    "colour_get_hue": {
        "desc": "This function will return the hue of the given colour. This is the \"pure\" colour tone which is part of the hue, saturation and value (luminosity) method for defining a colour. The following image illustrates how this value corresponds to the HSV scale of colour: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/colour%20and%20blending/get_hue.png)",
        "col": "The colour to check"
    },
    "colour_get_red": {
        "desc": "This function returns the amount of red used to make the given colour, with the value being between 0 and 255, where 0 is no red and 255 is all red. The following image illustrates this: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/colour%20and%20blending/get_red.png)",
        "col": "The colour to check"
    },
    "colour_get_saturation": {
        "desc": "This function will return the saturation of the given colour. This is the amount of the colour tone that is mixed into the final colour and is part of the hue, saturation and value (luminosity) method for defining a colour. The following image illustrates how this value corresponds to the HSV scale of colour: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/colour%20and%20blending/get_sat.png)",
        "col": "The colour to check"
    },
    "colour_get_value": {
        "desc": "This function will return the value (luminosity) of the given colour. This is the amount of the \"light\" that is mixed into the final colour and is part of the hue, saturation and value method for defining a colour. The following image illustrates how this value corresponds to the HSV scale of colour: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/colour%20and%20blending/get_val.png)",
        "col": "The colour to check"
    },
    "cos": {
        "desc": "In a right angled triangle cos(val) = Adjacent / Hypotenuse where val is one of the three angles. This function will always return a number between 1 and -1.",
        "radian_angle": "The angle (in radians) to return the cosine of."
    },
    "darccos": {
        "desc": "Returns the inverse cosine of x, in that if dcos(val)=n, darccos(n)=val, and the resulting number will be between 180 and 0.\n\nNOTE: This will only accept a number between -1 and 1 (anything else will throw an error).",
        "x": "The angle (in degrees) to return the inverse cosine of."
    },
    "darcsin": {
        "desc": "Returns the inverse sine of x, in that if dsin(x)=n, darcsin(n)=x, and the resulting number will be between -90 and 90.\n\nNOTE: This will only accept a number between -1 and 1 (anything else will throw an error).",
        "x": "The angle (in degrees) to return the inverse sine of."
    },
    "darctan": {
        "desc": "Returns the inverse tangent of x. This will accept any number as, unlike dtan, darctans asymptotes are on the y axis so it just means you'll never get returned a number greater than 90 or less than -90.",
        "x": "The angle (in degrees) to return the inverse tangent of."
    },
    "darctan2": {
        "desc": "This function returns the inverse tangent of an angle y/x, where y = Opposite side of triangle and x = Adjacent side of triangle. Unlike darctan(x) the function darctan2(y, x) is valid for all angles and so may be used to convert a vector to an angle without risking division by zero, and it also returns a result in the correct quadrant.\n\nNOTE: The value returned is in degrees, not radians.",
        "y": "The y coordinate to calculate.",
        "x": "The x coordinate to calculate."
    },
    "date_compare_date": {
        "desc": "With this function you can check two dates to see which one is the earlier or later than the other. The function returns -1 if date1 is earlier, 0 if both dates are the same, and 1 if date1 is later.",
        "date1": "The first date.",
        "date2": "The date to compare it to."
    },
    "date_compare_datetime": {
        "desc": "With this function you can check two dates and times to see which one is the earlier or later than the other. The function returns -1 if date1 is earlier, 1 if date1 is later and 0 if they are the same, although since this takes time into account as well, a 0 for matching is very rare (it literally has to be the same second of the same day of the same month of the same year to return a 0).",
        "date1": "The first datetime.",
        "date2": "The datetime to compare it to."
    },
    "date_compare_time": {
        "desc": "With this function you can check two dates and times to see which one has the time component earlier or later than the other. The function returns -1 if datetime1 is earlier, 1 if datetime1 is later and 0 if they are the same, and it ignores the date, so literally just which of the times is further through its given day.",
        "date1": "The first datetime.",
        "date2": "The datetime to compare the first one to."
    },
    "date_create_datetime": {
        "desc": "This function will create a datetime value from the component given as the arguments.",
        "year": "The year to set.",
        "month": "The month to set.",
        "day": "The day to set.",
        "hour": "The hour to set.",
        "minute": "The minute to set.",
        "second": "The second to set."
    },
    "date_current_datetime": {
        "desc": "Returns the date-time value of the current moment. The time returned is based on the default time zone for the system (ie: local time). You can change the base time zone to use with the function **date_set_timezone()**"
    },
    "date_datetime_string": {
        "desc": "With this function you can create a string containing the given datetime, formatted for the system or device that is running the game when the function is called.",
        "date": "The date to use."
    },
    "date_date_of": {
        "desc": "Returns the date value of the given datetime.",
        "date": "The datetime to extract the date from."
    },
    "date_date_string": {
        "desc": "With this function you can create a string containing the given date, formatted as day/month/year.",
        "date": "The date to use."
    },
    "date_days_in_month": {
        "desc": "With this function you can get the number of days that the given month has, either 28, 29, 30 or 31.",
        "date": "The date to use."
    },
    "date_days_in_year": {
        "desc": "With this function you can get the number of days that the given year has, returning 365 for a normal year, and 366 for a leap year.",
        "date": "The date to use."
    },
    "date_day_span": {
        "desc": "With this function you can get the number of days between two dates. This value is always positive, and incomplete days will be returned as a fraction.",
        "date1": "The first datetime.",
        "date2": "The datetime to compare it to."
    },
    "date_get_day": {
        "desc": "This function returns the day (from 1 to 31) of the given datetime.",
        "date": "The date to check."
    },
    "date_get_day_of_year": {
        "desc": "This function returns the day (from 1 to 366) within the year of the given datetime.",
        "date": "The date to check."
    },
    "date_get_hour": {
        "desc": "This function returns the hour of the given datetime value.",
        "date": "The datetime to check."
    },
    "date_get_hour_of_year": {
        "desc": "This function returns the hour of the given datetime value within the year (from the total number of hours for the year, taking into account leap years).",
        "date": "The datetime to check."
    },
    "date_get_minute": {
        "desc": "This function returns the minute of the given datetime value.",
        "date": "The datetime to check."
    },
    "date_get_minute_of_year": {
        "desc": "This function returns the minute of the given datetime value within the year (from the total number of minutes for the year, taking into account leap years).",
        "date": "The date to check."
    },
    "date_get_month": {
        "desc": "This function returns the month of the given datetime value.",
        "date": "The datetime to check."
    },
    "date_get_second": {
        "desc": "This function returns the second of the given datetime value.",
        "date": "The datetime to check."
    },
    "date_get_second_of_year": {
        "desc": "This function returns the second of the given datetime value within the year (from the total number of seconds for the year, taking into account leap years).",
        "date": "The date to check."
    },
    "date_get_timezone": {
        "desc": "Gets the base time zone being used for all the rest of the date and time functions. This time zone can either be local (as set by the system) or UTC, and the function will return one of the following constants: ![](https://gmlsupport.liaronce.win/images-in-intellisense/2.png)"
    },
    "date_get_week": {
        "desc": "This function returns the week of the given datetime value within the year.",
        "date": "The datetime to check."
    },
    "date_get_weekday": {
        "desc": "This function returns the week day value of the given datetime. This will be a value from 0 to 6.",
        "date": "The date to check."
    },
    "date_get_year": {
        "desc": "his function returns the year of the given datetime.",
        "date": "The datetime to check."
    },
    "date_hour_span": {
        "desc": "With this function you can get the number of hours between two dates. This value is always positive, and incomplete hours will be returned as a fraction.",
        "date1": "The first datetime.",
        "date2": "The datetime to compare the first one to."
    },
    "date_inc_day": {
        "desc": "With this function you can increment a given datetime value by a specific number of days, and it will return the new datetime value.",
        "date": "The datetime to add to.",
        "amount": "The number of days (must be an integer) to add."
    },
    "date_inc_hour": {
        "desc": "With this function you can increment a given datetime value by a specific number of hours, and it will return the new datetime value.",
        "date": "The datetime to add to.",
        "amount": "The number of hours (must be an integer) to add."
    },
    "date_inc_minute": {
        "desc": "With this function you can increment a given datetime value by a specific number of minutes, and it will return the new datetime value.",
        "date": "The datetime to add to.",
        "amount": "The number of minutes (must be an integer) to add."
    },
    "date_inc_month": {
        "desc": "With this function you can increment a given datetime value by a specific number of months, and it will return the new datetime value.",
        "date": "The datetime to add to.",
        "amount": "The number of months (must be an integer) to add."
    },
    "date_inc_second": {
        "desc": "With this function you can increment a given datetime value by a specific number of seconds, and it will return the new datetime value.",
        "date": "The datetime to add to.",
        "amount": "The number of seconds (must be an integer) to add."
    },
    "date_inc_week": {
        "desc": "With this function you can increment a given datetime value by a specific number of weeks, and it will return the new datetime value.",
        "date": "The datetime to add to.",
        "amount": "The number of weeks (must be an integer) to add."
    },
    "date_inc_year": {
        "desc": "With this function you can increment a given datetime value by a specific number of years, and it will return the new datetime value.",
        "date": "The datetime to add to",
        "amount": "The number of years (must be an integer) to add."
    },
    "date_is_today": {
        "desc": "This function will return true if the given datetime value is the day it is being checked on (ie: today), or false otherwise. This can be a handy function for things like Easter Eggs in your games, or for unlocking seasonal content. Note that this function will be affected by the time zone set (default is local time) which you can change using the **date_set_timezone()** function.",
        "date": "The datetime to use."
    },
    "date_leap_year": {
        "desc": "This function will return true if the year component of the given datetime value is a leap year or false otherwise. This can be a handy function for things like Easter Eggs in your games, or for unlocking special content.",
        "date": "The datetime to use."
    },
    "date_minute_span": {
        "desc": "With this function you can get the number of minutes between two dates. This value is always positive, and incomplete minutes will be returned as a fraction.",
        "date1": "The first datetime.",
        "date2": "The datetime to compare it to."
    },
    "date_month_span": {
        "desc": "With this function you can get the number of months between two dates. This value is always positive, and incomplete months will be returned as a fraction.",
        "date1": "The first datetime.",
        "date2": "The datetime to compare it to."
    },
    "date_second_span": {
        "desc": "With this function you can get the number of seconds between two dates. The return value is always positive and will be a whole number.",
        "date1": "The first datetime.",
        "date2": "The datetime to compare it to."
    },
    "date_set_timezone": {
        "desc": "Sets the base time zone to use for all the rest of the date and time functions. This time zone can either be local (as set by the system) or UTC, and you would use one of the following constants to define which is being used (by default this is local time): ![](https://gmlsupport.liaronce.win/images-in-intellisense/3.png)",
        "timezone": "The time zone to use for the base time."
    },
    "date_time_of": {
        "desc": "Returns the time value of the given datetime. The time returned ignores Daylight Saving Time (and so is Universal Time) and would normally be used in conjunction with another date/time handling function.",
        "date": "The datetime to extract the time from."
    },
    "date_time_string": {
        "desc": "With this function you can create a string containing the given time, formatted for the system or device that is running the game when the function is called.",
        "date": "The datetime to use."
    },
    "date_valid_datetime": {
        "desc": "With this function you can check a datetime value to see if it is valid (returns true) or not (returns false). Note that this function will only consider a valid datetime as being after 1/1/1970 and anything before that will return false, so the earliest you can check would be:\n\n```date_valid_datetime(1970, 01, 01, 0, 0, 0);```",
        "year": "The year to check.",
        "month": "The month to check.",
        "day": "The day to check.",
        "hour": "The hour to check.",
        "minute": "The minute to check.",
        "second": "The second to check."
    },
    "date_week_span": {
        "desc": "With this function you can get the number of weeks between two dates. This value is always positive, and incomplete weeks will be returned as a fraction.",
        "date1": "The first datetime.",
        "date2": "The datetime to compare it to."
    },
    "date_year_span": {
        "desc": "With this function you can get the number of years between two dates. This value is always positive, and incomplete years will be returned as a fraction.",
        "date1": "The first datetime.",
        "date2": "The datetime to compare it to."
    },
    "dcos": {
        "desc": "In a right angled triangle cos(val) = Adjacent / Hypotenuse where val is one of the three angles. This function will always return a number between 1 and -1.",
        "degree_angle": "The angle (in degrees) to return the cosine of."
    },
    "debug_event": {
        "desc": "",
        "str": ""
    },
    "degtorad": {
        "desc": "In GM all the trigonometric functions work in radians, but most people work in degrees and this means that to convert your degrees into radians you need to use this function. For example, degtorad(180) returns 3.14159265 radians. This function translates degrees into radians using the formula:\n\n```angle_radians = angle_degrees * pi / 180```",
        "x": "The degrees to convert."
    },
    "device_get_tilt_x": {
        "desc": "This function returns a value between -1 and 1 depending upon the angle of \"tilt\" of the device. The actual correlation between degrees of tilt and the value returned depends on the device and OS that it uses, but generally a value of 1 or -1 is the same as +/-90°. The image below shows how each if the available functions relates to the device: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/mouse,%20keyboard%20and%20other%20controls/device%20input/tilt_image.png)"
    },
    "device_get_tilt_y": {
        "desc": "This function returns a value between -1 and 1 depending upon the angle of \"tilt\" of the device. The actual correlation between degrees of tilt and the value returned depends on the device and OS that it uses, but generally a value of 1 or -1 is the same as +/-90°. The image below shows how each if the available functions relates to the device: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/mouse,%20keyboard%20and%20other%20controls/device%20input/tilt_image.png)"
    },
    "device_get_tilt_z": {
        "desc": "This function returns a value between -1 and 1 depending upon the angle of \"tilt\" of the device. The actual correlation between degrees of tilt and the value returned depends on the device and OS that it uses, but generally a value of 1 or -1 is the same as +/-90°. The image below shows how each if the available functions relates to the device: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/mouse,%20keyboard%20and%20other%20controls/device%20input/tilt_image.png)"
    },
    "device_is_keypad_open": {
        "desc": "This does a check of the device for a keypad and if one is available it returns true otherwise it returns false. Please note that this function is mainly for use with Android devices.\n\nFor those users with a Sony Xperia Play, there is a set button/key map setup within GameMaker: Studio, so you can use the keyboard constants **vk_up, vk_down, vk_left, vk_right** for the joypad keys and Triangle is *ord('T')*, Square is *ord('S')*, Circle is **vk_alt + vk_backspace** while the back button is simply *vk_backspace*, Cross is **vk_space**, Select is **vk_return** and Start is **vk_rshift**, the L Trigger is *ord('L')* and R Trigger is *ord('R')*."
    },
    "device_mouse_check_button": {
        "desc": "This function returns true (1) or false (0) depending on whether the device that you specify is being used or not. Now, the device refers to the mouse number, which can be from 0 to 4 and this event is triggered when the touch screen of a mobile device is touched, so in this way you can test for up to 5 different screen touches (or mouse devices). This function constantly updates every step, and the standard constants of *mb_left* and *mb_right* can be used to check for either button.",
        "device": "The device (from 0 - 4) that is being checked.",
        "button": "The button of the device that is being checked."
    },
    "device_mouse_check_button_pressed": {
        "desc": "This function returns true (1) or false (0) depending on whether the device that you specify has been pressed or not. Now, the device refers to the mouse number, which can be from 0 to 4 and this event is triggered when the touch screen of a mobile device is touched, so in this way you can test for up to 5 different screen touches. This function is only triggered once by the actual pressing action, and the standard constants of mb_left and mb_right can be used to check for either button.",
        "device": "The device (from 0 - 4) that is being checked.",
        "button": "The button of the device that is being checked."
    },
    "device_mouse_check_button_released": {
        "desc": "This function returns true (1) or false (0) depending on whether the device that you specify has been released or not. Now, the device refers to the mouse number, which can be from 0 to 4 and this event is triggered when the touch screen of a mobile device is touched, so in this way you can test for up to 5 different screen touches. This function is only triggered once by the actual releasing action, and the standard constants of mb_left and mb_right can be used to check for either button.",
        "device": "The device (from 0 - 4) that is being checked.",
        "button": "The button of the device that is being checked."
    },
    "device_mouse_dbclick_enable": {
        "desc": "This function can be used to set the device to detect a double tap of the mb_left (left mouse button) as an mb_right (right mouse button) tap or not. By default this is set to true, meaning that every time the user taps the device screen twice quickly and consecutively, the return value is the same as if the right mouse button had been clicked. When this is on, the first tap will be detected as mb_left, and the second as mb_right, so make sure that any code you use takes this into account.",
        "enable": "Set double-click detection on (true) or off (false)."
    },
    "device_mouse_raw_x": {
        "desc": "This function returns raw x position of the device. What this means is that it returns the actual device definition of the x position that is being touched, not the GameMaker: Studio one, and as such will ignore things like view position and scaling.\n\nNote: This function is very much device dependant and you should experiment first with the desired target module and device to see what exactly is returned.",
        "device": "The device (from 0 - 4) that is being checked."
    },
    "device_mouse_raw_y": {
        "desc": "This function returns raw y position of the device. What this means is that it returns the actual device definition of the y position that is being touched, not the GameMaker: Studio one, and as such will ignore things like view position and scaling.\n\nNote: This function is very much device dependant and you should experiment first with the desired target module and device to see what exactly is returned.",
        "device": "The device (from 0 - 4) that is being checked."
    },
    "device_mouse_x": {
        "desc": "This function returns x position of the device. If you are running this on a the HTML5 or PC and Mac modules then this value is updated constantly, as long as the device (usually a mouse) is plugged in, however for mobile devices, this will only be updated while the screen is being touched.",
        "device": "The device (from 0 - 4) that is being checked."
    },
    "device_mouse_x_to_gui": {
        "desc": "This function returns x position of the device in relation to the GUI layer. Since the GUI layer can be set to be a different size independently of the screen resolution and the room size, it can sometimes be complicated to get the exact point on the GUI layer that a user has touched the screen. With this function you can get that position based on the actual GUI size, making GUI buttons and HUD elements easier to create. If you are running this on a the HTML5 or PC and Mac modules then this value is updated constantly, as long as the device (usually a mouse) is plugged in, however for mobile devices, this will only be updated while the screen is being touched.",
        "device": "The device (from 0 - 4) that is being checked."
    },
    "device_mouse_y": {
        "desc": "This function returns y position of the device. If you are running this on a the HTML5 or PC and Mac modules then this value is updated constantly, as long as the device (usually a mouse) is plugged in, however for mobile devices, this will only be updated while the screen is being touched.",
        "device": "The device (from 0 - 4) that is being checked."
    },
    "device_mouse_y_to_gui": {
        "desc": "This function returns y position of the device in relation to the GUI layer. Since the GUI layer can be set to be a different size independently of the screen resolution and the room size, it can sometimes be complicated to get the exact point on the GUI layer that a user has touched the screen. With this function you can get that position based on the actual GUI size, making GUI buttons and HUD elements easier to create. If you are running this on a the HTML5 or PC and Mac modules then this value is updated constantly, as long as the device (usually a mouse) is plugged in, however for mobile devices, this will only be updated while the screen is being touched.",
        "device": "The device (from 0 - 4) that is being checked."
    },
    "directory_create": {
        "desc": "This function will creates a directory with the given name in the sandboxed local save area.\n\nWARNING! This function may not work as you expect due to GameMaker: Studio being sandboxed! Please see the section on File System Limits for more information.",
        "dname": "The name of the directory to create."
    },
    "directory_destroy": {
        "desc": "This function will remove a directory with the given name in the sandboxed local save area.\n\nWARNING! This function may not work as you expect due to GameMaker: Studio being sandboxed! Please see the section on File System Limits for more information.",
        "dname": "The name of the directory to remove."
    },
    "directory_exists": {
        "desc": "This function will return true if the indicated directory exists or false if it does not. The specified name must include the full path, not a relative path and you cannot access any directories from out-with the game bundle as all games are sandboxed.\n\nWARNING! This function may not work as you expect due to GameMaker: Studio being sandboxed! Please see the section on File System Limits for more information.",
        "dname": "The name of the directory to look for."
    },
    "display_get_dpi_x": {
        "desc": "Dots per inch (DPI) is a measure of spatial printing or video dot density, in particular the number of individual dots that can be placed in a line within the span of 1 inch (2.54 cm). When working on mobile devices (in particular Android devices) this is an important factor to take into consideration as what may be appropriate for one display resolution, may not be appropriate for another. For example, you may have two displays with the same resolution of 400 x 800, but display 1 has a dpi of 60 and display 2 has a dpi of 30. In this case, any text or image displayed on display 2 will appear much larger, even though the actual resolution is the same.\n\nThis function will get the dpi of the device display along the x axis (this value is also dependant on the orientation of the device). Please note that Mac and iOS do not return specific dpi settings but appear to return the same values as the OS, which are not correct (but will have to do) as Apple do not give the correct values."
    },
    "display_get_dpi_y": {
        "desc": "Dots per inch (DPI) is a measure of spatial printing or video dot density, in particular the number of individual dots that can be placed in a line within the span of 1 inch (2.54 cm). When working on mobile devices (in particular Android devices) this is an important factor to take into consideration as what may be appropriate for one display resolution, may not be appropriate for another. For example, you may have two displays with the same resolution of 400 x 800, but display 1 has a dpi of 60 and display 2 has a dpi of 30. In this case, any text or image displayed on display 2 will appear much larger, even though the actual resolution is the same.\n\nThis function will get the dpi of the device display along the y axis (this value is also dependant on the orientation of the device). Please note that Mac and iOS do not return specific dpi settings but appear to return the same values as the OS, which are not correct (but will have to do) as Apple do not give the correct values."
    },
    "display_get_gui_height": {
        "desc": "With this function you can get the height (in pixels) of the GUI as used in the Draw Gui Event."
    },
    "display_get_gui_width": {
        "desc": "With this function you can get the width (in pixels) of the GUI as used in the Draw Gui Event."
    },
    "display_get_colordepth": {
        "desc": ""
    },
    "display_get_height": {
        "desc": "This function will return the height of the display (in pixels). Note that on the HTML5 target, this value is the height of the browser window, rather than the physical display size."
    },
    "display_get_orientation": {
        "desc": "This function will return one of two constant GameMaker: Studio has to tell you whether the device running the game is being held in landscape or portrait mode: ![](https://gmlsupport.liaronce.win/images-in-intellisense/4.png)\n\nPlease note that this function may not correctly detect the orientation of the device when used in the HTML5 target module. However this is easily mimicked by the use of the following script: \n\n\n```return (browser_width < browser_height);```\n\nIt will return true for portrait and false for landscape."
    },
    "display_get_width": {
        "desc": "This function will return the width of the display (in pixels). Note that on the HTML5 target, this value is the width of the browser window, rather than the physical display size."
    },
    "display_mouse_get_x": {
        "desc": "This function will return the mouse x position within the screen. It should be noted that this function only works properly when used on the Windows target. It can be used for HTML5 too, but will only return a value relative to the 0,0 of the canvas itself, and will not return any value while the mouse is outside of the canvas. For other devices it will return 0, and you should use the **device_mouse_raw_x** and **device_mouse_raw_y** functions instead."
    },
    "display_mouse_get_y": {
        "desc": "This function will return the mouse y position within the screen. It should be noted that this function only works properly when used on the Windows target. It can be used for HTML5 too, but will only return a value relative to the 0,0 of the canvas itself, and will not return any value while the mouse is outside of the canvas. For other devices it will return 0, and you should use the **device_mouse_raw_x** and **device_mouse_raw_y** functions instead."
    },
    "display_set_gui_maximise": {
        "desc": "This function can be used to maximise the GUI layer and set it to be scaled and offset in relation to the screen dimensions, rather than the default application surface position and dimensions. By default, the GUI layer is 1:1 with the application surface resolution and drawn at the (0,0) position of the surface too. However this is not always what you want and so you can use this function to set it to be drawn relative to the absolute (0,0) position of the display or game window.\n\nWhat arguments you provide to this function will depend on the effect you wish it to have on the GUI layer. Simply calling the function with no arguments will set the GUI layer to be drawn at the (0,0) position of the screen or game window, with the width and height being scaled to fit the whole area.\n\n```display_set_gui_maximise();```\n\nHowever, you can set the scaling factor for the GUI layer, and the width and height will be scaled by that amount. Remember that the GUI layer is always made to fit the size of the display or game window, or the application surface, so setting this value to anything other than 1 basically scales the pixel count along the width and height. If your display is 1024x768 and you set the scaling factor to scale by 0.5, then your GUI layer will be half the size of the display, effectively doubling the pixel size.\n\n```display_set_gui_maximise(0.5, 0.5);```\n\nSetting the values in this way will also set the draw position to the (0,0) of the display or game window, so you can provide offset values to \"move\" the (0,0) position:\n\n```var pos = application_get_position();\ndisplay_set_gui_maximise(0.5, 0.5, pos[0], pos[1]);```\n\nFinally, you can reset the GUI layer using this function by setting the scaling factors to -1. This will set the GUI layer to have a 1:1 scale again and set the draw position to the (0,0) position of the application surface rather than the display or window.\n\n```display_set_gui_maximise(-1, -1);```",
        "xscale": "<Optional> The horizontal scaling factor (use -1 to reset to default).",
        "yscale": "<Optional> The vertical scaling factor (use -1 to reset to default).",
        "xoffset": "<Optional> The x offset position for drawing.",
        "yoffset": "<Optional> The y offset position for drawing."
    },
    "display_set_gui_size": {
        "desc": "This function will only affect things drawn in the Draw GUI Event and can be used to set a specific width and height for all GUI components in that event, and no matter what size of display or window is used to display the GUI, it will be scaled to fit correctly. Where the GUI is positioned (ie: the (0,0) position) will depend on whether you have used the function **display_set_gui_maximise()** or not. If you do not use this function (the default setting) then the GUI layer will be positioned with its (0,0) point at the same position as that for the application surface (the area where your game is being drawn) and the width and height will be stretched to fit the this surface, such that setting a GUI width of 256px with this function when the application surface is 512px would stretch those 256 pixels to fit, effectively making the pixels twice as large. This is ideal for those games that have aspect ratio correction set in the global Game Settings.\n\nIf you have used the **display_set_gui_maximise()** function then the (0,0) position for the GUI layer will default to the top left corner of the game window, or display (when in fullscreen or on devices), with the scaling factor set by that function, and the width and height set by this one. You can reset the GUI layer at any time to the default configuration by calling this function using -1 as both the width and height - this will set the (0, 0) position to the application surface and the width and height will be reset to 1:1 with the surface too.",
        "width": "The width of the GUI (-1 equals 1:1 with the display or application_surface).",
        "height": "The height of the GUI (-1 equals 1:1 with the display or application_surface)."
    },
    "display_set_ui_visibility": {
        "desc": "This function can be used to show or hide the system UI on Android only. The function requires you to supply one or more system flags as an integer value. When using more than a single flag, these need to be merged using the bitwise \"or\", as shown in the example below. You can find a list of Android system flags [here](https://developer.android.com/reference/android/view/View.html#SYSTEM_UI_FLAG_FULLSCREEN).",
        "flags": "The Android SYSTEM flags to use (as an integer value)."
    },
    "display_mouse_set": {
        "desc": "With this function you can change or set the position of the mouse within the game display which can be useful for FPS games, for example. The function will only work while the game is in focus and using alt + tab will unlock the mouse.",
        "x": "The x coordinate in the display.",
        "y": "The y coordinate in the display."
    },
    "display_reset": {
        "desc": "This function Resets the display settings to the ones that were set when the game was started, but also allows you to change the current level of full screen anti-aliasing being used and whether to use vertical synchronisation. The available anti-aliasing levels are 0,2,4 and 8, with the default startup value being set to 0, and the default v-sync setting is false (off). Switching v-sync on may give a smoother gaming experience but it will also need more processing power and so its impact must be considered careful before use, and the same goes for the anti-aliasing where the higher the number the more processing that is required.\n\nSince not all target devices are the same, some may not support 8x or 4x anti-aliasing for example, and so there is a **read only** variable available for getting the different levels of AA that the device running the game can display:\n\n  **display_aa**\n\nThis variable will return a value based on the setting of bits for the different levels. So for only 2xAA, this will report 2, for 2x and 4x availability it will report 6. For 8 and 4 it will report 12. For all 3 levels (2,4 and 8) it will report 14.",
        "aa_level": "The level of anti-aliasing filtering (0, 2, 4 or 8).",
        "vsync": "Toggle vertical synchronisation to on (true) or off (false)."
    },
    "distance_to_object": {
        "desc": "This function calculates the distance from the edge of the bounding box of the calling instance to the nearest edge of the nearest instance of the object specified. The object can be an object index or a specific instance id as well as the keyword other, and the distance is returned in pixels. Note that if either of the objects have no sprite or no mask defined, the results will be incorrect.",
        "obj": "The object to check for."
    },
    "distance_to_point": {
        "desc": "This function calculates the distance from the edge of the bounding box of the calling instance to the specified x/y position in the room, with the return value being in pixels. Note that if the calling object have no sprite or no mask defined, the results will be incorrect.",
        "x": "The x position to check.",
        "y": "The y position to check."
    },
    "dot_product": {
        "desc": "The dot product is a value expressing the angular relationship between two vectors and is found by taking two vectors, multiplying them together and then adding the results. The name \"dot product\" is derived from the centered dot \"·\" that is often used to designate this operation (the alternative name \"scalar product\" emphasizes the scalar rather than vector nature of the result).\n\nThe actual mathematical formula can be written like this: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/maths/vector%20functions/dot_product_image.png)\n\nSo, in 2D the dot product of vectors a[x1,y1] and b[x2,2] is x1x2 + y1y2, meaning that the dot_product in GameMaker: Studio is calculated as: \n\n```a · b = (x1*x2)+(y1*y2);```\nThe curious thing about the dot product is the relationship it has to the angle formed by the input vectors which can be expressed as: \n\n```a · b = (length of a) * (length of b) * cos(angle)```\nThat is to say, the dot product of two vectors will be equal to the cosine of the angle between those vectors, multiplied by the lengths of each of them. Here is an image to illustrate: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/maths/vector%20functions/dot_product_image_2.png)\n\nThere are a few things that we can now state from any two vectors in relation to the result of their dot product:\n\n - If a and b are perpendicular (at 90 degrees to each other), the result of the dot product will be zero, because cos(ang) will be zero\n\n - If the angle between a and b are less than 90 degrees, the dot product will be positive (greater than zero), as cos(ang) will be positive\n\n - If the angle between a and b are greater than 90 degrees, the dot product will be negative (less than zero), as cos(ang) will be negative\n\nSo what does this mean for those of us that make games? Well, this mathematical relationship can be used in quite a few circumstances, but the best way to see it is to build an actual scenario and see for yourself what is going on. One of the simplest ways to do this is to generate a simple \"line of sight\" check for an enemy in, say, a platform game so that the enemy will \"see\" the player if they are within 90ï¿½ of either side of their vector normal.\n\n![](https://docs.yoyogames.com/source/dadiospice/002_reference/maths/vector%20functions/dot_product_image_1.png)\n\nBasically, we have to get the vector normal from the enemy (ie: comprised of a direction and sight distance) and then we need to get the vector of the player to the enemy. We will then get the dot_product of these vectors, and if the result is positive the player has been seen, and if it is negative he hasn't. The actual code to get this working is supplied in the example below.",
        "x1": "The x coordinate of the first vector.",
        "y1": "The y coordinate of the first vector.",
        "x2": "The x coordinate of the second vector.",
        "y2": "The y coordinate of the second vector."
    },
    "dot_product_3d": {
        "desc": "The dot product is a value expressing the angular relationship between two vectors and is found by taking two vectors, multiplying them together and then adding the results. The name \"dot product\" is derived from the centered dot \"·\" that is often used to designate this operation (the alternative name \"scalar product\" emphasizes the scalar rather than vector nature of the result).\n\nThe actual mathematical formula can be written like this: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/maths/vector%20functions/dot_product_image.png)\n\nIn 2D, the dot product of vectors a[x1,y1] and b[x2,y2] is x1x2 + y1y2, so in 3D, the dot product of vectors a[x1,y1,z1] and b[x1,y1,z1] is x1x2 + y1y2 + z1z2. So, the dot_product_3d in GameMaker: Studio is calculated as: \n\n```a · b = (x1*x2) + (y1*y2) + (z1*z2);```\n\nThe curious thing about the dot product is the relationship it has to the angle formed by the input vectors which can be expressed as: ```a · b = (length of a) * (length of b) * cos(angle)```\n\nThat is to say, the dot product of two vectors will be equal to the cosine of the angle between those vectors, multiplied by the lengths of each of them. Here is an image to illustrate: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/maths/vector%20functions/dot_product_image_2.png)\n\nThere are a few things that we can now state from any two vectors in relation to the result of their dot product: \n\n - If a and b are perpendicular (at 90 degrees to each other), the result of the dot product will be zero, because cos(ang) will be zero\n\n - If the angle between a and b are less than 90 degrees, the dot product will be positive (greater than zero), as cos(ang) will be positive\n\n - If the angle between a and b are greater than 90 degrees, the dot product will be negative (less than zero), as cos(ang) will be negative\n\n - So what does this mean for those of us that make games? Well, this mathematical relationship can be used in quite a few circumstances, but the best way to see it is to build an actual scenario and see for yourself what is going on. One of the simplest ways to do this is to generate a simple \"height\" check for an enemy in, say, a platform game so that the enemy will \"see\" the player if they are above the plane formed by the enemy normal vector and the 3d floor.\n\n![](https://docs.yoyogames.com/source/dadiospice/002_reference/maths/vector%20functions/dot_product_3d_image.png)\n\nBasically, we are getting the vector normal from the enemy perpendicular to the floor and then we are getting the vector of the player to the enemy. We will then get the dot_product of these vectors, and if the result is positive the player is \"above\" the enemy floor plane and if it is negative he is below.",
        "x1": "The x coordinate of the first vector.",
        "y1": "The y coordinate of the first vector.",
        "z1": "The z coordinate of the first vector.",
        "x2": "The x coordinate of the second vector.",
        "y2": "The y coordinate of the second vector.",
        "z2": "The z coordinate of the second vector."
    },
    "dot_product_3d_normalised": {
        "desc": "The dot product is a value expressing the angular relationship between two vectors and is found by taking two vectors, multiplying them together and then adding the results. The name \"dot product\" is derived from the centered dot \"·\" that is often used to designate this operation (the alternative name \"scalar product\" emphasizes the scalar rather than vector nature of the result).\n\nThe actual mathematical formula can be written like this: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/maths/vector%20functions/dot_product_image.png)\n\nIn 2D, the dot product of vectors a[x1,y1] and b[x2,y2] is x1x2 + y1y2, so in 3D, the dot product of vectors a[x1,y1,z1] and b[x1,y1,z1] is x1x2 + y1y2 + z1z2. So, the dot_product_3d in GameMaker: Studio is calculated as: \n\n```a · b = (x1*x2) + (y1*y2) + (z1*z2);```\n\nWhat about the normalised dot product? The normalised dot product has been corrected in such a way as to bring the return value into the range of -1 and 1 (see Normalised Vectors for more detailed information), which is exceptionally useful in many circumstances, particularly when dealing with lighting and other 3D functions.",
        "x1": "The x coordinate of the first vector.",
        "y1": "The y coordinate of the first vector.",
        "z1": "The z coordinate of the first vector.",
        "x2": "The x coordinate of the second vector.",
        "y2": "The y coordinate of the second vector.",
        "z2": "The z coordinate of the second vector."
    },
    "dot_product_normalised": {
        "desc": "The dot product is a value expressing the angular relationship between two vectors and is found by taking two vectors, multiplying them together and then adding the results. The name \"dot product\" is derived from the centered dot \"·\" that is often used to designate this operation (the alternative name \"scalar product\" emphasizes the scalar rather than vector nature of the result).\n\nThe actual mathematical formula can be written like this: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/maths/vector%20functions/dot_product_image.png)\n\nSo, in 2D the dot product of vectors a[x1,y1] and b[x2,2] is x1x2 + y1y2, meaning that the dot_product in GameMaker: Studio is calculated as: \n\n```a · b = (x1*x2)+(y1*y2);```\n\nWhat about the normalised dot product? The normalised dot product has been corrected in such a way as to bring the return value into the range of -1 and 1 (see Normalised Vectors for more detailed information), which is exceptionally useful in many circumstances, particularly when dealing with lighting and other 3D functions.",
        "x1": "The x coordinate of the first vector.",
        "y1": "The y coordinate of the first vector.",
        "x2": "The x coordinate of the second vector.",
        "y2": "The y coordinate of the second vector."
    },
    "draw_arrow": {
        "desc": "This function will draw an arrow from point (x1,y1) to point (x2,y2). The stem of the arrow is drawn along these points with the actual arrow head being drawn at the end, where the size of the arrowhead is defined by the argument \"size\" and is calculated as being part of the stem so that the end point is always aligned with the position defined by x2,y2. The width of the arrow head is calculated automatically in proportion to the length.",
        "x1": "The x coordinate of the start of the line.",
        "y1": "The y coordinate of the start of the line.",
        "x2": "The x coordinate of the end of the line (where the arrowhead ends).",
        "y2": "The y coordinate of the end of the line (where the arrowhead ends).",
        "size": "The length of the arrow in pixels."
    },
    "draw_button": {
        "desc": "This function will draw a very simple, rectangular \"button\" using the currently selected draw colour and alpha where the up argument defines how the bevelled edge effect looks, as shown in the image below: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/drawing%20basic%20forms/draw_button.png)",
        "x1": "The x coordinate of the left of the button",
        "y1": "The y coordinate of the top of the button",
        "x2": "The x coordinate of the right of the button",
        "y2": "The y coordinate of the bottom of the button",
        "up": "Whether the button is up (true) or down (false)"
    },
    "draw_circle": {
        "desc": "With this function you can draw either an outline of a circle or a filled circle. You can define how precise the drawing is with the function **draw_set_circle_precision**.",
        "x": "The x coordinate of the center of the circle.",
        "y": "The y coordinate of the center of the circle.",
        "r": "The circle's radius (length from its center to its edge)",
        "outline": "Whether the circle is drawn filled (false) or as a one pixel wide outline (true)."
    },
    "draw_circle_color": {
        "desc": "With this function you can draw either an outline of a circle or a filled circle, and if it is filled you can define the interior and exterior fill colors. If these colors are not the same, you will get a gradient effect from one to the other and the color settings will over-ride the base color set with the function **draw_set_color**. You can define how precise the drawing is with the function **draw_set_circle_precision**.",
        "x": "The x coordinate of the center of the circle.",
        "y": "The y coordinate of the center of the circle.",
        "r": "The radius (distance from center to edge) of the circle in pixels.",
        "col1": "The color at the center of the circle.",
        "col2": "The color at the edge of the circle.",
        "outline": "Whether the circle is an outline (true) or not (false). If true, col1 is irrelevant."
    },
    "draw_circle_colour": {
        "desc": "With this function you can draw either an outline of a circle or a filled circle, and if it is filled you can define the interior and exterior fill colours. If these colours are not the same, you will get a gradient effect from one to the other and the colour settings will over-ride the base colour set with the function draw_set_colour. You can define how precise the drawing is with the function draw_set_circle_precision.",
        "x": "The x coordinate of the center of the circle.",
        "y": "The y coordinate of the center of the circle.",
        "r": "The radius (distance from center to edge) of the circle in pixels.",
        "col1": "The colour at the center of the circle.",
        "col2": "The colour at the edge of the circle.",
        "outline": "Whether the circle is an outline (true) or not (false). If true, col1 is irrelevant."
    },
    "draw_clear": {
        "desc": "This function can be used to clear the entire screen (with no alpha blend) to the given colour, and is only for use in the draw event of an instance (it will not show if used in any other event). It can also be useful for clearing surfaces when they are newly created.",
        "col": "The colour with which the screen will be cleared"
    },
    "draw_clear_alpha": {
        "desc": "",
        "col": "",
        "alpha": ""
    },
    "draw_ellipse": {
        "desc": "With this function you can draw either an outline of an ellipse or a filled ellipse by defining a rectangular area that will then have the ellipse created to fit. You can define how precise the drawing is with the function **draw_set_circle_precision**.",
        "x1": "The x coordinate of the left of the ellipse.",
        "y1": "The y coordinate of the top of the ellipse.",
        "x2": "The x coordinate of the right of the ellipse.",
        "y2": "The y coordinate of the bottom of the ellipse.",
        "outline": "Whether the ellipse is drawn filled (false) or as a one pixel wide outline (true)."
    },
    "draw_ellipse_color": {
        "desc": "With this function you can draw either an outline of an ellipse or a filled ellipse by defining a rectangular area that will then have the ellipse created to fit. If it is filled you can define the interior and exterior fill colors. If these colors are not the same, you will get a gradient effect from one to the other (the color settings will over-ride the base color set with the function draw_set_color). You can define how precise the drawing is with the function draw_set_circle_precision.",
        "x1": "The x coordinate of the left of the ellipse.",
        "y1": "The y coordinate of the top of the ellipse.",
        "x2": "The x coordinate of the right of the ellipse.",
        "y2": "The y coordinate of the bottom of the ellipse.",
        "col1": "The color of the center.",
        "col2": "The color of the edge.",
        "outline": "Whether the ellipse is an outline (true) or filled in (false)."
    },
    "draw_ellipse_colour": {
        "desc": "With this function you can draw either an outline of an ellipse or a filled ellipse by defining a rectangular area that will then have the ellipse created to fit. If it is filled you can define the interior and exterior fill colours. If these colours are not the same, you will get a gradient effect from one to the other (the colour settings will over-ride the base colour set with the function draw_set_colour). You can define how precise the drawing is with the function draw_set_circle_precision.",
        "x1": "The x coordinate of the left of the ellipse.",
        "y1": "The y coordinate of the top of the ellipse.",
        "x2": "The x coordinate of the right of the ellipse.",
        "y2": "The y coordinate of the bottom of the ellipse.",
        "col1": "The colour of the center.",
        "col2": "The colour of the edge.",
        "outline": ""
    },
    "draw_enable_alphablend": {
        "desc": "This function can be used to toggle alphablending on an off. Basically, if you have this set to false, all images being drawn will be drawn 100% opaque, meaning that any transparent, or semi transparent, areas of a sprite or background will be visible. It is encouraged that you have alpha blending off whenever possible (especially when developing for mobile devices) as this greatly increases the draw speed.",
        "enable": "This can be either true (switched on) or false (switched off)"
    },
    "draw_enable_drawevent": {
        "desc": "With this function you can choose to enable (true) or disable (false) the draw event for all instances in the game, thus giving you control over how and when things are draw, useful if you wish to implement a \"frame skip\" technique. Note that this doesn't just prevent instances drawing to the screen, it suppresses the draw event completely meaning that care should be taken since any game logic that is present in that event will not be run either.",
        "enable": "Enable (true) or disable (false) the draw event for all instances."
    },
    "draw_enable_swf_aa": {
        "desc": "With this function you can enable or disable anti-aliasing (AA) for SWF format vector sprites. AA simply smooths the edges of vector images to give them a nicer look. The amount of AA used will depend on the value set using the function **draw_set_swf_aa_level()**. By default this is disabled.",
        "enable": "Enable (true) or disable (false) AA for all SWF sprites."
    },
    "draw_flush": {
        "desc": ""
    },
    "draw_getpixel": {
        "desc": "With this function you can get the colour value of any pixel that is being drawn to the current render target. This means that the results will depend on the event in which the function is called, and also on the target surface being used. Note that this will not return any alpha values, for that you should use **draw_getpixel_ext**.\n\nNOTE: This function is incredibly slow and so should only be used when absolutely necessary.",
        "x": "The x coordinate of the pixel to check",
        "y": "The y coordinate of the pixel to check"
    },
    "draw_getpixel_ext": {
        "desc": "With this function you can get the full **abgr 32bit** value of any pixel that is being drawn to the current render target. This means that the results will depend on the event in which the function is called, and also on the target surface being used.\n\nNOTE: This function is slow and so should only be used when absolutely necessary.",
        "x": "The x coordinate of the pixel to check",
        "y": "The y coordinate of the pixel to check"
    },
    "draw_get_alpha": {
        "desc": "This function returns the current value of the draw alpha, which will range between 0 (fully transparent) and 1 (fully opaque). The draw alpha affects the transparency of all draw functions, and can be set with the **draw_set_alpha** function."
    },
    "draw_get_alpha_test": {
        "desc": "With this function you can check to see whether alpha testing is enabled (returns true) or not (returns false). For more information on alpha testing, see the function **draw_set_alpha_test**."
    },
    "draw_get_alpha_test_ref_value": {
        "desc": "You can use this function to find the current value for the alpha test reference (default is 0, but you can use **draw_set_alpha_test_ref_value** to set this value to something other than this)."
    },
    "draw_get_color": {
        "desc": "This function returns the current draw color which is used for drawing forms, text, primitives and un-textured 3D models. This can be set with the draw_set_color function."
    },
    "draw_get_colour": {
        "desc": "This function returns the current draw colour which is used for drawing forms, text, primitives and un-textured 3D models. This can be set with the draw_set_colour function."
    },
    "draw_get_swf_aa_level": {
        "desc": "This function can be used to get the anti-aliasing (AA) level for SWF format vector sprites. The return value will between 0 and 1 and shows how \"smooth\" the edges of these sprites will be drawn. You can set the AA level using the function **draw_set_swf_aa_level()**."
    },
    "draw_healthbar": {
        "desc": "With this function you can draw a coloured bar to show a constant value. Although the function uses the word \"healthbar\" you can use this to display anything you wish as long as the amount to be displayed is a percentage value between 0 and 100 (a percentage of any value can be calculated with the formula (**CURRENT_Value / MAXIMUM_value) * 100**), so, for example, you can use this to display power, health, mana, time or anything else that would benefit from a bar display.\n\nYou can set various different things that change the visual aspect of the bar and these are illustrated in the image below (note that the colours used here are *c_green* for the maximum value and *c_red* for the minimum value, but you can use the colours that you wish): ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/drawing%20basic%20forms/draw_healthbar.png)",
        "x1": "The x coordinate of the left of the healthbar",
        "y1": "The y coordinate of the top of the healthbar",
        "x2": "The x coordinate of the right of the healthbar",
        "y2": "The y coordinate of the bottom of the healthbar",
        "amount": "The variable which defines total health (between 0 and 100)",
        "backcol": "The colour of the background for the bar",
        "mincol": "The colour of the bar when at no health (0)",
        "maxcol": "The colour of the bar when at full health (100)",
        "direction": "Where the bar is 'anchored' (0 = left, 1 = right, 2 = top, 3 = bottom)",
        "showback": "Whether the bar's background is drawn (true) or not (false). If false, the backcol argument is disregarded.",
        "showborder": "Whether the bar's elements have a 1px wide black border (true) or not (false)."
    },
    "draw_highscore": {
        "desc": "This simple function will draw the current list of internally stored high scores using the currently set font, colour and alpha values within the specified rectangle. You provide the coordinates for the upper left corner and lower right corner of the rectangular area to draw the text, and GameMaker: Studio will take care of the rest, with spacing and position being done automatically.",
        "x1": "The x coordinate of the left of the highscore rectangle.",
        "y1": "The y coordinate of the top of the highscore rectangle.",
        "x2": "The x coordinate of the right of the highscore rectangle.",
        "y2": "The y coordinate of the bottom of the highscore rectangle."
    },
    "draw_line": {
        "desc": "With this function you can draw a 1 pixel wide line between any two points in the game room.",
        "x1": "The x coordinate of the start of the line.",
        "y1": "The y coordinate of the start of the line.",
        "x2": "The x coordinate of the end of the line.",
        "y2": "The y coordinate of the end of the line."
    },
    "draw_line_color": {
        "desc": "With this function you can draw a 1 pixel wide line with the color blended between color 1 at the first point and color 2 at the second point. The color settings will over-ride the base color set with the function draw_set_color.",
        "x1": "The x coordinate of the start of the line.",
        "y1": "The y coordinate of the start of the line.",
        "x2": "The x coordinate of the end of the line.",
        "y2": "The y coordinate of the end of the line.",
        "col1": "The color of the start of the line.",
        "col2": "The color of the end of the line."
    },
    "draw_line_colour": {
        "desc": "With this function you can draw a 1 pixel wide line with the colour blended between colour 1 at the first point and colour 2 at the second point. The colour settings will over-ride the base colour set with the function draw_set_colour.",
        "x1": "The x coordinate of the start of the line.",
        "y1": "The y coordinate of the start of the line.",
        "x2": "The x coordinate of the end of the line.",
        "y2": "The y coordinate of the end of the line.",
        "col1": "The colour of the start of the line.",
        "col2": "The colour of the end of the line."
    },
    "draw_line_width": {
        "desc": "With this function you can draw a line of a specified width between any two points in the game room.",
        "x1": "The x coordinate of the start of the line.",
        "y1": "The y coordinate of the start of the line.",
        "x2": "The x coordinate of the end of the line.",
        "y2": "The y coordinate of the end of the line.",
        "w": "The width of the line in pixels."
    },
    "draw_line_width_color": {
        "desc": "With this function you can draw a line of a specific width with the color blended between color 1 at the first point and color 2 at the second point. The color settings will over-ride the base color set with the function **draw_set_color**.",
        "x1": "The x coordinate of the start of the line.",
        "y1": "The y coordinate of the start of the line.",
        "x2": "The x coordinate of the end of the line.",
        "y2": "The y coordinate of the end of the line.",
        "w": "The width in pixels of the line.",
        "col1": "The color of the start of the line.",
        "col2": "The color of the end of the line."
    },
    "draw_line_width_colour": {
        "desc": "With this function you can draw a line of a specific width with the colour blended between colour 1 at the first point and colour 2 at the second point. The colour settings will over-ride the base colour set with the function **draw_set_colour**.",
        "x1": "The x coordinate of the start of the line.",
        "y1": "The y coordinate of the start of the line.",
        "x2": "The x coordinate of the end of the line.",
        "y2": "The y coordinate of the end of the line.",
        "w": "The width in pixels of the line.",
        "col1": "The colour of the start of the line.",
        "col2": "The colour of the end of the line."
    },
    "draw_path": {
        "desc": "With this function you can get GameMaker: Studio to draw a path to the screen. The path will be drawn as a simple line, and can be either relative to the calling instance or at the absolute position it was created at in the path editor or through code. This function is extremely useful when debugging dynamic paths (for example, those created for instances with the **mp_grid_path** function).",
        "path": "The path to draw",
        "x1": "The x coordinate of where the path is drawn",
        "y1": "The y coordinate of where the path is drawn",
        "absolute": "Whether the path is drawn at the absolute position (true) or the relative position (false)"
    },
    "draw_point": {
        "desc": "With this function you can draw a single pixel anywhere on the screen.",
        "x": "The x coordinate of the point to be drawn.",
        "y": "The y coordinate of the point to be drawn."
    },
    "draw_point_color": {
        "desc": "With this function you can draw a single pixel anywhere on the screen with a color that you define. The color settings will over-ride the base color set with the function **draw_set_color**.",
        "x": "The x coordinate of the point.",
        "y": "The y coordinate of the point.",
        "col": "The color of the point."
    },
    "draw_point_colour": {
        "desc": "With this function you can draw a single pixel anywhere on the screen with a colour that you define. The colour settings will over-ride the base colour set with the function **draw_set_colour**.",
        "x": "The x coordinate of the point.",
        "y": "The y coordinate of the point.",
        "col": "The colour of the point."
    },
    "draw_primitive_begin": {
        "desc": "This function must be called before you can define any primitives. There are 6 types of primitives you can define with the following constants:\n\n - **pr_pointlist**\n\n - **pr_linelist**\n\n - **pr_linestrip**\n\n - **pr_trianglelist**\n\n - **pr_trianglestrip**\n\n - **pr_trianglefan** (This is not available on the HTML5 target platform and may not work correctly on some devices for other platforms)\n\nThe following image illustrates basically how these should look and also the order in which you should define the vertexes: ![](https://docs.yoyogames.com/source/dadiospice/images/primitive_types.png)",
        "kind": "The kind of primitive you are going to draw."
    },
    "draw_primitive_begin_texture": {
        "desc": "This function must be called before you define the vertices of a textured primitive. You must give the kind of primitive to use (see **draw_primitive_begin** for more information) and the id of a texture to use, which can be a sprite or background image asset. This asset id can be gotten from the functions **sprite_get_texture** and **background_get_texture** (use -1 for no texture).\n\nNOTE: For a texture to repeat it must be a power of two in size, ie: 32x32, 128x128, etc...",
        "kind": "The kind of primitive you are going to draw.",
        "texid": "The texture to use with the primitive."
    },
    "draw_primitive_end": {
        "desc": "This function must be called when you have finished defining the points of your primitive. If you do not call this function, nothing will be drawn as this effectively tells GameMaker: Studio that you have finished and that it can now draw the defined primitive."
    },
    "draw_rectangle": {
        "desc": "With this function you can draw either an outline of a rectangle or a filled rectangle where the (x1,y1) position is the top left corner and the (x2,y2) position is the bottom right corner.",
        "x1": "The x coordinate of the top left corner of the rectangle.",
        "y1": "The y coordinate of the top left corner of the rectangle.",
        "x2": "The x coordinate of the bottom right corner of the rectangle.",
        "y2": "The y coordinate of the bottom right corner of the rectangle.",
        "outline": "Whether the rectangle is drawn filled (false) or as a one pixel wide outline (true)."
    },
    "draw_rectangle_color": {
        "desc": "With this function you can draw either an outline of a rectangle or a filled rectangle by defining an area where the (x1,y1) position is the top left corner and the (x2,y2) position is the bottom right corner. If it is filled you can define the individual colors for each corner point and if these colors are not the same, you will get a gradient effect from one to the other (the color settings will over-ride the base color set with the function **draw_set_color**).",
        "x1": "The x coordinate of the left of the rectangle.",
        "y1": "The y coordinate of the top of the rectangle.",
        "x2": "The x coordinate of the right of the rectangle.",
        "y2": "The y coordinate of the bottom of the rectangle.",
        "col1": "The color of the top left corner.",
        "col2": "The color of the top right corner.",
        "col3": "The color of the bottom right corner.",
        "col4": "The color of the bottom left corner.",
        "outline": "Whether the rectangle is an outline (true) or filled in (false)."
    },
    "draw_rectangle_colour": {
        "desc": "With this function you can draw either an outline of a rectangle or a filled rectangle by defining an area where the (x1,y1) position is the top left corner and the (x2,y2) position is the bottom right corner. If it is filled you can define the individual colours for each corner point and if these colours are not the same, you will get a gradient effect from one to the other (the colour settings will over-ride the base colour set with the function **draw_set_colour**).",
        "x1": "The x coordinate of the left of the rectangle.",
        "y1": "The y coordinate of the top of the rectangle.",
        "x2": "The x coordinate of the right of the rectangle.",
        "y2": "The y coordinate of the bottom of the rectangle.",
        "col1": "The colour of the top left corner.",
        "col2": "The colour of the top right corner.",
        "col3": "The colour of the bottom right corner.",
        "col4": "The colour of the bottom left corner.",
        "outline": "Whether the rectangle is an outline (true) or filled in (false)."
    },
    "draw_roundrect": {
        "desc": "With this function you can draw either an outline of a rounded rectangle or a filled rounded rectangle where the (x1,y1) position is the top left corner and the (x2,y2) position is the bottom right corner. You can define how precise the drawing of the corners is with the function **draw_set_circle_precision**, but this function uses a fixed radius for them (should you need to change the corner radius, use the function **draw_roundrect_ext()**).",
        "x1": "The x coordinate of the top left corner of the rounded rectangle (as if it were a normal rectangle).",
        "y1": "The y coordinate of the top left corner of the rounded rectangle (as if it were a normal rectangle).",
        "x2": "The x coordinate of the bottom right corner of the rounded rectangle (as if it were a normal rectangle).",
        "y2": "The y coordinate of the bottom right corner of the rounded rectangle (as if it were a normal rectangle).",
        "outline": "Whether the rounded rectangle is drawn filled (false) or as a one pixel wide outline (true)."
    },
    "draw_roundrect_color": {
        "desc": "With this function you can draw either an outline of a rounded rectangle or a filled rounded rectangle where the (x1,y1) position is the top left corner and the (x2,y2) position is the bottom right corner. If it is filled you can define the individual colors for the centre and the edges, and if these colors are not the same, you will get a gradient effect from one to the other (the color settings will over-ride the base color set with the function **draw_set_color**).You can define how precise the drawing of the corners is with the function **draw_set_circle_precision**, but the corners are always drawn with a fixed radius. Should you need to change the corner radius you should use the function **draw_roundrect_color_ext()**.",
        "x1": "The x coordinate of the left of the rounded rectangle.",
        "y1": "The y coordinate of the top of the rounded rectangle.",
        "x2": "The x coordinate of the right of the rounded rectangle.",
        "y2": "The y coordinate of the bottom of the rounded rectangle.",
        "col1": "The center color.",
        "col2": "The outside edge color.",
        "outline": "Whether the rectangle is an outline (true) or filled in (false)."
    },
    "draw_roundrect_color_ext": {
        "desc": "With this function you can draw either an outline of a rounded rectangle or a filled rounded rectangle where the (x1,y1) position is the top left corner and the (x2,y2) position is the bottom right corner. If the rectangle is filled, then the color arguments will be used to generate a color gradient from the centre to the edges, where color 1 is the centre color and color 2 the edge color. You must also supply radius values for the x and y axis (in pixels) and the corners will be rounded by these amounts. You can define how precise the drawing of the corners is with the function **draw_set_circle_precision**.",
        "x1": "The x coordinate of the left of the rounded rectangle.",
        "y1": "The y coordinate of the top of the rounded rectangle.",
        "x2": "The x coordinate of the right of the rounded rectangle.",
        "y2": "The y coordinate of the bottom of the rounded rectangle.",
        "radiusx": "The radius of the curve along the x axis from the rectangle corners.",
        "radiusy": "The radius of the curve along the y axis from the rectangle corners.",
        "col1": "The center color.",
        "col2": "The outside edge color.",
        "outline": "Whether the rectangle is an outline (true) or filled in (false)."
    },
    "draw_roundrect_colour": {
        "desc": "With this function you can draw either an outline of a rounded rectangle or a filled rounded rectangle where the (x1,y1) position is the top left corner and the (x2,y2) position is the bottom right corner. If it is filled you can define the individual colours for the centre and the edges, and if these colours are not the same, you will get a gradient effect from one to the other (the colour settings will over-ride the base colour set with the function **draw_set_colour**).You can define how precise the drawing of the corners is with the function **draw_set_circle_precision**, but the corners are always drawn with a fixed radius. Should you need to change the corner radius you should use the function **draw_roundrect_colour_ext()**.",
        "x1": "The x coordinate of the left of the rounded rectangle.",
        "y1": "The y coordinate of the top of the rounded rectangle.",
        "x2": "The x coordinate of the right of the rounded rectangle.",
        "y2": "The y coordinate of the bottom of the rounded rectangle.",
        "col1": "The center colour.",
        "col2": "The outside edge colour.",
        "outline": "Whether the rectangle is an outline (true) or filled in (false)."
    },
    "draw_roundrect_colour_ext": {
        "desc": "With this function you can draw either an outline of a rounded rectangle or a filled rounded rectangle where the (x1,y1) position is the top left corner and the (x2,y2) position is the bottom right corner. If the rectangle is filled, then the colour arguments will be used to generate a colour gradient from the centre to the edges, where colour 1 is the centre colour and colour 2 the edge colour. You must also supply radius values for the x and y axis (in pixels) and the corners will be rounded by these amounts. You can define how precise the drawing of the corners is with the function **draw_set_circle_precision**.",
        "x1": "The x coordinate of the left of the rounded rectangle.",
        "y1": "The y coordinate of the top of the rounded rectangle.",
        "x2": "The x coordinate of the right of the rounded rectangle.",
        "y2": "The y coordinate of the bottom of the rounded rectangle.",
        "radiusx": "The radius of the curve along the x axis from the rectangle corners.",
        "radiusy": "The radius of the curve along the y axis from the rectangle corners.",
        "col1": "The center colour.",
        "col2": "The outside edge colour.",
        "outline": "Whether the rectangle is an outline (true) or filled in (false)."
    },
    "draw_roundrect_ext": {
        "desc": "With this function you can draw either an outline of a rounded rectangle or a filled rounded rectangle where the (x1,y1) position is the top left corner and the (x2,y2) position is the bottom right corner. You must also supply radius values for the x and y axis (in pixels) and the corners will be rounded by these amounts. You can define how precise the drawing of the corners is with the function **draw_set_circle_precision**.",
        "x1": "The x coordinate of the top left corner of the rounded rectangle (as if it were a normal rectangle).",
        "y1": "The y coordinate of the top left corner of the rounded rectangle (as if it were a normal rectangle).",
        "x2": "The x coordinate of the bottom right corner of the rounded rectangle (as if it were a normal rectangle).",
        "y2": "The y coordinate of the bottom right corner of the rounded rectangle (as if it were a normal rectangle).",
        "radiusx": "The radius of the curve along the x axis from the rectangle corners.",
        "radiusy": "The radius of the curve along the y axis from the rectangle corners.",
        "outline": "Whether the rounded rectangle is drawn filled (false) or as a one pixel wide outline (true)."
    },
    "draw_self": {
        "desc": "This function draws the sprite assigned to the instance exactly as it would be drawn if the draw event held no code or actions, and will reflect and changes that have been made to the sprite variables in other events.\n\n  NOTE: If the instance has no sprite assigned to it, this function will throw an error!"
    },
    "draw_set_alpha": {
        "desc": "With this function you can set the base draw alpha for the game. This value can be set from 0 to 1 with 0 being fully transparent and 1 being fully opaque (the default value), and will affect all further drawing, including backgrounds, sprites, fonts, primitives and 3D. If any of those assets are drawn with their own alpha value changed, this will be added to the base alpha value set by this function, so a base alpha of 0.5 and a sprite being drawn with an alpha of 0.5 will actually draw the sprite with an alpha of 0.25.",
        "alpha": "The alpha to set (between 0 and 1)"
    },
    "draw_set_alpha_test": {
        "desc": "This function will enable or disable alpha testing for your game (by default this is disabled). By switching alpha testing on you can then use the companion function **draw_set_alpha_test_ref_value** to set the \"cut-off\" value at which all alpha values will be set to 0. The image below shows the difference that can be seen when alpha testing is switched on or off: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/colour%20and%20blending/alpha_test_on_off.png)\n\nNOTE: This function may negatively affect performance on iOS and Android devices.",
        "enable": "Set to true or false to enable or disable alpha testing."
    },
    "draw_set_alpha_test_ref_value": {
        "desc": "This function will set the reference value for the alpha testing (when it has been enabled using the **draw_set_alpha_test**). This is the \"cut-off\" threshold at which pixels with alpha will not be drawn.\n\nBasically, if you have this value set to 0 and you have texture interpolation turned on, you can still get visual errors at the edges of overlapping objects. This is because you can have almost completely transparent areas that block things drawn behind them, but if you set this reference value to, for example, 254 (i.e. one below maximum), this guarantees that only 100% opaque pixels are going to be drawn. You can also turn texture interpolation off, which would normally allow you to use the default values with no problems and no need to use this function at all, however a lot depends on the source artwork.\n\nNOTE: This is an advanced drawing feature, so if you are not sure whether you need it or not, or don't know exactly what it does, you are probably better off not using it as it can seriously corrupt how your game is drawn.",
        "value": "Sets the reference value for alpha testing from 0 to 255 (default value is 0)"
    },
    "draw_set_blend_mode": {
        "desc": "When GameMaker: Studio goes to draw a pixel there is a source colour (the colour of the pixel we're going to draw) and a destination colour(the colour that's already in the pixel we're drawing to), so when determining the new colour of the pixel, the source and destination colours are calculated according to the chosen blend mode. Each component of the colours is stored as a floating point value between 0 and 1, and the new colour is calculated by multiply each component of the source colour by some factor and by multiplying each component of destination colour by some other factor and then adding the results together component by component.\n\nThis function permits you to set the blend mode in four basic ways using the following constants: ![](https://gmlsupport.liaronce.win/images-in-intellisense/5.png)\n\nAs you can see these modes are really composites of extended blend modes and those can be found on the page describing **draw_set_blend_mode_ext**.",
        "mode": "The blend mode constant to set to (see the table below)."
    },
    "draw_set_blend_mode_ext": {
        "desc": "When GameMaker: Studio goes to draw a pixel there is a source colour (the colour of the pixel we're going to draw) and a destination colour(the colour that's already in the pixel we're drawing to), so when determining the new colour of the pixel, the source and destination colours are calculated according to the chosen blend mode. Each component of the colours is stored as a floating point value between 0 and 1, and the new colour is calculated by multiply each component of the source colour by some factor and by multiplying each component of destination colour by some other factor and then adding the results together component by component.\n\nThis function permits you to set the different component parts that should be factored together to create a custom blend mode. The source and destination both have a red, green, blue and alpha component, and in the following chart the source's RGBA are considered (Rs, Gs, Bs, As) while the destination's are (Rd, Gd, Bd, Ad). The eleven constants that are available for use can be either source or destination (or both) when used in this function.\n\n![](https://gmlsupport.liaronce.win/images-in-intellisense/6.png)\n\nIt can be quite difficult to visualise how these different blend modes work, so below you can find a simple chart that shows the basic interaction of a single sprite being drawn with different combinations of blend modes over a single background. Please note that the actual results of the blend mode you use will very much depend on the colour in the sprite, the alpha value of the sprite and the colour and alpha of the background.\n\n![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/colour%20and%20blending/blendmode_chart.png)\n\nWARNING!: Not all blend modes are available on all platforms. Android, iOS, and HTML5 without WebGL enabled, will not be able to display the following modes correctly:\n\n - bm_src_colour\n\n - bm_inv_src_colour\n\n - bm_dest_colour\n\n - bm_inv_dest_colour\n\n - bm_src_alpha_sat",
        "src": "Source (see constants above).",
        "dest": "Destination (see constants above)"
    },
    "draw_set_circle_precision": {
        "desc": "To optimise performance when drawing circles, GameMaker: Studio basically draws a polygon shape with enough sides to make it appear circular. However, depending on how big or small you need your circles to be, you may find that changing this value can help increase the performance of your game, or make the circles look better. The precision value that you can input into this function is the number of sides the circle polygon has, and this number can be anything between 4 and 64, but must be a number divisible by 4, with a default value of 24.\n\n![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/drawing%20basic%20forms/draw_set_circle_precision.png)",
        "precision": "The precision of all circles drawn after this function is called."
    },
    "draw_set_color": {
        "desc": "With this function you can set the base draw color for the game. This value will affect all further drawing where appropriate, including fonts, forms, primitives and 3D. If any of those assets are drawn with their own color value changed, this value will be ignored.",
        "col": "The color to set for drawing."
    },
    "draw_set_color_write_enable": {
        "desc": "With this function you can switch on or off the color channels and the alpha channel for all further drawing. You can use this function to create alpha-channel only surfaces (switch off the RGB writing before using the surface), or to create special effects while drawing to the screen. The default value for each of the components is true.",
        "red": "The color to set for drawing.",
        "green": "The color to set for drawing.",
        "blue": "The color to set for drawing.",
        "alpha": "The color to set for drawing."
    },
    "draw_set_colour": {
        "desc": "With this function you can set the base draw colour for the game. This value will affect all further drawing where appropriate, including fonts, forms, primitives and 3D. If any of those assets are drawn with their own colour value changed, this value will be ignored.",
        "col": "The colour to set for drawing."
    },
    "draw_set_colour_write_enable": {
        "desc": "With this function you can switch on or off the colour channels and the alpha channel for all further drawing. You can use this function to create alpha-channel only surfaces (switch off the RGB writing before using the surface), or to create special effects while drawing to the screen. The default value for each of the components is true.",
        "red": "The colour to set for drawing.",
        "green": "The colour to set for drawing.",
        "blue": "The colour to set for drawing.",
        "alpha": "The colour to set for drawing."
    },
    "draw_set_font": {
        "desc": "This function will set the font to be used for all further text drawing. This font must have been added into the font assets of the game or have been created using either the **font_add** or **font_add_sprite**. You may also set this to -1 to default to drawing text using a 12point Arial font.",
        "font": "The name of the font to use."
    },
    "draw_set_halign": {
        "desc": "This function is used to align text along the horizontal axis and changing the horizontal alignment will change the position and direction in which all further text is drawn with the default value being **fa_left**. The following constants are accepted: ![](https://gmlsupport.liaronce.win/images-in-intellisense/7.png)",
        "halign": "Horizontal alignment."
    },
    "draw_set_swf_aa_level": {
        "desc": "This function can be used to set the anti-aliasing (AA) level for SWF format vector sprites. This can be a real value from 0 to 1 and will \"smooth\" the edges of these sprites. Note that to see this effect, you must first have enabled AA using the function **draw_enable_swf_aa()**.",
        "aa_level": "The anti-aliasing value to use from 0 to 1."
    },
    "draw_set_valign": {
        "desc": "This function is used to align text along the vertical axis and changing the vertical alignment will change the position and direction in which all further text is drawn, with the default value being fa_top. The following constants are accepted: ![](https://gmlsupport.liaronce.win/images-in-intellisense/8.png)",
        "valign": "Vertical alignment."
    },
    "draw_skeleton": {
        "desc": "This function is only for use with sprites that have been created using a skeletal animation program like Spine. While you can draw these sprites using the normal draw functions (like **draw_self()**), there are times when you may want to draw a single frame or show a change of skin texture without actually changing the sprite properties. In these cases you can draw the sprite with this function, where you give the sprite index and then the name of the animation to get the frame from (a string, as set within the program used to make the sprite). Next you give the name of the skin to use (again, as set when the sprite was made), and a frame value. The frame value is for telling GameMaker: Studio what part of the animation to show and is a value between 0 and the **image_number**. The rest of the arguments are the same as those used for normal sprite drawing and will change the scale, angle, blend colour and alpha of the final animation frame being drawn.\n\nWARNING! Because of the way skeletal animations are interpolated between various \"key\" frames, there is an additional overhead associated with this call and therefore it is recommended that you avoid drawing skeleton based sprites using this method unless absolutely necessary.",
        "sprite": "The index of the sprite to draw.",
        "animname": "The name of the animation to get the frame from (a string).",
        "skinname": "The name of the skin to use (a string).",
        "frame": "The animation frame to draw (from 0 to image_number - 1).",
        "x": "The x coordinate of where to draw the sprite.",
        "y": "The y coordinate of where to draw the sprite.",
        "xscale": "The horizontal scaling of the sprite, as a multiplier: 1 = normal scaling, 0.5 is half etc...",
        "yscale": "The vertical scaling of the sprite, as a multiplier: 1 = normal scaling, 0.5 is half etc...",
        "rot": "The rotation of the sprite. 0=normal, 90=turned 90 degrees counter-clockwise etc.",
        "colour": "The colour with which to blend the sprite.",
        "alpha": "The alpha of the sprite (from 0 to 1 where 0 is transparent and 1 opaque)."
    },
    "draw_skeleton_collision": {
        "desc": "This function will draw the collision masks associated with the given skeletal animation. You supply the base sprite, the animation set to use and the frame to get the information from, and you can also set the transform properties to suit.",
        "sprite": "The index of the sprite to draw.",
        "animname": "The name of the animation to get the frame from (a string).",
        "frame": "The animation frame to draw (from 0 to image_number - 1).",
        "x": "The x coordinate of where to draw the sprite.",
        "y": "The y coordinate of where to draw the sprite.",
        "xscale": "The horizontal scaling of the sprite, as a multiplier: 1 = normal scaling, 0.5 is half etc...",
        "yscale": "The vertical scaling of the sprite, as a multiplier: 1 = normal scaling, 0.5 is half etc...",
        "rot": "The rotation of the sprite. 0=normal, 90=turned 90 degrees counter-clockwise etc.",
        "colour": "The colour with which to blend the sprite."
    },
    "draw_skeleton_instance": {
        "desc": "",
        "instance": "",
        "animname": "",
        "skinname": "",
        "frame": "",
        "x": "",
        "y": "",
        "xscale": "",
        "yscale": "",
        "rot": "",
        "colour": "",
        "alpha": ""
    },
    "draw_skeleton_time": {
        "desc": "This function will draw the given animation using the given skin at a specific time in the animation. The time value should be between 0 (the beginning) and the end duration of the animation, which you can find using the function **skeleton_animation_get_duration()**. You can set the time value to values higher than the total duration of the animation and the animation will loop back to the beginning, but you run the risk of losing floating point accuracy as the accumulated time gets larger.",
        "sprite": "The index of the sprite to draw.",
        "animname": "The name of the animation to get the frame from (a string).",
        "skinname": "The name of the skin to use for drawing (a string).",
        "time": "The time-frame to draw the animation at (from 0 to the end duration, in seconds).",
        "x": "The x coordinate of where to draw the sprite.",
        "y": "The y coordinate of where to draw the sprite.",
        "xscale": "The horizontal scaling of the sprite, as a multiplier: 1 = normal scaling, 0.5 is half etc...",
        "yscale": "The vertical scaling of the sprite, as a multiplier: 1 = normal scaling, 0.5 is half etc...",
        "rot": "The rotation of the sprite. 0=normal, 90=turned 90 degrees counter-clockwise etc.",
        "colour": "The colour with which to blend the sprite.",
        "alpha": ""
    },
    "draw_sprite": {
        "desc": "This function draws the given sprite and sub-image at a position within the game room. For the sprite you can use the instance variable **sprite_index** to get the current sprite that is assigned to the instance running the code, or you can use any other sprite asset. The same goes for the sub-image, as this can also be set to the instance variable **image_index** which will set the sub-image to that selected for the current instance sprite (note, that you can draw a different sprite and still use the sub-image value for the current instance), or you can use any other value for this to draw a specific sub-image of the chosen sprite. If the value is larger than the number of sub-images, then GameMaker: Studio will automatically loop the number to select the corresponding image (for example, if the sprite being drawn has 5 sub-images numbered 0 to 4 and we set the index value to 7, then the function will draw sub-image 3, numbered 0). Finally, the x and y position is the position within the room that the sprite will be drawn, and it is centered on the sprite x offset and y offset.",
        "sprite": "The index of the sprite to draw.",
        "subimg": "The sub-image (frame) of the sprite to draw (image_index or -1 correlate to the current frame of animation in the object).",
        "x": "The x coordinate of where to draw the sprite.",
        "y": "The y coordinate of where to draw the sprite."
    },
    "draw_sprite_ext": {
        "desc": "This function will draw the given sprite as in the function **draw_sprite** but with additional options to change the scale, blending, rotation and alpha of the sprite being drawn. Changing these values does not modify the resource in any way (only how it is drawn), and you can use any of the available sprite variables instead of direct values for all the arguments in the function. The image below illustrates how different values affect the drawing of the sprite: \n\n![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/drawing%20sprites%20and%20backgrounds/spr_ext.png)\n\n![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/drawing%20sprites%20and%20backgrounds/spr_ext.png)\n\nNOTE: Colour blending is only recommended for the HTML5 target when WebGL is enabled, although you can still set the blending colour if it is not enabled and it will blend the sprite as normal. However all blending in this way creates a duplicate sprite which is then stored in the cache and used when required. This is far from optimal and if you use multiple colour changes it will slow down your games performance unless you activate WebGL. if you do not wish to use WebGL, then you can set the font cache size to try and limit this should it be necessary using the function sprite_set_cache_size.",
        "sprite": "The index of the sprite to draw.",
        "subimg": "The subimg (frame) of the sprite to draw (image_index or -1 correlate to the current frame of animation in the object).",
        "x": "The x coordinate of where to draw the sprite.",
        "y": "The y coordinate of where to draw the sprite.",
        "xscale": "The horizontal scaling of the sprite, as a multiplier: 1 = normal scaling, 0.5 is half etc...",
        "yscale": "The vertical scaling of the sprite as a multiplier: 1 = normal scaling, 0.5 is half etc...",
        "rot": "The rotation of the sprite. 0=right way up, 90=rotated 90 degrees counter-clockwise etc...",
        "colour": "The colour with which to blend the sprite. c_white is to display it normally.",
        "alpha": "The alpha of the sprite (from 0 to 1 where 0 is transparent and 1 opaque)."
    },
    "draw_sprite_general": {
        "desc": "This function combines the function **draw_sprite_ext** with the function **draw_sprite_part**, adding in some additional blending options so that each corner of the final sprite part can be blended with an individual colour.\n\nNOTE: Colour blending is only recommended for the HTML5 target when WebGL is enabled, although you can still set the blending colour if it is not enabled and it will blend the sprite as normal. However all blending in this way creates a duplicate sprite which is then stored in the cache and used when required. This is far from optimal and if you use multiple colour changes it will slow down your games performance unless you activate WebGL. if you do not wish to use WebGL, then you can set the font cache size to try and limit this should it be necessary using the function **sprite_set_cache_size**.",
        "sprite": "The index of the sprite to draw.",
        "subimg": "The subimg (frame) of the sprite to draw (image_index or -1 correlate to the current frame of animation in the object).",
        "left": "The x position on the sprite of the top left corner of the area to draw.",
        "top": "The y position on the sprite of the top left corner of the area to draw.",
        "width": "The width of the area to draw.",
        "height": "The height of the area to draw.",
        "x": "The x coordinate of where to draw the sprite.",
        "y": "The y coordinate of where to draw the sprite.",
        "xscale": "The horizontal scaling of the sprite, as a multiplier: 1 = normal scaling, 0.5 is half etc...",
        "yscale": "The vertical scaling of the sprite, as a multiplier: 1 = normal scaling, 0.5 is half etc...",
        "rot": "The rotation of the sprite. 0=normal, 90=turned 90 degrees counter-clockwise etc.",
        "c1": "The colour with which to blend the top left area of the sprite.",
        "c2": "The colour with which to blend the top right area of the sprite.",
        "c3": "The colour with which to blend the bottom right area of the sprite.",
        "c4": "The colour with which to blend the bottom left area of the sprite.",
        "alpha": "The alpha of the sprite (from 0 to 1 where 0 is transparent and 1 opaque)."
    },
    "draw_sprite_part": {
        "desc": "With this function you can draw part of any sprite at a given position within the room. As with **draw_sprite** you can specify a sprite and a sub-image for drawing, then you must give the relative coordinates within the sprite of the area to select for drawing. This means that a left position of 0 and a top position of 0 would be the top left corner of the sprite and all further coordinates should be taken from that position. The image below shows an example of how this works: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/drawing%20sprites%20and%20backgrounds/spr_part.png)\n\nYou should note that if the texture page permits automatic cropping then this function may not work as expected, since the extra \"empty\" space around the sprite will have been removed for creating the texture page. To resolve this issue, you will need to set the texture page settings (in the Global Game Settings) to no cropping.\n\nNOTE: When drawing with this function, the sprite x offset and y offset are ignored and the sprite part will be drawn with the top left corner at the specified x / y position in the room.\n\nNOTE: This function is only useful for bitmap sprites and will not work with SWF or JSON (Spine) sprites.",
        "sprite": "The index of the sprite to draw.",
        "subimg": "The subimg (frame) of the sprite to draw (image_index or -1 correlate to the current frame of animation in the object).",
        "left": "The x position on the sprite of the top left corner of the area to draw.",
        "top": "The y position on the sprite of the top left corner of the area to draw.",
        "width": "The width of the area to draw.",
        "height": "The height of the area to draw.",
        "x": "The x coordinate of where to draw the sprite.",
        "y": "The y coordinate of where to draw the sprite."
    },
    "draw_sprite_part_ext": {
        "desc": "This function will draw a part of the chosen sprite at the given position following the same rules as per **draw_sprite_part**, only now you can scale the part, blend a colour with it, or change its alpha when drawing it to the screen (the same as when drawing a sprite with **draw_sprite_ext**). You should note that if the texture page permits automatic cropping then this function may not work as expected, since the extra \"empty\" space around the sprite will have been removed for creating the texture page. To resolve this issue, you will need to set the texture page settings (in the Global Game Settings) to **no cropping**.\n\nNOTE: When drawing with this function, the sprite x offset and y offset are ignored and the sprite part will be drawn with the top left corner at the specified x / y position in the room.\n\nNOTE: Colour blending is only recommended for the HTML5 target when WebGL is enabled, although you can still set the blending colour if it is not enabled and it will blend the sprite as normal. However all blending in this way creates a duplicate sprite which is then stored in the cache and used when required. This is far from optimal and if you use multiple colour changes it will slow down your games performance unless you activate WebGL. if you do not wish to use WebGL, then you can set the font cache size to try and limit this should it be necessary using the function **sprite_set_cache_size**.\n\nNOTE: This function is only useful for bitmap sprites and will not work with SWF or JSON (Spine) sprites.",
        "sprite": "The index of the sprite to draw.",
        "subimg": "The subimg (frame) of the sprite to draw (image_index or -1 correlate to the current frame of animation in the object).",
        "left": "The x position on the sprite of the top left corner of the area to draw.",
        "top": "The y position on the sprite of the top left corner of the area to draw.",
        "width": "The width of the area to draw.",
        "height": "The height of the area to draw.",
        "x": "The x coordinate of where to draw the sprite.",
        "y": "The y coordinate of where to draw the sprite.",
        "xscale": "The horizontal scaling of the sprite, as a multiplier: 1 = normal scaling, 0.5 is half etc...",
        "yscale": "The vertical scaling of the sprite, as a multiplier: 1 = normal scaling, 0.5 is half etc...",
        "colour": "The colour with which to blend the sprite. c_white is to display it normally.",
        "alpha": "The alpha of the sprite (from 0 to 1 where 0 is transparent and 1 opaque)."
    },
    "draw_sprite_pos": {
        "desc": "With this function you can draw a sprite distorted over the area defined by the four corner coordinates. The first two arguments are the sprite to draw and the sub-image of the sprite (the same as in the function **draw_sprite**) but the next ones are those that define the position of each of the four corners of the **bounding box** of the given sprite. These should be given in clockwise order, so the first coordinate is the top left, then the top right, then bottom right and finally the bottom left. You can also set a value for the alpha of the sprite to draw it with transparency. The image below illustrates how this function works: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/drawing%20sprites%20and%20backgrounds/spr_pos.png)\n\nWARNING: The image above is only for illustrative purposes, and if you use this function on a sprite, you will get different results and may experience texture \"shearing\" due to the way that a sprite is constructed from a quad of primitives.\n\nNOTE: This function is only useful for bitmap sprites and will not work with SWF or JSON (Spine) sprites.",
        "sprite": "The index of the sprite to draw.",
        "subimg": "The subimg (frame) of the sprite to draw (image_index or -1 correlate to the current frame of animation in the object).",
        "x1": "The first x coordinate.",
        "y1": "The first y coordinate.",
        "x2": "The second x coordinate.",
        "y2": "The second y coordinate.",
        "x3": "The third x coordinate.",
        "y3": "The third y coordinate.",
        "x4": "The fourth x coordinate.",
        "y4": "The fourth y coordinate.",
        "alpha": "The alpha of the sprite (from 0 to 1 where 0 is transparent and 1 opaque)."
    },
    "draw_sprite_stretched": {
        "desc": "This function simply takes a sprite resource and stretches it over the given width and height so that it occupies the area. As with **draw_sprite** you can specify a sprite and a sub-image for drawing, then the x / y position in the room for the sprite to be drawn at and finally a width and a height (which must be pixel values). The image below illustrates how this function works: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/drawing/drawing%20sprites%20and%20backgrounds/spr_stretch.png)\n\nNOTE: When drawing with this function, the sprite x offset and y offset are ignored and the sprite will be drawn with the top left corner at the specified x / y position in the room.",
        "sprite": "The index of the sprite to draw.",
        "subimg": "The subimg (frame) of the sprite to draw (image_index or -1 correlate to the current frame of animation in the object).",
        "x": "The x coordinate of where to draw the sprite.",
        "y": "The y coordinate of where to draw the sprite.",
        "w": "The width of the area the stretched sprite will occupy.",
        "h": "The height of the area the stretched sprite will occupy."
    },
    "draw_sprite_stretched_ext": {
        "desc": "This function does exactly the same as the **draw_sprite_stretched** function with the added ability to set the colour blending and alpha value for the sprite when it is drawn (similar to the function **draw_sprite_ext**).\n\nNOTE: Colour blending is only recommended for the HTML5 target when WebGL is enabled, although you can still set the blending colour if it is not enabled and it will blend the sprite as normal. However all blending in this way creates a duplicate sprite which is then stored in the cache and used when required. This is far from optimal and if you use multiple colour changes it will slow down your games performance unless you activate WebGL. if you do not wish to use WebGL, then you can set the font cache size to try and limit this should it be necessary using the function **sprite_set_cache_size**.",
        "sprite": "The index of the sprite to draw.",
        "subimg": "The subimg (frame) of the sprite to draw (image_index or -1 correlate to the current frame of animation in the object).",
        "x": "The x coordinate of where to draw the sprite.",
        "y": "The y coordinate of where to draw the sprite.",
        "w": "The width of the area the stretched sprite will occupy.",
        "h": "The height of the area the stretched sprite will occupy.",
        "colour": "The colour with which to blend the sprite. c_white is to display it normally.",
        "alpha": "The alpha of the sprite (from 0 to 1 where 0 is transparent and 1 opaque)."
    },
    "draw_sprite_tiled": {
        "desc": "This function will take a sprite and then repeatedly tile it across the whole view (or room if no view is defined), starting from the coordinates that you give in the function. Tiling is based on the width and height of the sprite as defined by the sprite variables of the instance running the code.",
        "sprite": "The index of the sprite to draw.",
        "subimg": "The subimg (frame) of the sprite to draw (image_index or -1 correlate to the current frame of animation in the object).",
        "x": "The x coordinate of where to draw the sprite.",
        "y": "The y coordinate of where to draw the sprite."
    },
    "draw_sprite_tiled_ext": {
        "desc": "This function will take a sprite and then repeatedly tile it across the whole view (or room if no view is defined), starting from the coordinates that you give in the function and with each tile scaled, colour blended and with the alpha that you define (these properties are the same as those used in **draw_sprite_ext**).\n\nNOTE: Colour blending is only recommended for the HTML5 target when WebGL is enabled, although you can still set the blending colour if it is not enabled and it will blend the sprite as normal. However all blending in this way creates a duplicate sprite which is then stored in the cache and used when required. This is far from optimal and if you use multiple colour changes it will slow down your games performance unless you activate WebGL. if you do not wish to use WebGL, then you can set the font cache size to try and limit this should it be necessary using the function **sprite_set_cache_size**.",
        "sprite": "The index of the sprite to draw.",
        "subimg": "The subimg (frame) of the sprite to draw (image_index or -1 correlate to the current frame of animation in the object).",
        "x": "The x coordinate of where to draw the sprite.",
        "y": "The y coordinate of where to draw the sprite.",
        "xscale": "The horizontal scaling of the sprite. A multiplier ' 1 = normal scaling, 0.5 is half etc.",
        "yscale": "The vertical scaling of the sprite. A multiplier ' 1 = normal scaling, 0.5 is half etc.",
        "colour": "The colour with which to blend the sprite. c_white is to display it normally.",
        "alpha": "The alpha of the sprite (from 0 to 1 where 0 is transparent and 1 opaque)."
    },
    "draw_surface": {
        "desc": "With this function you can draw a surface at a given position within the room, with the top left corner of the image being drawn at the specified x/y position.\n\nNOTE: When working with surfaces there is the possibility that they can cease to exist at any time due to them being stored in texture memory. You should **ALWAYS** check that a surface exists using **surface_exists** before referencing them directly. For further information see Surfaces.",
        "id": "The unique id (index) of the surface to draw.",
        "x": "The x position of where to draw the surface.",
        "y": "The y position of where to draw the surface."
    },
    "draw_surface_ext": {
        "desc": "This function will draw the given surface as in the function **draw_surface** but with additional options to change the scale, blending, rotation and alpha of the surface being drawn. Changing these values does not modify the resource in any way (only how it is drawn).\n\nNOTE: When working with surfaces there is the possibility that they can cease to exist at any time due to them being stored in texture memory. You should **ALWAYS** check that a surface exists using **surface_exists** before referencing them directly. For further information see Surfaces.",
        "id": "The unique id (index) of the surface to draw.",
        "x": "The x position of where to draw the surface.",
        "y": "The y position of where to draw the surface.",
        "xscale": "The horizontal scale.",
        "yscale": "The vertical scale.",
        "rot": "The rotation or angle to draw the surface.",
        "colour": "The colour with which to blend the surface.",
        "alpha": "The alpha transparency for drawing the surface."
    },
    "draw_surface_general": {
        "desc": "This function combines the function **draw_surface_ext** with the function **draw_surface_part**, adding in some additional blending options so that each corner of the final surface part can be blended with an individual colour.\n\nNOTE: Gradient blending is not available for the HTML5 target unless WebGL is enabled.\n\nNOTE: When working with surfaces there is the possibility that they can cease to exist at any time due to them being stored in texture memory. You should ALWAYS check that a surface exists using **surface_exists** before referencing them directly. For further information see Surfaces.",
        "id": "The unique id (index) of the surface to draw.",
        "left": "The left position in the surface of the part to be drawn.",
        "top": "The top position in the surface of the part to be drawn.",
        "width": "The width of the part to be draw, from left.",
        "height": "The height of the part to be draw, from top.",
        "x": "The x position of where to draw the surface.",
        "y": "The y position of where to draw the surface.",
        "xscale": "The horizontal scaling to draw the surface with.",
        "yscale": "The vertical scaling to draw the surface with.",
        "rot": "The rotation or angle to draw the surface with.",
        "c1": "The colour of the top left corner of the surface.",
        "c2": "The colour of the top right corner of the surface.",
        "c3": "The colour of the bottom right corner of the surface.",
        "c4": "The colour of the bottom left corner of the surface.",
        "alpha": "The alpha transparency to draw the surface with.."
    },
    "draw_surface_part": {
        "desc": "With this function you can draw part of any surface at a given position within the room. As with **draw_surface** you can specify a surface, but you then need to specify the relative coordinates within the surface of an area to select for drawing. This means that a left position of 0 and a top position of 0 would be the top left corner of the surface and all further coordinates should be taken from that position.\n\nNOTE: When working with surfaces there is the possibility that they can cease to exist at any time due to them being stored in texture memory. You should ALWAYS check that a surface exists using surface_exists before referencing them directly. For further information see Surfaces.",
        "id": "The unique id (index) of the surface to draw.",
        "left": "The left position in the surface of the part to be drawn.",
        "top": "The top position in the surface of the part to be drawn.",
        "width": "The width of the part to be draw, from left.",
        "height": "The height of the part to be drawn, from top.",
        "x": "The x position of where to draw the surface.",
        "y": "The y position of where to draw the surface."
    },
    "draw_surface_part_ext": {
        "desc": "This function will draw a part of the chosen surface at the given position following the same rules as per **draw_surface_part**, only now you can scale the part, blend a colour with it, or change its alpha when drawing it to the screen (the same as when drawing a surface with **draw_surface_ext**).\n\nNOTE: When working with surfaces there is the possibility that they can cease to exist at any time due to them being stored in texture memory. You should ALWAYS check that a surface exists using **surface_exists** before referencing them directly. For further information see Surfaces.",
        "id": "The unique id (index) of the surface to draw.",
        "left": "The left position in the surface of the part to be drawn.",
        "top": "The top position in the surface of the part to be drawn.",
        "width": "The width of the part to be draw, from left.",
        "height": "The height of the part to be drawn, from top.",
        "x": "The x position of where to draw the surface.",
        "y": "The y position of where to draw the surface.",
        "xscale": "The horizontal scaling the part should be drawn with.",
        "yscale": "The vertical scaling the part should be drawn with.",
        "colour": "The colour blending the part should be drawn with.",
        "alpha": "The alpha transparency the part should be drawn with."
    },
    "draw_surface_stretched": {
        "desc": "This function simply takes a surface and stretches it over the given width and height so that it occupies the area. As with **draw_surface** you can specify a surface and then the x / y position in the room for the surface to be drawn at and finally a width and a height (which must be pixel values).\n\nNOTE: When working with surfaces there is the possibility that they can cease to exist at any time due to them being stored in texture memory. You should ALWAYS check that a surface exists using **surface_exists** before referencing them directly. For further information see Surfaces.",
        "id": "The unique id (index) of the surface to draw.",
        "x": "The x position of where to draw the surface.",
        "y": "The y position of where to draw the surface.",
        "w": "The width at which to draw the surface.",
        "h": "The height at which to draw the surface."
    },
    "draw_surface_stretched_ext": {
        "desc": "This function does exactly the same as the **draw_surface_stretched** function with the added ability to set the colour blending and alpha value for the surface when it is drawn (similar to the function **draw_surface_ext**).\n\nNOTE: When working with surfaces there is the possibility that they can cease to exist at any time due to them being stored in texture memory. You should ALWAYS check that a surface exists using **surface_exists** before referencing them directly. For further information see Surfaces.",
        "id": "The unique id (index) of the surface to draw.",
        "x": "The x position of where to draw the surface.",
        "y": "The y position of where to draw the surface.",
        "w": "The width at which to draw the surface.",
        "h": "The height at which to draw the surface.",
        "colour": "The colour with which to colour the surface.",
        "alpha": "The alpha with which to blend the surface."
    },
    "draw_surface_tiled": {
        "desc": "This function will take a surface and then repeatedly tile it across the whole room, starting from the coordinates that you give in the function.\n\nNOTE: When working with surfaces there is the possibility that they can cease to exist at any time due to them being stored in texture memory. You should ALWAYS check that a surface exists using **surface_exists** before referencing them directly. For further information see Surfaces.",
        "id": "The unique id (index) of the surface to draw.",
        "x": "The x position of where to draw the surface.",
        "y": "The y position of where to draw the surface."
    },
    "draw_surface_tiled_ext": {
        "desc": "This function will take a surface and then repeatedly tile it across the whole room, starting from the coordinates that you give in the function and with each tile scaled, colour blended and with the alpha that you define (these properties are the same as those used in **draw_surface_ext**).\n\nNOTE: When working with surfaces there is the possibility that they can cease to exist at any time due to them being stored in texture memory. You should ALWAYS check that a surface exists using **surface_exists** before referencing them directly. For further information see Surfaces.",
        "id": "The unique id (index) of the surface to draw.",
        "x": "The x coordinate of where to draw the surface.",
        "y": "The y coordinate of where to draw the surface.",
        "xscale": "The horizontal scaling of the surface.",
        "yscale": "The vertical scaling of the surface.",
        "colour": "The colour with which to blend the surface.",
        "alpha": "The alpha of the surface."
    },
    "draw_text": {
        "desc": "With this function you can draw any string at any position within the room (for drawing real numbers you should use the string function to convert them into text). To combine strings you can use + (see example below), you can also use # to add a line break to the string (should you need to display the # symbol, then you should precede it with a backslash like this \"this will draw a \\#\") and you can also draw quotations by using inverted commas (for example 'I said \"Hello\"...'). The colour of the text and the alpha are governed by the current base alpha and colour values as set by **draw_set_alpha** and **draw_set_colour**\n\nNOTE: The actual position of the text will be influenced by the alignment values set by **draw_set_halign** and **draw_set_valign**.",
        "x": "The x coordinate of the drawn string.",
        "y": "The y coordinate of the drawn string.",
        "string": "The string to draw."
    },
    "draw_texture_flush": {
        "desc": "With this function you can remove all textures from video memory, and they will then be reloaded on first use. This is the only effective way to manage video memory when you have multiple texture pages for a game, and you should flush the texture memory between levels on your game and organise the graphics using the texture group feature to ensure that the minimum number of textures are used.\n\nIt is worth noting that this function works as described on all target platforms except for Windows (YYC and standard), where by default all textures will always be loaded into memory on start-up. You can, however, change this behaviour from the Global Game Settings and have Windows behave the same as all other target platforms.\n\nNOTE: There is a performance hit as the texture is uploaded to texture memory on most devices, so the best idea is to do a dummy render of the required graphics at the start of a level to avoid any stalls. You would only need to render a single graphic from each texture page to ensure that texture is loaded, and you should be aware that texture groups can have more than one texture page which means that each load will cause a stall."
    },
    "draw_text_color": {
        "desc": "This function will **draw text** in a similar way to draw_text only now you can choose the colors to use for coloring the text as well as the alpha value, and these new values will be used instead of the base drawing color and alpha.\n\nNOTE: Gradient blending is not available for the HTML5 target unless WebGL is enabled, although you can still set the blending colors and it will blend the font with the first given color. However all blending in this way creates a duplicate font which is then stored in the cache and used when required, which is far from optimal and if you use multiple color changes it will slow down your games performance. You can set the font cache size to try and limit this should it be necessary using the function **font_set_cache_size**.",
        "x": "The x coordinate of the drawn string.",
        "y": "The y coordinate of the drawn string.",
        "string": "The string to draw.",
        "c1": "The color for the top left of the drawn text.",
        "c2": "The color for the top right of the drawn text.",
        "c3": "The color for the bottom right of the drawn text.",
        "c4": "The color for the bottom left of the drawn text.",
        "alpha": "The alpha for the text."
    },
    "draw_text_colour": {
        "desc": "This function will draw text in a similar way to **draw_text** only now you can choose the colours to use for colouring the text as well as the alpha value, and these new values will be used instead of the base drawing colour and alpha.\n\nNOTE: Gradient blending is not available for the HTML5 target unless WebGL is enabled, although you can still set the blending colours and it will blend the font with the first given colour. However all blending in this way creates a duplicate font which is then stored in the cache and used when required, which is far from optimal and if you use multiple colour changes it will slow down your games performance. You can set the font cache size to try and limit this should it be necessary using the function **font_set_cache_size**.",
        "x": "The x coordinate of the drawn string.",
        "y": "The y coordinate of the drawn string.",
        "string": "The string to draw.",
        "c1": "The colour for the top left of the drawn text.",
        "c2": "The colour for the top right of the drawn text.",
        "c3": "The colour for the bottom right of the drawn text.",
        "c4": "The colour for the bottom left of the drawn text.",
        "alpha": "The alpha for the text."
    },
    "draw_text_ext": {
        "desc": "This function will draw text in a similar way to **draw_text** only now you can set the space between each line of text - should the text occupy more than one line - and limit the width (in pixels) of the string per line so that should any line exceed this value, GameMaker: Studio will automatically split the text to the next line. A value of -1 for the line separation argument will default to a separation based on the height of the \"M\" character in the chosen font.",
        "x": "The x coordinate of the drawn string.",
        "y": "The y coordinate of the drawn string.",
        "string": "The string to draw.",
        "sep": "The distance in pixels between lines of text.",
        "w": "The maximum width in pixels of the string before a line break."
    },
    "draw_text_ext_color": {
        "desc": "This function is a combination of the base **draw_text** function with the **draw_text_ext** and **draw_text_color** functions, permitting you to define gradient colors for text as well as the line spacing and maximum width per line all together.\n\nNOTE: Gradient blending is not available for the HTML5 target unless WebGL is enabled, although you can still set the blending colors and it will blend the font with the first given color. However all blending in this way creates a duplicate font which is then stored in the cache and used when required, which is far from optimal and if you use multiple color changes it will slow down your games performance. You can set the font cache size to try and limit this should it be necessary using the function **font_set_cache_size**.",
        "x": "The x coordinate of the drawn string.",
        "y": "The y coordinate of the drawn string.",
        "string": "The string to draw.",
        "sep": "The distance in pixels between lines of text.",
        "w": "The maximum width in pixels of the string before a line break.",
        "c1": "The color for the top left of the drawn text.",
        "c2": "The color for the top right of the drawn text.",
        "c3": "The color for the bottom right of the drawn text.",
        "c4": "The color for the bottom left of the drawn text.",
        "alpha": "The alpha for the text."
    },
    "draw_text_ext_colour": {
        "desc": "This function is a combination of the base **draw_text** function with the **draw_text_ext** and **draw_text_colour** functions, permitting you to define gradient colours for text as well as the line spacing and maximum width per line all together.\n\nNOTE: Gradient blending is not available for the HTML5 target unless WebGL is enabled, although you can still set the blending colours and it will blend the font with the first given colour. However all blending in this way creates a duplicate font which is then stored in the cache and used when required, which is far from optimal and if you use multiple colour changes it will slow down your games performance. You can set the font cache size to try and limit this should it be necessary using the function **font_set_cache_size**.",
        "x": "The x coordinate of the drawn string.",
        "y": "The y coordinate of the drawn string.",
        "string": "The string to draw.",
        "sep": "The distance in pixels between lines of text.",
        "w": "The maximum width in pixels of the string before a line break.",
        "c1": "The colour for the top left of the drawn text.",
        "c2": "The colour for the top right of the drawn text.",
        "c3": "The colour for the bottom right of the drawn text.",
        "c4": "The colour for the bottom left of the drawn text.",
        "alpha": "The alpha for the text."
    },
    "draw_text_ext_transformed": {
        "desc": "This function is a combination of the base **draw_text** function with the **draw_text_ext** and **draw_text_transformed** functions, permitting you to scale and rotate text while maintaining a specific line spacing and maximum width per line. Note that the \"width\" argument is based on a scale of 1, so if the scale is different, this value should be changed proportionally. For example, if the base width for a line break is 300 and you set the scale to 2, then the text will appear wrong, over-running the given width. Instead you should have set the width to 150 to compensate the scaling.",
        "x": "The x coordinate of the drawn string.",
        "y": "The y coordinate of the drawn string.",
        "string": "The string to draw.",
        "sep": "The distance in pixels between lines of text.",
        "w": "The maximum width in pixels of the string before a line break.",
        "xscale": "The horizontal scale.",
        "yscale": "The vertical scale.",
        "angle": "The angle of the text."
    },
    "draw_text_ext_transformed_color": {
        "desc": "This function is a combination of the base **draw_text** function with the **draw_text_ext**, **draw_text_transformed** and **draw_text_color** functions. As such, this is the most general of all functions for drawing text and gives a large amount of flexibility when drawing. Note that the \"width\" argument is based on a scale of 1, so if the scale is different, this value should be changed proportionally. For example, if the base width for a line break is 300 and you set the scale to 2, then the text will appear wrong, over-running the given width. Instead you should have set the width to 150 to compensate the scaling.\n\nNOTE: Gradient blending is not available for the HTML5 target unless WebGL is enabled, although you can still set the blending colors and it will blend the font with the first given color. However all blending in this way creates a duplicate font which is then stored in the cache and used when required, which is far from optimal and if you use multiple color changes it will slow down your games performance. You can set the font cache size to try and limit this should it be necessary using the function **font_set_cache_size**.",
        "x": "The x coordinate of the drawn string.",
        "y": "The y coordinate of the drawn string.",
        "string": "The string to draw.",
        "sep": "The distance in pixels between lines of text.",
        "w": "The maximum width in pixels of the string before a line break.",
        "xscale": "The horizontal scale.",
        "yscale": "The vertical scale.",
        "angle": "The angle of the text.",
        "c1": "The color for the top left of the drawn text.",
        "c2": "The color for the top right of the drawn text.",
        "c3": "The color for the bottom right of the drawn text.",
        "c4": "The color for the bottom left of the drawn text.",
        "alpha": "The alpha for the text."
    },
    "draw_text_ext_transformed_colour": {
        "desc": "This function is a combination of the base **draw_text** function with the **draw_text_ext**, **draw_text_transformed** and **draw_text_colour** functions. As such, this is the most general of all functions for drawing text and gives a large amount of flexibility when drawing. Note that the \"width\" argument is based on a scale of 1, so if the scale is different, this value should be changed proportionally. For example, if the base width for a line break is 300 and you set the scale to 2, then the text will appear wrong, over-running the given width. Instead you should have set the width to 150 to compensate the scaling.\n\nNOTE: Gradient blending is not available for the HTML5 target unless WebGL is enabled, although you can still set the blending colours and it will blend the font with the first given colour. However all blending in this way creates a duplicate font which is then stored in the cache and used when required, which is far from optimal and if you use multiple colour changes it will slow down your games performance. You can set the font cache size to try and limit this should it be necessary using the function **font_set_cache_size**.",
        "x": "The x coordinate of the drawn string.",
        "y": "The y coordinate of the drawn string.",
        "string": "The string to draw.",
        "sep": "The distance in pixels between lines of text.",
        "w": "The maximum width in pixels of the string before a line break.",
        "xscale": "The horizontal scale.",
        "yscale": "The vertical scale.",
        "angle": "The angle of the text.",
        "c1": "The colour for the top left of the drawn text.",
        "c2": "The colour for the top right of the drawn text.",
        "c3": "The colour for the bottom right of the drawn text.",
        "c4": "The colour for the bottom left of the drawn text.",
        "alpha": "The alpha for the text."
    },
    "draw_text_transformed": {
        "desc": "This function will draw text in a similar way to **draw_text** only now you can choose to scale the text along the horizontal or vertical axis (effectively stretching or shrinking it) and also have GameMaker: Studio draw it at an angle (where 0 is normal and every degree over 0 rotates the text anti-clockwise).",
        "x": "The x coordinate of the drawn string.",
        "y": "The y coordinate of the drawn string.",
        "string": "The string to draw.",
        "xscale": "The horizontal scale (default 1).",
        "yscale": "The vertical scale(default 1).",
        "angle": "The angle of the text."
    },
    "draw_text_transformed_color": {
        "desc": "This function is a combination of the base **draw_text** function with the **draw_text_transformed** and **draw_text_color** functions, permitting you to scale and rotate text as well as color it with a gradient fill and change its alpha value, ignoring the base alpha and color settings for drawing.\n\nNOTE: Gradient blending is not available for the HTML5 target unless WebGL is enabled, although you can still set the blending colors and it will blend the font with the first given color. However all blending in this way creates a duplicate font which is then stored in the cache and used when required, which is far from optimal and if you use multiple color changes it will slow down your games performance. You can set the font cache size to try and limit this should it be necessary using the function **font_set_cache_size**.",
        "x": "The x coordinate of the drawn string.",
        "y": "The y coordinate of the drawn string.",
        "string": "The string to draw.",
        "xscale": "The horizontal scale.",
        "yscale": "The vertical scale.",
        "angle": "The angle of the text.",
        "c1": "The color for the top left of the drawn text.",
        "c2": "The color for the top right of the drawn text.",
        "c3": "The color for the bottom right of the drawn text.",
        "c4": "The color for the bottom left of the drawn text.",
        "alpha": "The alpha for the text."
    },
    "draw_text_transformed_colour": {
        "desc": "This function is a combination of the base **draw_text** function with the **draw_text_transformed** and **draw_text_colour** functions, permitting you to scale and rotate text as well as colour it with a gradient fill and change its alpha value, ignoring the base alpha and colour settings for drawing.\n\nNOTE: Gradient blending is not available for the HTML5 target unless WebGL is enabled, although you can still set the blending colours and it will blend the font with the first given colour. However all blending in this way creates a duplicate font which is then stored in the cache and used when required, which is far from optimal and if you use multiple colour changes it will slow down your games performance. You can set the font cache size to try and limit this should it be necessary using the function **font_set_cache_size**.",
        "x": "The x coordinate of the drawn string.",
        "y": "The y coordinate of the drawn string.",
        "string": "The string to draw.",
        "xscale": "The horizontal scale.",
        "yscale": "The vertical scale.",
        "angle": "The angle of the text.",
        "c1": "The colour for the top left of the drawn text.",
        "c2": "The colour for the top right of the drawn text.",
        "c3": "The colour for the bottom right of the drawn text.",
        "c4": "The colour for the bottom left of the drawn text.",
        "alpha": "The alpha for the text."
    },
    "draw_triangle": {
        "desc": "With this function you can draw either an outline of a triangle or a filled triangle.",
        "x1": "The x coordinate of the triangle's first corner.",
        "y1": "The y coordinate of the triangle's first corner.",
        "x2": "The x coordinate of the triangle's second corner.",
        "y2": "The y coordinate of the triangle's second corner.",
        "x3": "The x coordinate of the triangle's third corner.",
        "y3": "The y coordinate of the triangle's third corner.",
        "outline": "Whether the triangle is drawn filled (false) or as a one pixel wide outline (true)."
    },
    "draw_triangle_color": {
        "desc": "With this function you can draw either an outline of a triangle or a filled triangle. If it is filled you can define the individual colors for each corner point and if these colors are not the same, you will get a gradient effect from one to the other (the color settings will over-ride the base color set with the function **draw_set_color**).",
        "x1": "The x coordinate of the triangle's first corner.",
        "y1": "The y coordinate of the triangle's first corner.",
        "x2": "The x coordinate of the triangle's second corner.",
        "y2": "The y coordinate of the triangle's second corner.",
        "x3": "The x coordinate of the triangle's third corner.",
        "y3": "The y coordinate of the triangle's third corner.",
        "col1": "The color of the first corner.",
        "col2": "The color of the second corner.",
        "col3": "The color of the third corner.",
        "outline": "Whether the triangle is an outline (true) or filled in (false)."
    },
    "draw_triangle_colour": {
        "desc": "With this function you can draw either an outline of a triangle or a filled triangle. If it is filled you can define the individual colours for each corner point and if these colours are not the same, you will get a gradient effect from one to the other (the colour settings will over-ride the base colour set with the function **draw_set_colour**).",
        "x1": "The x coordinate of the triangle's first corner.",
        "y1": "The y coordinate of the triangle's first corner.",
        "x2": "The x coordinate of the triangle's second corner.",
        "y2": "The y coordinate of the triangle's second corner.",
        "x3": "The x coordinate of the triangle's third corner.",
        "y3": "The y coordinate of the triangle's third corner.",
        "col1": "The colour of the first corner.",
        "col2": "The colour of the second corner.",
        "col3": "The colour of the third corner.",
        "outline": "Whether the triangle is an outline (true) or filled in (false)."
    },
    "draw_vertex": {
        "desc": "This function defines the position of a vertex for a primitive. The final look of the primitive will depend on the primitive type chosen to draw and the order with which you add the vertexes to it. See **draw_primitive_begin** for more information. To end and draw the primitive you must call **draw_primitive_end**.",
        "x": "The x coordinate of the vertex.",
        "y": "The y coordinate of the vertex."
    },
    "draw_vertex_color": {
        "desc": "This function defines the position of a vertex for a primitive, with its own color and alpha setting. The final look of the primitive will depend on the primitive type chosen to draw and the order with which you add the vertexes to it (see **draw_primitive_begin** for more information) and the vertexes with different colors and alphas will blend smoothly from one to the other. To end and draw the primitive you must call **draw_primitive_end**.",
        "x": "The x coordinate of the vertex.",
        "y": "The y coordinate of the vertex.",
        "col": "The color to draw this vertex with.",
        "alpha": "The alpha to draw this vertex with (0-1)."
    },
    "draw_vertex_colour": {
        "desc": "This function defines the position of a vertex for a primitive, with its own colour and alpha setting. The final look of the primitive will depend on the primitive type chosen to draw and the order with which you add the vertexes to it (see **draw_primitive_begin** for more information) and the vertexes with different colours and alphas will blend smoothly from one to the other. To end and draw the primitive you must call **draw_primitive_end**.",
        "x": "The x coordinate of the vertex.",
        "y": "The y coordinate of the vertex.",
        "col": "The colour to draw this vertex with.",
        "alpha": "The alpha to draw this vertex with (0-1)."
    },
    "draw_vertex_texture": {
        "desc": "This function defines the position of a textured vertex for a primitive. The final look of the primitive will depend on the primitive type chosen to draw (See **draw_primitive_begin** for more information), the order with which you add the vertexes to it and the position of the start point you set for the texture. To end and draw the primitive you must call **draw_primitive_end**.",
        "x": "The x coordinate of the vertex.",
        "y": "The y coordinate of the vertex.",
        "xtex": "The width of the texture sample to use.",
        "ytex": "The height of the texture sample to use."
    },
    "draw_vertex_texture_color": {
        "desc": "This function defines the position of a textured vertex for a primitive. The final look of the primitive will depend on the primitive type chosen to draw (See **draw_primitive_begin** for more information), the order with which you add the vertices to it, the position of the start and end points that you give for the texture sample and the color and alpha values that you have set. To maintain the texture appearance while changing only the alpha, a value of -1 (or *c_white*) may be used for the color argument. To end and draw the primitive you must call **draw_primitive_end**.\n\nNOTE: For a texture to repeat it must be a power of two in size, ie: 32x32, 128x128, etc...",
        "x": "The x coordinate of the vertex.",
        "y": "The y coordinate of the vertex.",
        "xtex": "The x coordinate within the texture.",
        "ytex": "The y coordinate within the texture.",
        "col": "The color to blend with the texture at this vertex (-1 or c_white for no blending).",
        "alpha": "The alpha to draw this vertex with (0-1)."
    },
    "draw_vertex_texture_colour": {
        "desc": "This function defines the position of a textured vertex for a primitive. The final look of the primitive will depend on the primitive type chosen to draw (See **draw_primitive_begin** for more information), the order with which you add the vertices to it, the position of the start and end points that you give for the texture sample and the colour and alpha values that you have set. To maintain the texture appearance while changing only the alpha, a value of -1 (or *c_white*) may be used for the colour argument. To end and draw the primitive you must call **draw_primitive_end**.\n\nNOTE: For a texture to repeat it must be a power of two in size, ie: 32x32, 128x128, etc...",
        "x": "The x coordinate of the vertex.",
        "y": "The y coordinate of the vertex.",
        "xtex": "The x coordinate within the texture.",
        "ytex": "The y coordinate within the texture.",
        "col": "The colour to blend with the texture at this vertex (-1 or c_white for no blending).",
        "alpha": "The alpha to draw this vertex with (0-1)."
    },
    "dsin": {
        "desc": "In a right angled triangle dsin(val) = Opposite / Hypotenuse where \"val\" is one of the three angles.",
        "degree_angle": "The angle (in degrees) to return the sine of."
    },
    "ds_exists": {
        "desc": "With this function you can check to see if a data structure of the given type exists. You supply the \"index\" value (as held in a variable) and the ds \"type\", which can be any of the constants listed below, and the function will return true if the data structure exists and false otherwise.![](https://gmlsupport.liaronce.win/images-in-intellisense/9.png)",
        "index": "The variable index to check for the data structure",
        "type": "The type of data structure to check for (see the list of constants below)"
    },
    "ds_grid_add": {
        "desc": "This function can be used to add a given value (real or string) to the value of the given cell within the grid. The value to be added must be the same type as that held within the grid cell, ie: you cannot add a string to a real or vice-versa, and for strings this corresponds to concatenation.",
        "index": "The index of the grid.",
        "x": "The x position of the cell in the grid.",
        "y": "The y position of the cell in the grid.",
        "val": "The value to add to the cell."
    },
    "ds_grid_add_disk": {
        "desc": "This function can be used to add a given value (real or string) to all the values of the cells found within the defined disk area of a grid. The value to be added must be of the same type as that held within the grid cells, ie: you cannot add a string to a real or vice-versa, and for strings this corresponds to concatenation.",
        "index": "The index of the grid.",
        "xm": "The x position of the disk on the grid.",
        "ym": "The y position of the disk on the grid.",
        "r": "The radius of the disk on the grid.",
        "val": "The value to add to the cells within the disk."
    },
    "ds_grid_add_grid_region": {
        "desc": "This function can be used to add all the values of all the cells found within the source area of a grid to the values within the destination grid, as illustrated below: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_add_grid_region.png)\n\nNOTE: You can also use this function on the same grid to add values from one region of the grid to those stored in another (see code example below).",
        "index": "The index of the destination grid.",
        "source": "The index of the source grid.",
        "x1": "The left position of the region of cells to copy from the source grid.",
        "y1": "The top position of the region of cells to copy from the source grid.",
        "x2": "The right position of the region of cells to copy from the source grid.",
        "y2": "The bottom position of the region of cells to copy from the source grid.",
        "xpos": "The x position on the destination grid to add the source region to.",
        "ypos": "The y position on the destination grid to add the source region to."
    },
    "ds_grid_add_region": {
        "desc": "This function can be used to add a given value (real or string) to all the values of the cells found within the defined area of a grid. The value to be added must be of the same type as that held within the grid cells, ie: you cannot add a string to a real or vice-versa, and for strings this corresponds to concatenation.",
        "index": "The index of the grid.",
        "x1": "The x position of the left of the region in the grid.",
        "y1": "The y position of the top of the region in the grid.",
        "x2": "The x position of the right of the region in the grid.",
        "y2": "The y position of the bottom of the region in the grid.",
        "val": "The value to add to the region cells."
    },
    "ds_grid_clear": {
        "desc": "This function can be used to clear a given ds_grid to a specific value. All cells within the grid will then contain this value, which can be a real number or a string. The image below illustrates how this works: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_clear.png)",
        "index": "This index of the grid to clear.",
        "val": "The new value for all grid cells."
    },
    "ds_grid_copy": {
        "desc": "With this function you can copy the contents of one grid into another one. Both grids must have been created previously using the **ds_grid_create** function.",
        "index": "This index of the grid to copy to.",
        "source": "This index of the grid to copy from."
    },
    "ds_grid_create": {
        "desc": "With this function you can create a new ds_grid data structure of the specified cell width and height. This function returns an id which must be used in all further functions that deal with this ds_grid.",
        "w": "The width of the grid to be created.",
        "h": "The height of the grid to be created."
    },
    "ds_grid_destroy": {
        "desc": "This function will remove the given grid data-structure from memory, freeing up the resources it was using and removing all values that it contained. This function should always be used when you are finished using the ds_grid to prevent memory leaks that can slow down and crash your game.",
        "index": "This index of the grid to destroy."
    },
    "ds_grid_get": {
        "desc": "This function can be used to get the value (either a real number or a string) from any cell within the given ds_grid. If you pass invalid grid coordinates to the function, then the value returned will be 0.",
        "index": "The index of the grid.",
        "x": "The x position of the cell you want to find the value of.",
        "y": "The y position of the cell you want to find the value of."
    },
    "ds_grid_get_disk_max": {
        "desc": "This function can be used to find the maximum value for all the cells found within the defined disk area of a grid, as shown in the image below: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_get_disk_max.png)",
        "index": "The index of the grid.",
        "xm": "The x position of the disk center in the grid.",
        "ym": "The y position of the disk center in the grid.",
        "r": "The radius of the disk in the grid."
    },
    "ds_grid_get_disk_mean": {
        "desc": "This function can be used to find the mean value for all the cells found within the defined disk area of a grid (all cell values are added together and then divided by the total number of cells that make up the disk), as shown in the image below: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_get_disk_mean.png)",
        "index": "The index of the grid.",
        "xm": "The x position of the disk on the grid.",
        "ym": "The y position of the disk on the grid.",
        "r": "The radius of the disk on the grid."
    },
    "ds_grid_get_disk_min": {
        "desc": "This function can be used to find the minimum value for all the cells found within the defined disk area of a grid, as shown in the image below: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_get_disk_min.png)",
        "index": "The index of the grid.",
        "xm": "The x position of the disk on the grid.",
        "ym": "The y position of the disk on the grid.",
        "r": "The radius of the disk on the grid."
    },
    "ds_grid_get_disk_sum": {
        "desc": "This function can be used to add all the values all the cells found within the defined disk area of a grid together, as shown in the image below: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_get_disk_sum.png)",
        "index": "The index of the grid.",
        "xm": "The x position of the disk on the grid.",
        "ym": "The y position of the disk on the grid.",
        "r": "The radius of the disk on the grid."
    },
    "ds_grid_get_max": {
        "desc": "This function can be used to find the maximum value for all the cells found within the defined region of a grid, as shown in the image below: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_get_max.png)",
        "index": "The index of the grid.",
        "x1": "The left cell column of the region.",
        "y1": "The top cell row of the region.",
        "x2": "The right cell column of the region.",
        "y2": "The bottom cell row of the region."
    },
    "ds_grid_get_mean": {
        "desc": "This function can be used to find the mean value for all the cells found within the defined region of a grid (all cell values are added together and then divided by the total number of cells that make the region), as shown in the image below: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_get_mean.png)",
        "index": "The index of the grid.",
        "x1": "The left cell column of the region.",
        "y1": "The top cell row of the region.",
        "x2": "The right cell column of the region.",
        "y2": "The bottom cell row of the region."
    },
    "ds_grid_get_min": {
        "desc": "This function can be used to find the minimum value for all the cells found within the defined region of a grid, as shown in the image below: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_get_min.png)",
        "index": "The index of the grid.",
        "x1": "The left cell column of the region.",
        "y1": "The top cell row of the region.",
        "x2": "The right cell column of the region.",
        "y2": "The bottom cell row of the region."
    },
    "ds_grid_get_sum": {
        "desc": "This function can be used to add all the values all the cells found within the defined region of a grid together, as shown in the image below: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_get_sum.png)",
        "index": "The index of the grid.",
        "x1": "The left cell column of the region.",
        "y1": "The top cell row of the region.",
        "x2": "The right cell column of the region.",
        "y2": "The bottom cell row of the region."
    },
    "ds_grid_height": {
        "desc": "This function will return the height of the given grid. This value is the number of cells the grid has along the y-axis and is always an integer, as shown in the image below: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_height.png)",
        "index": "This index of the grid to find the height of."
    },
    "ds_grid_multiply": {
        "desc": "This function will multiply the value of a the given grid cell by the specified amount.\n\nNOTE: This function will only work with real numbers, not strings.",
        "index": "The index of the grid.",
        "x": "The x position of the cell in the grid.",
        "y": "The y position of the cell in the grid.",
        "val": "The value to multiply with the cell."
    },
    "ds_grid_multiply_disk": {
        "desc": "This function will take all the values in a given disc-shaped region of the ds_grid, and multiply each one by the given amount.\n\nNOTE: This function will only work with real numbers, not strings.",
        "index": "The index of the grid.",
        "xm": "The x position of the disk on the grid.",
        "ym": "The y position of the disk on the grid.",
        "r": "The radius of the disk on the grid.",
        "val": "The value to multiply the cells within the disk with."
    },
    "ds_grid_multiply_grid_region": {
        "desc": "With this function you can define an area within a given ds_grid, then take those values and multiply them with those found in a separate region of either the same ds_grid, or another one (which has been previously created). The original region will remain unchanged, while the region that they have been multiplied with will now store the new values for each cell.",
        "index": "The index of the destination grid.",
        "source": "The index of the source grid.",
        "x1": "The left position of the region of cells to copy from the source grid.",
        "y1": "The top position of the region of cells to copy from the source grid.",
        "x2": "The right position of the region of cells to copy from the source grid.",
        "y2": "The bottom position of the region of cells to copy from the source grid.",
        "xpos": "The x position on the destination grid to multiply the source region with.",
        "ypos": "The y position on the destination grid to multiply the source region with."
    },
    "ds_grid_multiply_region": {
        "desc": "With this function you can specify a region of the grid in which to multiply each cell value by a given amount.\n\nNOTE: This function will only work with real numbers, not strings.",
        "index": "The index of the grid.",
        "x1": "The x position of the left of the region in the grid.",
        "y1": "The y position of the top of the region in the grid.",
        "x2": "The x position of the right of the region in the grid.",
        "y2": "The y position of the bottom of the region in the grid.",
        "val": "The value to multiply with the region cells."
    },
    "ds_grid_read": {
        "desc": "This function can be used to convert a string which has been created previously by the function **ds_grid_write()** back into a ds_grid. The ds_grid must have been created previously (see the example below). Note that if the data structure was created with previous versions of GameMaker you should add the optional argument \"legacy\", setting it to true as the string format has changed with this version.",
        "index": "The index of the grid to read.",
        "str": "The string to read into the ds_grid.",
        "legacy": "(optional) Can be either true or false or omitted completely."
    },
    "ds_grid_resize": {
        "desc": "With this function you can resize the given ds_grid to have a different width and/or height. If the grid size is larger than the current grid, the new cells will have a base value of 0, and if the size is smaller then the values held in the cells that are no longer within the new size will be lost. All other cells will be left untouched.",
        "index": "This index of the grid to resize.",
        "w": "The new width of the grid.",
        "h": "The new height of the grid."
    },
    "ds_grid_set": {
        "desc": "This function can be used to set a given cell within the given ds_grid to any value, which can be a real number or a string. The image below illustrates this: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_set.png)",
        "index": "This index of the grid.",
        "x": "The x position of the cell to set.",
        "y": "The y position of the cell to set.",
        "val": "The value with which to set the cell."
    },
    "ds_grid_set_disk": {
        "desc": "With this function you can set a circular region of a grid to a certain value. You need to supply a starting grid cell (as an x and y axis coordinate) as well as the radius of the disk to set and the value that you wish to set the disk too, as shown by the illustration below: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_set_disk.png)",
        "index": "The index of the grid.",
        "xm": "The x position of the disk on the grid.",
        "ym": "The y position of the disk on the grid.",
        "r": "The radius of the disk on the grid.",
        "val": "The value to set with the cells within the disk."
    },
    "ds_grid_set_grid_region": {
        "desc": "This function can be used to copy the contents of a rectangular area of grid cells from one (previously defined) ds_grid to another, or it can be used to copy a region from within the same grid. The following images illustrate both ways that this function can be used: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_set_grid_region.png)",
        "index": "The index of the destination grid.",
        "source": "The index of the source grid.",
        "x1": "The left position of the region of cells to copy from the source grid.",
        "y1": "The top position of the region of cells to copy from the source grid.",
        "x2": "The right position of the region of cells to copy from the source grid.",
        "y2": "The bottom position of the region of cells to copy from the source grid.",
        "xpos": "The x position on the destination grid to copy the source region to.",
        "ypos": "The y position on the destination grid to copy the source region to."
    },
    "ds_grid_set_region": {
        "desc": "This function can be used to set a rectangular region of a given grid to a specified value (which can be either a real or a string) as illustrated by the image shown below: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_set_region.png)",
        "index": "The index of the grid.",
        "x1": "The x position of the left of the region in the grid.",
        "y1": "The y position of the top of the region in the grid.",
        "x2": "The x position of the right of the region in the grid.",
        "y2": "The y position of the bottom of the region in the grid.",
        "val": "The value to set the region cells to."
    },
    "ds_grid_shuffle": {
        "desc": "This function can be used to randomize the positions of all values in all cells within a grid.\n\nNOTE: This function will shuffle the grid cells to the same positions every time the game is run afresh due to the fact that GameMaker: Studio generates the same initial random seed every time to make debugging code a far easier task. To avoid this behaviour use **randomize** at the start of your game. This is only true when testing and debugging the game, as the final executable package will not show this behaviour and will be random every play.",
        "index": "The index of the grid to shuffle."
    },
    "ds_grid_sort": {
        "desc": "This function can be used to sort a ds_grid based on the values from a given column (much as you would sort files by date, size etc... in the Windows Explorer). The following image shows an example: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_sort.png)",
        "index": "The index of the grid to sort.",
        "column": "The column to use for sorting the rows",
        "ascending": "Whether to sort lowest to highest (true), or highest to lowest (false)."
    },
    "ds_grid_value_disk_exists": {
        "desc": "With this function you can check to see if a specific value (real or string) is present within a circular area of a given ds_grid. If it is present the function will return true otherwise it will return false.",
        "index": "The index of the grid.",
        "xm": "The x position of the disk on the grid.",
        "ym": "The y position of the disk on the grid.",
        "r": "The radius of the disk on the grid.",
        "val": "The value to find."
    },
    "ds_grid_value_disk_x": {
        "desc": "With this function you can get the x coordinate (within the given grid disc-shaped region) of the value being searched for. Be aware that if the value being searched for does not exists, the function will return 0, so it is a good idea to check if the values exists first with **ds_grid_value_disk_exists** then run this function (along with the **ds_grid_value_disk_y** function) to get the exact position within disc being searched.",
        "index": "The index of the grid.",
        "xm": "The x position of the disk on the grid.",
        "ym": "The y position of the disk on the grid.",
        "r": "The radius of the disk on the grid.",
        "val": "The value to find."
    },
    "ds_grid_value_disk_y": {
        "desc": "With this function you can get the y coordinate (within the given grid disc-shaped region) of the value being searched for. Be aware that if the value being searched for does not exists, the function will return 0, so it is a good idea to check if the values exists first with **ds_grid_value_disk_exists** then run this function (along with the **ds_grid_value_disk_x** function) to get the exact position within disc being searched.",
        "index": "The index of the grid.",
        "xm": "The x position of the disk on the grid.",
        "ym": "The y position of the disk on the grid.",
        "r": "The radius of the disk on the grid.",
        "val": "The value to find."
    },
    "ds_grid_value_exists": {
        "desc": "With this function you can check to see if a specific value (real or string) is present within a rectangular area of a given ds_grid. If it is present the function will return true otherwise it will return false.",
        "index": "he index of the grid.",
        "x1": "The x position of the left of the region in the grid.",
        "y1": "The y position of the top of the region in the grid.",
        "x2": "The x position of the right of the region in the grid.",
        "y2": "The y position of the bottom of the region in the grid.",
        "val": "The value to find."
    },
    "ds_grid_value_x": {
        "desc": "With this function you can get the x coordinate (within the given rectangular grid region) of the value being searched for. Be aware that if the value being searched for does not exists, the function will return 0, so it is a good idea to check if the values exists first with **ds_grid_value_exists** then run this function (along with the **ds_grid_value_y** function) to get the exact position within region being searched.",
        "index": "The index of the grid.",
        "x1": "The x position of the left of the region in the grid.",
        "y1": "The y position of the top of the region in the grid.",
        "x2": "The x position of the right of the region in the grid.",
        "y2": "The y position of the bottom of the region in the grid.",
        "val": "The value to find."
    },
    "ds_grid_value_y": {
        "desc": "With this function you can get the y coordinate (within the given rectangular grid region) of the value being searched for. Be aware that if the value being searched for does not exists, the function will return 0, so it is a good idea to check if the values exists first with **ds_grid_value_exists** then run this function (along with the **ds_grid_value_x** function) to get the exact position within region being searched.",
        "index": "The index of the grid.",
        "x1": "The x position of the left of the region in the grid.",
        "y1": "The y position of the top of the region in the grid.",
        "x2": "The x position of the right of the region in the grid.",
        "y2": "The y position of the bottom of the region in the grid.",
        "val": "The value to find."
    },
    "ds_grid_width": {
        "desc": "This function will return the width of the given grid. This value is the number of cells the grid has along the x-axis and is always an integer, as shown in the image below: ![](https://docs.yoyogames.com/source/dadiospice/002_reference/data%20structures/ds%20grids/ds_grid_width.png)",
        "index": "This index of the grid to find the width of."
    },
    "ds_grid_write": {
        "desc": "This function can be used to convert the given ds_grid into a string, which can then be stored in an external file (for example). You can read the returned string from this function back into a ds_grid using the function **ds_grid_read()**.\n\nNOTE: The returned string is not a human readable string, but rather a dump of the contents of the data-structure",
        "index": "The index of the grid to write."
    },
    "ds_list_add": {
        "desc": "This function can be used to add a new value (real or string) to the list, which will be added on at the end. The function can take a further 14 optional arguments (making a total of 15 possible additions), permitting you to add multiple values consecutively to the list in a single call.",
        "id": "The id of the list to add to.",
        "value": "The value to add to the list.",
        "more": "Optional values to be added to the list."
    },
    "ds_list_clear": {
        "desc": "With this function you can clear all data from the given list data-structure. This does NOT destroy the data-structure (for that you should use **ds_list_destroy**) it only wipes all data from it and returns an empty list.",
        "id": "The id of the data structure to clear."
    },
    "ds_list_copy": {
        "desc": "With this function you can copy the contents of one list into another. Both lists must have been created previously and if the list being copied to already has information within it, this list will be cleared first. The end result is two independent lists which contain the same information.",
        "id": "The id of the list being copied to.",
        "source": "The id of the list to be copied from."
    },
    "ds_list_create": {
        "desc": "This function will create a new list data-structure and return the index value. This value should be stored in a variable and used in all further function calls relating to the list."
    },
    "ds_list_delete": {
        "desc": "With this function you can remove the value stored at a specific position within the list.",
        "id": "The id of the list to change.",
        "pos": "Where in the list to delete the value."
    },
    "ds_list_destroy": {
        "desc": "This function will remove the given list data-structure from memory, freeing up the resources it was using and removing all values that it contained. This function should always be used when you are finished using the ds_list to prevent memory leaks that can slow down and crash your game.",
        "id": "The id of the data structure to remove."
    },
    "ds_list_empty": {
        "desc": "With this function you can check the given ds_list to see if it is empty (returns true) or not (returns false).",
        "id": "The id of the data structure to check."
    },
    "ds_list_find_index": {
        "desc": "With this function you can check the given list for a value and the position within the list for that value will be returned. Note that if there are more than one entries in the list with the same value, the position of any one of them may be returned, and that if the value does not exist, then -1 will be returned. Note that the value can be an array, which you can check with the function **is_array**.",
        "id": "The id of the list to use.",
        "value": "The value to find."
    },
    "ds_list_find_value": {
        "desc": "With this function you can check the given list position and the value held within the list for that position will be returned.\n\nNOTE: If you give a position that is outside of the given list size (ie: position 11 in a 10 value list) then the function will return <undefined>. You should always check this using the **is_undefined()** function.",
        "id": "The id of the list to use.",
        "pos": "The position to look at, where 0 corresponds to the very beginning of the list and the final position is ds_list_size(id)-1."
    },
    "ds_list_insert": {
        "desc": "This function will add the given value into the list at the given position. if the list contains more values after the given position, their position will be shifted up one to make room making the list larger by one.",
        "id": "The id of the list to add to.",
        "pos": "The position to add the value, where 0 corresponds to the very beginning of the list and the final position is ds_list_size(id)-1.",
        "value": "The value to add to the list."
    },
    "ds_list_mark_as_list": {
        "desc": "This function will \"mark\" (or \"flag\") a given position within a previously created ds_list as holding another ds_list. This functionality is designed only for use when encoding JSON strings (which you can create using **json_encode**) and the complimentary ds map functions.\n\nNOTE: Once a ds_list has had a value within it flagged as another list or map, destroying the list will also destroy the marked lists and maps too. This means that you do not have to manually go through the list contents and destroy the marked data structures individually before destroying the \"parent\" list.",
        "id": "The id of the list to mark.",
        "pos": "The position within the list to mark."
    },
    "ds_list_mark_as_map": {
        "desc": "This function will \"mark\" (or \"flag\") a given position within a previously created ds_list as holding a previously created ds_map. This functionality is designed only for use when encoding JSON strings (which you can create using **json_encode**) and the complimentary ds map functions.\n\nNOTE: Once a ds_list has had a value within it flagged as another list or map, destroying the list will also destroy the marked lists and maps too. This means that you do not have to manually go through the list contents and destroy the marked data structures individually before destroying the \"parent\" list.",
        "id": "The id of the list to mark.",
        "pos": "The position within the list to mark."
    },
    "ds_list_read": {
        "desc": "With this function you can recreate a saved ds_list (one that has previously been written as a string using **ds_list_write**). You must first create a new ds_list to read the string into, and if the ds_list already exists and has information stored in it, then this will be cleared before reading. This function is of vital importance when creating save/load mechanisms for your game.Note that if the data structure was created with previous versions of GameMaker you should add the optional argument \"legacy\", setting it to true as the string format has changed with this version.",
        "id": "The id of the data structure to read into.",
        "str": "The string to read from.",
        "legacy": "(optional)Can be either true or false or omitted completely."
    },
    "ds_list_replace": {
        "desc": "This function will replace the value at the given position for another one.",
        "id": "The id of the list to change.",
        "pos": "The position to replace the value, where 0 corresponds to the very beginning of the list and the final position is ds_list_size(id)-1.",
        "value": "The new value to replace the given value with."
    },
    "ds_list_shuffle": {
        "desc": "With this function you can shuffle a list, which will re-order all the component values into random positions from those in which they were originally added to the list.\n\nNOTE: This function will shuffle the list items to the same positions every time the game is run afresh due to the fact that GameMaker: Studio generates the same initial random seed every time to make debugging code a far easier task. To avoid this behaviour use **randomize** at the start of your game. This is only true when testing and debugging the game, as the final executable package will not show this behaviour and will be random every play.",
        "id": "The id of the list to shuffle."
    },
    "ds_list_size": {
        "desc": "This function will return the \"size\" of the list, ie: the number of items that have been added into it.",
        "id": "The id of the data structure to check."
    },
    "ds_list_sort": {
        "desc": "With this function you can sort all the values within a list, either in ascending or descending order. If the list contains strings, these will be sorted alphabetically, based on the english 26 letter alphabet.",
        "id": "The id of the list to sort.",
        "ascending": "Whether the values should be ascending (true) or descending (false) order."
    },
    "ds_list_write": {
        "desc": "This function returns a string which can then be stored or transferred to another data structure using the **ds_list_read** function.\n\nNOTE: The returned string is not a human readable string, but rather a dump of the contents of the data-structure",
        "id": "The id of the data structure to write."
    },
    "ds_map_add": {
        "desc": "This function should be used to add sets of key/value pairs into the specified ds_map. You can check this function to see if it was successful or not, as it may fail if there already exists the same key in the ds_map or you specify a non-existent ds_map as the id of the map to add to. Both keys and values can be made up of either integers or strings, so all of the following are acceptable:\n\n```ds_map_add(map, 5, 1);\nds_map_add(map, \"level\", 100);\nds_map_add(map, 89, \"hello world\");\nds_map_add(map, \"fish\", \"good\");```\n\nYou can also add to a map using the accessor \"?\", as shown below:```map[? 5] = 1;\nmap[? \"level\"] = 100;\nmap[? 89] = \"hello world\";\nmap[? \"fish\"] = \"good\";```\n\nNOTE: Unlike other data structures in GameMaker: Studio this key will not go to the start (nor the end) of the ds_map, but rather it will just go into the ds_map **somewhere**.",
        "id": "The id of the map to add to.",
        "key": "The key of the value to add.",
        "value": "The value to add to the map."
    },
    "ds_map_add_list": {
        "desc": "With this function you can assign a (previously created) ds_list to a key within the given ds_map. This function is designed for creating JSON compatible maps which you would then encode using **json_encode** and should only be used in conjunction with that functionality. If a ds_map has a list added in this way, destroying the parent map will also destroy the contained lists and free their memory.",
        "id": "The id of the map to use.",
        "key": "The key for the added list.",
        "value": "The id of the list to add."
    },
    "ds_map_add_map": {
        "desc": "With this function you can assign a (previously created) ds_map to a key within the given ds_map. This function is designed for creating JSON compatible maps which you would then encode using **json_encode** and should only be used in conjunction with that functionality. If a ds_map has another map added in this way, then destroying the parent map will also destroy the contained maps and free their memory.",
        "id": "The id of the map to use.",
        "key": "The key for the added map.",
        "value": "The id of the map to add."
    },
    "ds_map_clear": {
        "desc": "This function will clear the (previously created) ds_map of all key/value pairs, but it will not delete the ds_map itself from memory. For that you should use the function **ds_map_destroy**.",
        "id": "The id of the data structure to clear."
    },
    "ds_map_copy": {
        "desc": "You can use this function to copy the contents of one map into another one that you have previously created using ds_map_create(). If the ds_map that is being copied to is not empty, then this function will clear it first before copying. The original ds_map remains un-changed by this process.",
        "id": "The id of the map you are copying **to</>**",
        "source": "The id of the map you are copying **from**"
    },
    "ds_map_create": {
        "desc": "This function is used to create a new, empty, ds_map and will return its id which is then used to access the data structure in all other ds_map functions."
    },
    "ds_map_delete": {
        "desc": "With this function you can remove any given key (and its corresponding value) from the given, previously created, ds_map.",
        "id": "The id of the map to change.",
        "key": "The key (along with its associated value) to delete."
    },
    "ds_map_destroy": {
        "desc": "Ds_maps take up space in memory, which is allocated to them when they are created. This means that you also need to free this memory when the ds_map is not needed to prevent errors, memory leaks and loss of performance when running your game. This function does just that.",
        "id": "The id of the map to destroy."
    },
    "ds_map_empty": {
        "desc": "This function will simply return false if the specified (previously created) ds_map contains any key/value pairs, or true if it does not.",
        "id": "The id of the data structure to check."
    },
    "ds_map_exists": {
        "desc": "This function will return true if the specified key exists in the (previously created) ds_map, and false if it does not.",
        "id": "The id of the data structure to check",
        "key": "The key to check for"
    },
    "ds_map_find_first": {
        "desc": "This function returns the first key stored in the ds_map. **This is not the first key in the order you added them!** Ds_maps are not stored in a linear form, for that use ds_lists, so all this does is find the first key as stored by the computer. This can be useful if your have to iterate through the ds_map looking for something, but should be avoided if possible as it can be slow.",
        "id": "The id of the map to use."
    },
    "ds_map_find_last": {
        "desc": "This function returns the last key stored in the ds_map. **This is not the last key in the order that you have added them!** Ds_maps are not stored in a linear form, for that use ds_lists, so all this does is find the last key as stored by the computer. This can be useful if your have to iterate through the ds_map looking for something, but should be avoided if possible as it can be slow.",
        "id": "The id of the map to use."
    },
    "ds_map_find_next": {
        "desc": "This function returns the next key stored in the ds_map after the one specified in the function. This can be useful if your have to iterate through the ds_map looking for something, but should be avoided if possible as it can be slow. If no such key exists then the function will return <undefined>. You should always check this using the **is_undefined()** function.",
        "id": "The id of the map to use.",
        "key": "The key to find the next one to."
    },
    "ds_map_find_previous": {
        "desc": "This function returns the next key stored in the ds_map after the one specified in the function. This can be useful if your have to iterate through the ds_map looking for something, but should be avoided if possible as it can be slow. If no such key exists then the function will return <undefined>. You should always check this using the **is_undefined()** function.",
        "id": "The id of the map to use.",
        "key": "The key to find the previous one to."
    },
    "ds_map_find_value": {
        "desc": "With this function you can get the value from a specified key. The input values of the function are the (previously created) ds_map to use and the key to check for.\n\nNOTE: If no such key exists then the function will return <undefined>. You should always check this using the **is_undefined()** function.",
        "id": "The id of the map to use.",
        "key": "The key to find."
    },
    "ds_map_read": {
        "desc": "This function will take a string that has previously been created by the function **ds_map_write** and then read it into a previously created ds_map. If the map that the string is being read into contains any key/value pairs, these will be cleared first before the saved map is re-constructed. Note that if the data structure was created with previous versions of GameMaker you should add the optional argument \"legacy\", setting it to true as the string format has changed with this version.",
        "id": "The id of the data structure to read the string into",
        "str": "The string to read",
        "legacy": "(optional)Can be either true or false or omitted completely."
    },
    "ds_map_replace": {
        "desc": "With this function you can change the value for the given key within the (previously created) ds_map. Please note that if the key to be replaced does not exists, it is created and the given value assigned to it.",
        "id": "The id of the map to change.",
        "key": "The key with the value that should be replaced by the new one",
        "value": "The new value to replace the given value with"
    },
    "ds_map_replace_list": {
        "desc": "With this function you can replace a *ds_list* that has been stored in the given \"key\" with another list that has been created previously. This function is designed for creating JSON compatible maps which you would then encode using **json_encode** and should only be used in conjunction with that functionality.",
        "id": "The id of the map to use.",
        "key": "The key to replace.",
        "value": "The id of the ds_list to use to replace the one previously stored in the given key."
    },
    "ds_map_replace_map": {
        "desc": "With this function you can replace a ds_map that has been stored in the given \"key\" with another map that has been created previously. This function is designed for creating JSON compatible maps which you would then encode using **json_encode** and should only be used in conjunction with that functionality.",
        "id": "The id of the ds_map to use.",
        "key": "The key to replace.",
        "value": "The id of the ds_map to use to replace the one previously stored in the given key."
    },
    "ds_map_secure_load": {
        "desc": "This function will load a previously saved ds_map from the given file. This file must have been previously created using the **ds_map_secure_save()** function, and, when loaded, the function will return the index of the ds_map that has been created from the loaded data. This ds_map index should be stored in a variable and used for all further function calls to this map.",
        "filename": "The name of the file to load the map data from."
    },
    "ds_map_secure_load_buffer": {
        "desc": "This function will load a secure saved DS map from a buffer. You must previously have loaded the buffer into memory (using **buffer_load**) and then passing that into this function will return a DS map populated with the contents of the buffer. Note that the buffer must have been created using the function **ds_map_secure_save_buffer** for this to work correctly.",
        "buffer": "The buffer ID of the buffer to load the map data from."
    },
    "ds_map_secure_save": {
        "desc": "This function will save the contents of the given ds_map to a file. The file itself can have almost any extension (for example, *.dat, *.json, *.bin, etc...) and will be encrypted and stored to a safe location on the target platform. In this way you can store sensitive information, like in app purchase details or passwords, locally in a secure way. you can then re-load the ds_map using the function **ds_map_secure_load()**.",
        "id": "The id of the data structure to use",
        "filename": "The name of the file to save the map to"
    },
    "ds_map_secure_save_buffer": {
        "desc": "This function will save a previously created DS map to a buffer. You supply the DS map ID value (as returned by the function **ds_map_create**) and the ID of the buffer to write to (as returned by the function **buffer_create**).",
        "id": "The DS map ID value.",
        "buffer": "The buffer ID value."
    },
    "ds_map_size": {
        "desc": "With this function you can find how many key/values pairs the (previously created) ds_map contains.",
        "id": "The id of the data structure to check."
    },
    "ds_map_write": {
        "desc": "This function will turn the ds_map data of the specified map into string format which can then be written to an *.ini or a *.txt file for easy storage. This string can then be later read back into a new ds_map using **ds_map_read()**.\n\nNOTE: The returned string is not a human readable string, but rather a dump of the contents of the data-structure",
        "id": "The id of the data structure to use"
    },
    "ds_priority_add": {
        "desc": "With this function you can add a value (either a real number or a string) to a priority queue, at the same time assigning it a priority value.",
        "id": "The id of the priority queue to add to.",
        "value": "The value to add to the priority queue.",
        "priority": "The priority of the value to add."
    },
    "ds_priority_change_priority": {
        "desc": "This function will take a given value and change its priority within the referenced priority queue.",
        "id": "The id of the priority queue to change.",
        "value": "The value to change the priority of.",
        "priority": "The new priority of the value."
    },
    "ds_priority_clear": {
        "desc": "With this function you can clear all data from the given priority queue data-structure. This does NOT destroy the data-structure (for that you should use **ds_priority_destroy**) it only wipes all data from it and returns an empty priority queue.",
        "id": "The id of the data structure to clear."
    },
    "ds_priority_copy": {
        "desc": "This function can be used to copy the contents of one priority queue into another. Note that this does NOT remove the contents from the original priority queue, nor does it destroy the original priority queue. When using this function the priority queue being copied to must have been previously created and if it contained any items before the copy, then these will be cleared first (meaning this information will be lost).",
        "id": "The id of the priority queue to copy to.",
        "source": "The id of the priority queue to copy from."
    },
    "ds_priority_create": {
        "desc": "This function will create a new priority queue data-structure and return the index value. This value should be stored in a variable and used in all further function calls relating to the priority queue."
    },
    "ds_priority_delete_max": {
        "desc": "This function will return the value that has the highest priority in the queue and then remove the value (and priority) from the data structure. If more than one value has the same priority, the one that was added to the priority queue first will be the one to get removed, but all other values with the same priority will still be in the queue.",
        "id": "The id of the priority queue to use."
    },
    "ds_priority_delete_min": {
        "desc": "This function will return the value that has the lowest priority in the queue and then remove the value (and priority) from the data structure. If more than one value has the same priority, the one that was added to the priority queue first will be the one to get removed, but all other values with the same priority will still be in the queue.",
        "id": "The id of the priority queue to use."
    },
    "ds_priority_delete_value": {
        "desc": "This function will simply delete the given value, along with its priority, from the indexed priority queue.",
        "id": "The id of the priority queue to use.",
        "value": "The value to delete from the priority queue."
    },
    "ds_priority_destroy": {
        "desc": "This function will remove the given priority queue data-structure from memory, freeing up the resources it was using and removing all values that it contained. This function should always be used when you are finished using the ds_priority queue to prevent memory leaks that can slow down and crash your game.",
        "id": "The id of the data structure to remove."
    },
    "ds_priority_empty": {
        "desc": "With this function you can check the given ds_priority queue to see if it is empty (returns true) or not (returns false).",
        "id": "The id of the data structure to check."
    },
    "ds_priority_find_max": {
        "desc": "With this function you can find the value stored in the priority queue with the highest priority, and if more than one value has the same priority, the one that was added to the priority queue first will be the one to get returned. However, unlike **ds_priority_delete_max**, this function will not remove the value from the queue.",
        "id": "The id of the priority queue to use."
    },
    "ds_priority_find_min": {
        "desc": "With this function you can find the value stored in the priority queue with the lowest priority, and if more than one value has the same priority, the one that was added to the priority queue first will be the one to get returned. However, unlike **ds_priority_delete_min**, this function will not remove the value from the queue.",
        "id": "The id of the priority queue to use."
    },
    "ds_priority_find_priority": {
        "desc": "With this function you can retrieve the priority of any given value. If the value does not exist in the priority queue then undefined will be returned.",
        "id": "The id of the priority queue to use.",
        "value": "The value to find the priority of."
    },
    "ds_priority_read": {
        "desc": "With this function you can recreate a saved ds_priority (one that has previously been written as a string using **ds_priority_write**). You must first create a new ds_priority to read the string into, and if the ds_priority already exists and has information stored in it, then this will be cleared before reading. This function is of vital importance when creating save/load mechanisms for your game. Note that if the data structure was created with previous versions of GameMaker you should add the optional argument \"legacy\", setting it to true as the string format has changed with this version.",
        "id": "The id of the data structure to read into.",
        "str": "The string to read from.",
        "legacy": "(optional)Can be either true or false or omitted completely."
    },
    "ds_priority_size": {
        "desc": "This function will return the \"size\" of the priority queue, ie: the number of items that have been prioritized in it.",
        "id": "The id of the data structure to check."
    },
    "ds_priority_write": {
        "desc": "This function returns a string which can then be stored or transferred to another data structure using the **ds_priority_read** function.\n\nNOTE: The returned string is not a human readable string, but rather a dump of the contents of the data-structure",
        "id": "The id of the data structure to check."
    },
    "ds_queue_clear": {
        "desc": "With this function you can clear all data from the given queue data-structure. This does NOT destroy the data-structure (for that you should use **ds_queue_destroy**) it only wipes all data from it and returns an empty queue.",
        "id": "The id of the data structure to clear."
    },
    "ds_queue_copy": {
        "desc": "This function can be used to copy the contents of one queue into another. Note that this does NOT remove the contents from the original queue, nor does it destroy the original queue. When using this function the queue being copied to must have been previously created and if it contained any items before the copy, then these will be cleared first (meaning this information will be lost).",
        "id": "The id of the NEW queue.",
        "source": "The ORIGINAL queue to copy to id."
    },
    "ds_queue_create": {
        "desc": "This function will create a new queue data-structure and return the index value. This value should be stored in a variable and used in all further function calls relating to the queue."
    },
    "ds_queue_dequeue": {
        "desc": "This function will dequeue the head value off of the ds_queue, removing it from the queue and returning the value to be stored in a variable.",
        "id": "The id of the queue to dequeue from."
    },
    "ds_queue_destroy": {
        "desc": "This function will remove the given queue data-structure from memory, freeing up the resources it was using and removing all values that it contained. This function should always be used when you are finished using the ds_queue to prevent memory leaks that can slow down and crash your game.",
        "id": "The id of the data structure to remove."
    },
    "ds_queue_empty": {
        "desc": "With this function you can check the given ds_queue to see if it is empty (returns true) or not (returns false).",
        "id": "The id of the data structure to check."
    },
    "ds_queue_enqueue": {
        "desc": "This function will add a value (real or string) onto the tail of the ds_queue. The function can take a further 14 optional arguments (making a total of 15 possible additions), permitting you to add multiple values consecutively to the tail of the queue in a single call.",
        "id": "The id of the queue to add to.",
        "value": "The value to add to the queue.",
        "more": "Optional values to be added to the queue."
    },
    "ds_queue_head": {
        "desc": "This function will only read the first value of the queue (that which is \"at the head\"). It will not dequeue the value, meaning that it can still be read in the future by this function or the **ds_queue_dequeue**.",
        "id": "The id of the data structure to read from."
    },
    "ds_queue_read": {
        "desc": "With this function you can recreate a saved ds_queue (one that has previously been written as a string using **ds_queue_write**). You must first create a new ds_queue to read the string into, and if the ds_queue already exists and has information stored in it, then this will be cleared before reading. This function is of vital importance when creating save/load mechanisms for your game. Note that if the data structure was created with previous versions of GameMaker you should add the optional argument \"legacy\", setting it to true as the string format has changed with this version.",
        "id": "The id of the data structure to read into.",
        "str": "The string to read from.",
        "legacy": "(optional)Can be either true or false or omitted completely."
    },
    "ds_queue_size": {
        "desc": "This function will return the \"size\" of the queue, ie: the number of items that have been queued onto it.",
        "id": "The id of the data structure to check."
    },
    "ds_queue_tail": {
        "desc": "This function will only read the last value of the queue (that which is \"at the tail\"). It will not dequeue the value, meaning that it can still be read in the future by this function or the **ds_queue_dequeue**.",
        "id": "The id of the data structure to read from."
    },
    "ds_queue_write": {
        "desc": "This function returns a string which can then be stored or transferred to another data structure using the **ds_queue_read** function.\n\nNOTE: The returned string is not a human readable string, but rather a dump of the contents of the data-structure",
        "id": "The id of the data structure to write."
    },
    "ds_set_precision": {
        "desc": "When comparing values, for example when searching in a map or sorting a list, GameMaker: Studio must decide when two values are equal. For strings and integer values this is clear but for real numbers, due to floating point round-off errors, seemingly equal numbers can easily become unequal. For example, it's possible that **(5 / 3) * 3** will not be equal to 5! To help avoid this, a precision value is used on all real number functions, and when the difference between two numbers is smaller than this precision they are considered equal. The default a precision of 0.0000001 is used for all data structure functions unless changed by this function.\n\nNOTE: This precision is used in all data structures but not in other comparisons in GML!",
        "prec": "The precision value (default 0.0000001)"
    },
    "ds_stack_clear": {
        "desc": "With this function you can clear all data from the given stack data-structure. This does NOT destroy the data-structure (for that you should use **ds_stack_destroy**) it only wipes all data from it and returns an empty stack.",
        "id": "The id of the data structure to clear."
    },
    "ds_stack_copy": {
        "desc": "This function can be used to copy the contents of one stack into another. Note that this does NOT remove the contents from the original stack, nor does it destroy the original stack. When using this function the stack being copied to must have been previously created and if it contained any items before the copy, then these will be cleared first (meaning this information will be lost).",
        "id": "The id of the NEW stack.",
        "source": "The ORIGINAL stack to copy to id."
    },
    "ds_stack_create": {
        "desc": "This function will create a new stack data-structure and return the index value. This value should be stored in a variable and used in all further function calls relating to the stack."
    },
    "ds_stack_destroy": {
        "desc": "This function will remove the given stack data-structure from memory, freeing up the resources it was using and removing all values that it contained. This function should always be used when you are finished using the ds_stack to prevent memory leaks that can slow down and crash your game.",
        "id": "The id of the data structure to remove."
    },
    "ds_stack_empty": {
        "desc": "With this function you can check the given ds_stack to see if it is empty (returns true) or not (returns false).",
        "id": "The id of the data structure to check."
    },
    "ds_stack_pop": {
        "desc": "This function will pop the top value off of the ds_stack, removing it from the stack and returning the value to be stored in a variable.",
        "id": "The id of the data structure to pop from."
    },
    "ds_stack_push": {
        "desc": "This function will push (add) a value, which can be either a real or a string, onto the top of the stack. The function can take a further 14 optional arguments (making a total of 15 possible additions), permitting you to push multiple values consecutively to the stack in a single call.",
        "id": "The id of the data structure to push onto.",
        "value": "The value to push onto the stack.",
        "more": "Optional values to be added to the stack."
    },
    "ds_stack_read": {
        "desc": "With this function you can recreate a saved ds_stack (one that has previously been written as a string using **ds_stack_write**). You must first create a new ds_stack to read the string into, and if the ds_stack already exists and has information stored in it, then this will be cleared before reading. This function is of vital importance when creating save/load mechanisms for your game. Note that if the data structure was created with previous versions of GameMaker you should add the optional argument \"legacy\", setting it to true as the string format has changed with this version.",
        "id": "The id of the data structure to read into.",
        "str": "The string to read from.",
        "legacy": "(optional)Can be either true or false or omitted completely."
    },
    "ds_stack_size": {
        "desc": "This function will return the \"size\" of the stack, ie: the number of items that have been pushed onto it.",
        "id": "The id of the data structure to check."
    },
    "ds_stack_top": {
        "desc": "This function will only read the first value of the stack (that which is \"on top\"). It will not pop the value, meaning that it can still be read in the future by this function or the **ds_stack_pop**.",
        "id": "The id of the data structure to read from."
    },
    "ds_stack_write": {
        "desc": "This function returns a string which can then be stored or transferred to another data structure using the **ds_stack_read** function.\n\nNOTE: The returned string is not a human readable string, but rather a dump of the contents of the data-structure",
        "id": "The id of the data structure to write."
    },
    "dtan": {
        "desc": "In a right angled triangle dtan(val) = Opposite / Adjacent where \"val\" is one of the three angles.\n\nNOTE: A vast number of values (90, or -90 for example) will error with this function due to their returning infinity, a graph representation of this would produce asymptotes at these values.",
        "degree_angle": "The angle (in degrees) to return the tangent of."
    },
    "effect_clear": {
        "desc": ""
    },
	"effect_create_above": {
        "desc": "",
        "kind": "",
        "x": "",
        "y": "",
        "size": "",
        "colour": ""
    },
	"effect_create_below": {
        "desc": "",
        "kind": "",
        "x": "",
        "y": "",
        "size": "",
        "colour": ""
    },
	"environment_get_variable": {
        "desc": "",
        "name": ""
    },
	"event_inherited": {
        "desc": ""
    },
	"event_perform": {
        "desc": "",
        "type": "",
        "numb": ""
    },
	"event_perform_object": {
        "desc": "",
        "obj": "",
        "type": "",
        "numb": ""
    },
	"event_user": {
        "desc": "",
        "numb": ""
    },
	"exp": {
        "desc": "",
        "x": ""
    },
	"external_call": {
        "desc": "",
        "id": "",
        "arg1": "",
        "arg2": "",
        "more": ""
    },
	"external_define": {
        "desc": "",
        "dll": "",
        "name": "",
        "calltype": "",
        "restype": "",
        "argnumb": "",
        "arg1type": "",
        "arg2type": "",
        "more": ""
    },
	"external_free": {
        "desc": "",
        "dllname": ""
    },
	"facebook_accesstoken": {
        "desc": ""
    },
	"facebook_check_permission": {
        "desc": "",
        "permission": ""
    },
	"facebook_dialog": {
        "desc": "",
        "graph_path": "",
        "ds_map_params": "",
        "ds_map_response": ""
    },
	"facebook_graph_request": {
        "desc": "",
        "graph_path": "",
        "httpMethod": "",
        "ds_map_params": "",
        "ds_map_response": ""
    },
	"facebook_init": {
        "desc": ""
    },
	"facebook_launch_offerwall": {
        "desc": "",
        "product_url": ""
    },
	"facebook_login": {
        "desc": "",
        "ds_list_of_permissions": "",
        "ios_login_type": ""
    },
	"facebook_logout": {
        "desc": ""
    },
	"facebook_post_message": {
        "desc": "",
        "title": "",
        "caption": "",
        "message": "",
        "picture_url": "",
        "redirect_url": "",
        "actionname": "",
        "action_url": ""
    },
	"facebook_request_publish_permissions": {
        "desc": "",
        "ds_list_permissions": ""
    },
	"facebook_request_read_permissions": {
        "desc": "",
        "ds_list_permissions": ""
    },
	"facebook_send_invite": {
        "desc": "",
        "title": "",
        "message": "",
        "picture_url": "",
        "redirect_url": "",
        "ds_map_response": ""
    },
	"facebook_status": {
        "desc": ""
    },
	"facebook_user_id": {
        "desc": ""
    },
	"filename_change_ext": {
        "desc": "",
        "fname": "",
        "newext": ""
    },
	"filename_dir": {
        "desc": "",
        "fname": ""
    },
	"filename_drive": {
        "desc": "",
        "fname": ""
    },
	"filename_ext": {
        "desc": "",
        "fname": ""
    },
	"filename_name": {
        "desc": "",
        "fname": ""
    },
	"filename_path": {
        "desc": "",
        "fname": ""
    },
	"file_attributes": {
        "desc": "",
        "fname": "",
        "attr": ""
    },
	"file_bin_close": {
        "desc": "",
        "binfile": ""
    },
	"file_bin_open": {
        "desc": "",
        "fname": "",
        "mode": ""
    },
	"file_bin_position": {
        "desc": "",
        "binfile": ""
    },
	"file_bin_read_byte": {
        "desc": "",
        "binfile": ""
    },
	"file_bin_rewrite": {
        "desc": "",
        "binfile": ""
    },
	"file_bin_seek": {
        "desc": "",
        "binfile": "",
        "pos": ""
    },
	"file_bin_size": {
        "desc": "",
        "binfile": ""
    },
	"file_bin_write_byte": {
        "desc": "",
        "binfile": "",
        "byte": ""
    },
	"file_copy": {
        "desc": "",
        "fname": "",
        "newname": ""
    },
	"file_delete": {
        "desc": "",
        "fname": ""
    },
	"file_exists": {
        "desc": "",
        "fname": ""
    },
	"file_find_close": {
        "desc": ""
    },
	"file_find_first": {
        "desc": "",
        "mask": "",
        "attr": ""
    },
	"file_find_next": {
        "desc": ""
    },
	"file_rename": {
        "desc": "",
        "oldname": "",
        "newname": ""
    },
	"file_text_close": {
        "desc": "",
        "file": ""
    },
	"file_text_eof": {
        "desc": "",
        "file": ""
    },
	"file_text_eoln": {
        "desc": "",
        "file": ""
    },
	"file_text_open_append": {
        "desc": "",
        "fname": ""
    },
	"file_text_open_from_string": {
        "desc": "",
        "content": ""
    },
	"file_text_open_read": {
        "desc": "",
        "fname": ""
    },
	"file_text_open_write": {
        "desc": "",
        "fname": ""
    },
	"file_text_readln": {
        "desc": "",
        "file": ""
    },
	"file_text_read_real": {
        "desc": "",
        "file": ""
    },
	"file_text_read_string": {
        "desc": "",
        "file": ""
    },
	"file_text_writeln": {
        "desc": "",
        "file": ""
    },
	"file_text_write_real": {
        "desc": "",
        "file": "",
        "val": ""
    },
	"file_text_write_string": {
        "desc": "",
        "file": "",
        "str": ""
    },
	"floor": {
        "desc": "",
        "x": ""
    },
	"font_add": {
        "desc": "",
        "name": "",
        "size": "",
        "bold": "",
        "italic": "",
        "first": "",
        "last": ""
    },
	"font_add_sprite": {
        "desc": "",
        "spr": "",
        "first": "",
        "prop": "",
        "sep": ""
    },
	"font_add_sprite_ext": {
        "desc": "",
        "spr": "",
        "mapstring": "",
        "prop": "",
        "sep": ""
    },
	"font_delete": {
        "desc": "",
        "ind": ""
    },
	"font_exists": {
        "desc": "",
        "ind": ""
    },
	"font_get_bold": {
        "desc": "",
        "ind": ""
    },
	"font_get_first": {
        "desc": "",
        "ind": ""
    },
	"font_get_fontname": {
        "desc": "",
        "ind": ""
    },
	"font_get_italic": {
        "desc": "",
        "ind": ""
    },
	"font_get_last": {
        "desc": "",
        "ind": ""
    },
	"font_get_name": {
        "desc": "",
        "ind": ""
    },
	"font_get_size": {
        "desc": "",
        "ind": ""
    },
	"font_get_texture": {
        "desc": "",
        "ind": ""
    },
	"font_get_uvs": {
        "desc": "",
        "ind": ""
    },
	"font_replace": {
        "desc": "",
        "ind": "",
        "name": "",
        "size": "",
        "bold": "",
        "italic": "",
        "first": "",
        "last": ""
    },
	"font_replace_sprite": {
        "desc": "",
        "ind": "",
        "spr": "",
        "first": "",
        "prop": "",
        "sep": ""
    },
	"font_replace_sprite_ext": {
        "desc": "",
        "font": "",
        "spr": "",
        "string_map": "",
        "prop": "",
        "sep": ""
    },
	"font_set_cache_size": {
        "desc": "",
        "font": "",
        "max": ""
    },
	"frac": {
        "desc": "",
        "x": ""
    },
	"gamepad_axis_count": {
        "desc": "",
        "axis": ""
    },
	"gamepad_axis_value": {
        "desc": "",
        "device": "",
        "axisIndex": ""
    },
	"gamepad_button_check": {
        "desc": "",
        "device": "",
        "buttonIndex": ""
    },
	"gamepad_button_check_pressed": {
        "desc": "",
        "device": "",
        "buttonIndex": ""
    },
	"gamepad_button_check_released": {
        "desc": "",
        "device": "",
        "buttonIndex": ""
    },
	"gamepad_button_count": {
        "desc": "",
        "device": ""
    },
	"gamepad_button_value": {
        "desc": "",
        "device": "",
        "buttonIndex": ""
    },
	"gamepad_get_axis_deadzone": {
        "desc": "",
        "device": ""
    },
	"gamepad_get_button_threshold": {
        "desc": "",
        "device": ""
    },
	"gamepad_get_description": {
        "desc": "",
        "device": ""
    },
	"gamepad_get_device_count": {
        "desc": ""
    },
	"gamepad_is_connected": {
        "desc": "",
        "device": ""
    },
	"gamepad_is_supported": {
        "desc": ""
    },
	"gamepad_set_axis_deadzone": {
        "desc": "",
        "device": "",
        "deadzone": ""
    },
	"gamepad_set_button_threshold": {
        "desc": "",
        "device": "",
        "threshold": ""
    },
	"gamepad_set_color": {
        "desc": "",
        "index": "",
        "color": ""
    },
	"gamepad_set_colour": {
        "desc": "",
        "index": "",
        "colour": ""
    },
	"gamepad_set_vibration": {
        "desc": "",
        "device": "",
        "leftMotorSpeed": "",
        "rightMotorSpeed": ""
    },
	"game_end": {
        "desc": ""
    },
	"game_load": {
        "desc": "",
        "filename": ""
    },
	"game_load_buffer": {
        "desc": "",
        "buffer": ""
    },
	"game_restart": {
        "desc": ""
    },
	"game_save": {
        "desc": "",
        "filename": ""
    },
	"game_save_buffer": {
        "desc": "",
        "buffer": ""
    },
	"get_integer": {
        "desc": "",
        "str": "",
        "def": ""
    },
	"get_integer_async": {
        "desc": "",
        "str": "",
        "def": ""
    },
	"get_login_async": {
        "desc": "",
        "username": "",
        "password": ""
    },
	"get_open_filename": {
        "desc": "",
        "filter": "",
        "fname": ""
    },
	"get_open_filename_ext": {
        "desc": "",
        "filter": "",
        "fname": "",
        "dir": "",
        "title": ""
    },
	"get_save_filename": {
        "desc": "",
        "filter": "",
        "fname": ""
    },
	"get_save_filename_ext": {
        "desc": "",
        "filter": "",
        "fname": "",
        "dir": "",
        "title": ""
    },
	"get_string": {
        "desc": "",
        "str": "",
        "def": ""
    },
	"get_string_async": {
        "desc": "",
        "str": "",
        "def": ""
    },
	"get_timer": {
        "desc": ""
    },
	"gml_pragma": {
        "desc": "",
        "setting": "",
        "more": ""
    },
	"gml_release_mode": {
        "desc": "",
        "enable": ""
    },
	"highscore_add": {
        "desc": "",
        "str": "",
        "numb": ""
    },
	"highscore_clear": {
        "desc": ""
    },
	"highscore_name": {
        "desc": "",
        "place": ""
    },
	"highscore_value": {
        "desc": "",
        "place": ""
    },
	"http_get": {
        "desc": "",
        "url": ""
    },
	"http_get_file": {
        "desc": "",
        "url": "",
        "dest": ""
    },
	"http_post_string": {
        "desc": "",
        "url": "",
        "string": ""
    },
	"http_request": {
        "desc": "",
        "url": "",
        "method": "",
        "header_map": "",
        "body": ""
    },
	"iap_acquire": {
        "desc": "",
        "product_id": "",
        "payload": ""
    },
	"iap_activate": {
        "desc": "",
        "ds_list": ""
    },
	"iap_consume": {
        "desc": "",
        "product_id": ""
    },
	"iap_enumerate_products": {
        "desc": "",
        "ds_list": ""
    },
	"iap_is_purchased": {
        "desc": "",
        "product_id": ""
    },
	"iap_product_details": {
        "desc": "",
        "product_id": "",
        "ds_map": ""
    },
	"iap_purchase_details": {
        "desc": "",
        "product_id": "",
        "ds_map": ""
    },
	"iap_restore_all": {
        "desc": ""
    },
	"iap_status": {
        "desc": ""
    },
	"ini_close": {
        "desc": ""
    },
	"ini_key_delete": {
        "desc": "",
        "section": "",
        "key": ""
    },
	"ini_key_exists": {
        "desc": "",
        "section": "",
        "key": ""
    },
	"ini_open": {
        "desc": "",
        "fname": ""
    },
	"ini_open_from_string": {
        "desc": "",
        "content": ""
    },
	"ini_read_real": {
        "desc": "",
        "section": "",
        "key": "",
        "default": ""
    },
	"ini_read_string": {
        "desc": "",
        "section": "",
        "key": "",
        "default": ""
    },
	"ini_section_delete": {
        "desc": "",
        "section": ""
    },
	"ini_section_exists": {
        "desc": "",
        "section": ""
    },
	"ini_write_real": {
        "desc": "",
        "section": "",
        "key": "",
        "value": ""
    },
	"ini_write_string": {
        "desc": "",
        "section": "",
        "key": "",
        "str": ""
    },
	"instance_activate_all": {
        "desc": ""
    },
	"instance_activate_object": {
        "desc": "",
        "obj": ""
    },
	"instance_activate_region": {
        "desc": "",
        "left": "",
        "top": "",
        "width": "",
        "height": "",
        "inside": ""
    },
	"instance_change": {
        "desc": "",
        "obj": "",
        "performevents": ""
    },
	"instance_copy": {
        "desc": "",
        "performevents": ""
    },
	"instance_create": {
        "desc": "",
        "x": "",
        "y": "",
        "obj": ""
    },
	"instance_deactivate_all": {
        "desc": "",
        "notme": ""
    },
	"instance_deactivate_object": {
        "desc": "",
        "obj": ""
    },
	"instance_deactivate_region": {
        "desc": "",
        "left": "",
        "top": "",
        "width": "",
        "height": "",
        "inside": "",
        "notme": ""
    },
	"instance_destroy": {
        "desc": "",
        "id": "",
        "execute_event_flag": ""
    },
	"instance_exists": {
        "desc": "",
        "obj": ""
    },
	"instance_find": {
        "desc": "",
        "obj": "",
        "n": ""
    },
	"instance_furthest": {
        "desc": "",
        "x": "",
        "y": "",
        "obj": ""
    },
	"instance_nearest": {
        "desc": "",
        "x": "",
        "y": "",
        "obj": ""
    },
	"instance_number": {
        "desc": "",
        "obj": ""
    },
	"instance_place": {
        "desc": "",
        "x": "",
        "y": "",
        "obj": ""
    },
	"instance_position": {
        "desc": "",
        "x": "",
        "y": "",
        "obj": ""
    },
	"int64": {
        "desc": "",
        "val": ""
    },
	"io_clear": {
        "desc": ""
    },
	"irandom": {
        "desc": "",
        "x": ""
    },
	"irandom_old": {
        "desc": "",
        "x": ""
    },
	"irandom_range": {
        "desc": "",
        "x1": "",
        "x2": ""
    },
	"irandom_range_old": {
        "desc": "",
        "x1": "",
        "x2": ""
    },
	"is_array": {
        "desc": "",
        "val": ""
    },
	"is_bool": {
        "desc": "",
        "val": ""
    },
	"is_int32": {
        "desc": "",
        "val": ""
    },
	"is_int64": {
        "desc": "",
        "val": ""
    },
	"is_matrix": {
        "desc": "",
        "val": ""
    },
	"is_ptr": {
        "desc": "",
        "val": ""
    },
	"is_real": {
        "desc": "",
        "val": ""
    },
	"is_string": {
        "desc": "",
        "val": ""
    },
	"is_undefined": {
        "desc": "",
        "val": ""
    },
	"is_vec3": {
        "desc": "",
        "val": ""
    },
	"is_vec4": {
        "desc": "",
        "val": ""
    },
	"joystick_axes": {
        "desc": "",
        "id": ""
    },
	"joystick_buttons": {
        "desc": "",
        "id": ""
    },
	"joystick_check_button": {
        "desc": "",
        "id": "",
        "button": ""
    },
	"joystick_direction": {
        "desc": "",
        "id": ""
    },
	"joystick_exists": {
        "desc": "",
        "id": ""
    },
	"joystick_has_pov": {
        "desc": "",
        "id": ""
    },
	"joystick_name": {
        "desc": "",
        "id": ""
    },
	"joystick_pov": {
        "desc": "",
        "id": ""
    },
	"joystick_rpos": {
        "desc": "",
        "id": ""
    },
	"joystick_upos": {
        "desc": "",
        "id": ""
    },
	"joystick_vpos": {
        "desc": "",
        "id": ""
    },
	"joystick_xpos": {
        "desc": "",
        "id": ""
    },
	"joystick_ypos": {
        "desc": "",
        "id": ""
    },
	"joystick_zpos": {
        "desc": "",
        "id": ""
    },
	"json_decode": {
        "desc": "",
        "string": ""
    },
	"json_encode": {
        "desc": "",
        "ds_map": ""
    },
	"keyboard_check": {
        "desc": "",
        "key": ""
    },
	"keyboard_check_direct": {
        "desc": "",
        "key": ""
    },
	"keyboard_check_pressed": {
        "desc": "",
        "key": ""
    },
	"keyboard_check_released": {
        "desc": "",
        "key": ""
    },
	"keyboard_clear": {
        "desc": "",
        "key": ""
    },
	"keyboard_get_map": {
        "desc": "",
        "key": ""
    },
	"keyboard_get_numlock": {
        "desc": ""
    },
	"keyboard_key_press": {
        "desc": "",
        "key": ""
    },
	"keyboard_key_release": {
        "desc": "",
        "key": ""
    },
	"keyboard_set_map": {
        "desc": "",
        "key1": "",
        "key2": ""
    },
	"keyboard_set_numlock": {
        "desc": "",
        "bool": ""
    },
	"keyboard_unset_map": {
        "desc": ""
    },
	"lengthdir_x": {
        "desc": "",
        "len": "",
        "dir": ""
    },
	"lengthdir_y": {
        "desc": "",
        "len": "",
        "dir": ""
    },
	"lerp": {
        "desc": "",
        "val1": "",
        "val2": "",
        "amount": ""
    },
	"ln": {
        "desc": "",
        "x": ""
    },
	"log10": {
        "desc": "",
        "x": ""
    },
	"log2": {
        "desc": "",
        "x": ""
    },
	"logn": {
        "desc": "",
        "n": "",
        "x": ""
    },
	"make_color_hsv": {
        "desc": "",
        "hue": "",
        "saturation": "",
        "value": ""
    },
	"make_color_rgb": {
        "desc": "",
        "red": "",
        "green": "",
        "blue": ""
    },
	"make_colour_hsv": {
        "desc": "",
        "hue": "",
        "saturation": "",
        "value": ""
    },
	"make_colour_rgb": {
        "desc": "",
        "red": "",
        "green": "",
        "blue": ""
    },
	"math_get_epsilon": {
        "desc": ""
    },
	"math_set_epsilon": {
        "desc": "",
        "new_epsilon": ""
    },
	"matrix_build": {
        "desc": "",
        "x": "",
        "y": "",
        "z": "",
        "xrotation": "",
        "yrotation": "",
        "zrotation": "",
        "xscale": "",
        "yscale": "",
        "zscale": ""
    },
	"matrix_get": {
        "desc": "",
        "type": ""
    },
	"matrix_multiply": {
        "desc": "",
        "matrix": ""
    },
	"matrix_set": {
        "desc": "",
        "type": "",
        "matrix": ""
    },
	"max": {
        "desc": "",
        "x1": "",
        "x2": "",
        "x3": "",
        "more": ""
    },
	"md5_file": {
        "desc": "",
        "fname": ""
    },
	"md5_string_unicode": {
        "desc": "",
        "string": ""
    },
	"md5_string_utf8": {
        "desc": "",
        "string": ""
    },
	"mean": {
        "desc": "",
        "x1": "",
        "x2": "",
        "x3": "",
        "more": ""
    },
	"median": {
        "desc": "",
        "x1": "",
        "x2": "",
        "x3": "",
        "more": ""
    },
	"merge_color": {
        "desc": "",
        "col1": "",
        "col2": "",
        "amount": ""
    },
	"min": {
        "desc": "",
        "x1": "",
        "x2": "",
        "x3": "",
        "more": ""
    },
	"motion_add": {
        "desc": "",
        "dir": "",
        "speed": ""
    },
	"motion_set": {
        "desc": "",
        "dir": "",
        "speed": ""
    },
	"mouse_check_button": {
        "desc": "",
        "button": ""
    },
	"mouse_check_button_pressed": {
        "desc": "",
        "button": ""
    },
	"mouse_check_button_released": {
        "desc": "",
        "button": ""
    },
	"mouse_clear": {
        "desc": "",
        "button": ""
    },
	"mouse_wheel_down": {
        "desc": ""
    },
	"mouse_wheel_up": {
        "desc": ""
    },
	"move_bounce_all": {
        "desc": "",
        "advanced": ""
    },
	"move_bounce_solid": {
        "desc": "",
        "advanced": ""
    },
	"move_contact_all": {
        "desc": "",
        "dir": "",
        "maxdist": ""
    },
	"move_contact_solid": {
        "desc": "",
        "dir": "",
        "maxdist": ""
    },
	"move_outside_all": {
        "desc": "",
        "dir": "",
        "maxdist": ""
    },
	"move_outside_solid": {
        "desc": "",
        "dir": "",
        "maxdist": ""
    },
	"move_random": {
        "desc": "",
        "hsnap": "",
        "vsnap": ""
    },
	"move_snap": {
        "desc": "",
        "hsnap": "",
        "vsnap": ""
    },
	"move_towards_point": {
        "desc": "",
        "x": "",
        "y": "",
        "sp": ""
    },
	"move_wrap": {
        "desc": "",
        "hor": "",
        "vert": "",
        "margin": ""
    },
	"mp_grid_add_cell": {
        "desc": "",
        "id": "",
        "h": "",
        "v": ""
    },
	"mp_grid_add_instances": {
        "desc": "",
        "id": "",
        "obj": "",
        "prec": ""
    },
	"mp_grid_add_rectangle": {
        "desc": "",
        "id": "",
        "left": "",
        "top": "",
        "right": "",
        "bottom": ""
    },
	"mp_grid_clear_all": {
        "desc": "",
        "id": ""
    },
	"mp_grid_clear_cell": {
        "desc": "",
        "id": "",
        "h": "",
        "v": ""
    },
	"mp_grid_clear_rectangle": {
        "desc": "",
        "id": "",
        "left": "",
        "top": "",
        "right": "",
        "bottom": ""
    },
	"mp_grid_create": {
        "desc": "",
        "left": "",
        "top": "",
        "hcells": "",
        "vcells": "",
        "cellwidth": "",
        "cellheight": ""
    },
	"mp_grid_destroy": {
        "desc": "",
        "id": ""
    },
	"mp_grid_draw": {
        "desc": "",
        "id": ""
    },
	"mp_grid_get_cell": {
        "desc": "",
        "id": "",
        "h": "",
        "v": ""
    },
	"mp_grid_path": {
        "desc": "",
        "id": "",
        "path": "",
        "xstart": "",
        "ystart": "",
        "xgoal": "",
        "ygoal": "",
        "allowdiag": ""
    },
	"mp_grid_to_ds_grid": {
        "desc": "",
        "src": "",
        "dest": ""
    },
	"mp_linear_path": {
        "desc": "",
        "path": "",
        "xg": "",
        "yg": "",
        "stepsize": "",
        "checkall": ""
    },
	"mp_linear_path_object": {
        "desc": "",
        "path": "",
        "xg": "",
        "yg": "",
        "stepsize": "",
        "obj": ""
    },
	"mp_linear_step": {
        "desc": "",
        "x": "",
        "y": "",
        "speed": "",
        "checkall": ""
    },
	"mp_linear_step_object": {
        "desc": "",
        "x": "",
        "y": "",
        "speed": "",
        "obj": ""
    },
	"mp_potential_path": {
        "desc": "",
        "path": "",
        "xg": "",
        "yg": "",
        "stepsize": "",
        "factor": "",
        "checkall": ""
    },
	"mp_potential_path_object": {
        "desc": "",
        "path": "",
        "xg": "",
        "yg": "",
        "stepsize": "",
        "factor": "",
        "obj": ""
    },
	"mp_potential_settings": {
        "desc": "",
        "maxrot": "",
        "rotstep": "",
        "ahead": "",
        "onspot": ""
    },
	"mp_potential_step": {
        "desc": "",
        "x": "",
        "y": "",
        "speed": "",
        "checkall": ""
    },
	"mp_potential_step_object": {
        "desc": "",
        "x": "",
        "y": "",
        "speed": "",
        "obj": ""
    },
	"network_connect": {
        "desc": "",
        "socket": "",
        "url": "",
        "port": ""
    },
	"network_connect_raw": {
        "desc": "",
        "socket": "",
        "url": "",
        "port": ""
    },
	"network_create_server": {
        "desc": "",
        "type": "",
        "port": "",
        "maxclients": ""
    },
	"network_create_server_raw": {
        "desc": "",
        "type": "",
        "port": "",
        "maxclients": ""
    },
	"network_create_socket": {
        "desc": "",
        "type": ""
    },
	"network_create_socket_ext": {
        "desc": "",
        "type": "",
        "port": ""
    },
	"network_destroy": {
        "desc": "",
        "socket": ""
    },
	"network_resolve": {
        "desc": "",
        "url": ""
    },
	"network_send_broadcast": {
        "desc": "",
        "socket": "",
        "port": "",
        "bufferid": "",
        "size": ""
    },
	"network_send_packet": {
        "desc": "",
        "socket": "",
        "bufferid": "",
        "size": ""
    },
	"network_send_raw": {
        "desc": "",
        "socket": "",
        "bufferid": "",
        "size": ""
    },
	"network_send_udp": {
        "desc": "",
        "socket": "",
        "URL": "",
        "port": "",
        "data": "",
        "size": ""
    },
	"network_send_udp_raw": {
        "desc": "",
        "socket": "",
        "URL": "",
        "port": "",
        "data": "",
        "size": ""
    },
	"network_set_config": {
        "desc": "",
        "parameter": "",
        "value": ""
    },
	"network_set_timeout": {
        "desc": "",
        "socket": "",
        "read": "",
        "write": ""
    },
	"object_exists": {
        "desc": "",
        "ind": ""
    },
	"object_get_mask": {
        "desc": "",
        "ind": ""
    },
	"object_get_name": {
        "desc": "",
        "ind": ""
    },
	"object_get_parent": {
        "desc": "",
        "ind": ""
    },
	"object_get_persistent": {
        "desc": "",
        "ind": ""
    },
	"object_get_physics": {
        "desc": "",
        "ind": ""
    },
	"object_get_solid": {
        "desc": "",
        "ind": ""
    },
	"object_get_sprite": {
        "desc": "",
        "ind": ""
    },
	"object_get_visible": {
        "desc": "",
        "ind": ""
    },
	"object_is_ancestor": {
        "desc": "",
        "ind_child": "",
        "ind_parent": ""
    },
	"object_set_mask": {
        "desc": "",
        "ind": "",
        "spr": ""
    },
	"object_set_parent": {
        "desc": "",
        "ind": "",
        "obj": ""
    },
	"object_set_persistent": {
        "desc": "",
        "ind": "",
        "pers": ""
    },
	"object_set_solid": {
        "desc": "",
        "ind": "",
        "soild": ""
    },
	"object_set_sprite": {
        "desc": "",
        "ind": "",
        "spr": ""
    },
	"object_set_visible": {
        "desc": "",
        "ind": "",
        "vis": ""
    },
	"ord": {
        "desc": "",
        "char": ""
    },
	"os_get_config": {
        "desc": ""
    },
	"os_get_info": {
        "desc": ""
    },
	"os_get_language": {
        "desc": ""
    },
	"os_get_region": {
        "desc": ""
    },
	"os_is_network_connected": {
        "desc": ""
    },
	"os_is_paused": {
        "desc": ""
    },
	"os_lock_orientation": {
        "desc": "",
        "flag": ""
    },
	"os_powersave_enable": {
        "desc": "",
        "enable": ""
    },
	"parameter_count": {
        "desc": ""
    },
	"parameter_string": {
        "desc": "",
        "n": ""
    },
	"part_emitter_burst": {
        "desc": "",
        "ps": "",
        "ind": "",
        "parttype": "",
        "number": ""
    },
	"part_emitter_clear": {
        "desc": "",
        "ps": "",
        "ind": ""
    },
	"part_emitter_create": {
        "desc": "",
        "ps": ""
    },
	"part_emitter_destroy": {
        "desc": "",
        "ps": "",
        "ind": ""
    },
	"part_emitter_destroy_all": {
        "desc": "",
        "ps": ""
    },
	"part_emitter_exists": {
        "desc": "",
        "ps": "",
        "ind": ""
    },
	"part_emitter_region": {
        "desc": "",
        "ps": "",
        "ind": "",
        "xmin": "",
        "xmax": "",
        "ymin": "",
        "ymax": "",
        "shape": "",
        "distribution": ""
    },
	"part_emitter_stream": {
        "desc": "",
        "ps": "",
        "ind": "",
        "parttype": "",
        "number": ""
    },
	"part_particles_clear": {
        "desc": "",
        "ind": ""
    },
	"part_particles_count": {
        "desc": "",
        "ind": ""
    },
	"part_particles_create": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "parttype": "",
        "number": ""
    },
	"part_particles_create_color": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "parttype": "",
        "colour": "",
        "number": ""
    },
	"part_particles_create_colour": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "parttype": "",
        "colour": "",
        "number": ""
    },
	"part_system_automatic_draw": {
        "desc": "",
        "ind": "",
        "draw": ""
    },
	"part_system_automatic_update": {
        "desc": "",
        "ind": "",
        "automatic": ""
    },
	"part_system_clear": {
        "desc": "",
        "ind": ""
    },
	"part_system_create": {
        "desc": ""
    },
	"part_system_depth": {
        "desc": "",
        "ind": "",
        "depth": ""
    },
	"part_system_destroy": {
        "desc": "",
        "ind": ""
    },
	"part_system_drawit": {
        "desc": "",
        "ind": ""
    },
	"part_system_draw_order": {
        "desc": "",
        "ind": "",
        "oldtonew": ""
    },
	"part_system_exists": {
        "desc": "",
        "ind": ""
    },
	"part_system_position": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": ""
    },
	"part_system_update": {
        "desc": "",
        "ind": ""
    },
	"part_type_alpha1": {
        "desc": "",
        "ind": "",
        "alpha1": ""
    },
	"part_type_alpha2": {
        "desc": "",
        "ind": "",
        "alpha1": "",
        "alpha2": ""
    },
	"part_type_alpha3": {
        "desc": "",
        "ind": "",
        "alpha1": "",
        "alpha2": "",
        "alpha3": ""
    },
	"part_type_blend": {
        "desc": "",
        "ind": "",
        "additive": ""
    },
	"part_type_clear": {
        "desc": "",
        "ind": ""
    },
	"part_type_color1": {
        "desc": "",
        "ind": "",
        "color1": ""
    },
	"part_type_color2": {
        "desc": "",
        "ind": "",
        "color1": "",
        "color2": ""
    },
	"part_type_color3": {
        "desc": "",
        "ind": "",
        "color1": "",
        "color2": "",
        "color3": ""
    },
	"part_type_color_hsv": {
        "desc": "",
        "ind": "",
        "hmin": "",
        "hmax": "",
        "smin": "",
        "smax": "",
        "vmin": "",
        "vmax": ""
    },
	"part_type_color_mix": {
        "desc": "",
        "ind": "",
        "color1": "",
        "color2": ""
    },
	"part_type_color_rgb": {
        "desc": "",
        "ind": "",
        "rmin": "",
        "rmax": "",
        "gmin": "",
        "gmax": "",
        "bmin": "",
        "bmax": ""
    },
	"part_type_colour1": {
        "desc": "",
        "ind": "",
        "colour1": ""
    },
	"part_type_colour2": {
        "desc": "",
        "ind": "",
        "colour1": "",
        "colour2": ""
    },
	"part_type_colour3": {
        "desc": "",
        "ind": "",
        "colour1": "",
        "colour2": "",
        "colour3": ""
    },
	"part_type_colour_hsv": {
        "desc": "",
        "ind": "",
        "hmin": "",
        "hmax": "",
        "smin": "",
        "smax": "",
        "vmin": "",
        "vmax": ""
    },
	"part_type_colour_mix": {
        "desc": "",
        "ind": "",
        "colour1": "",
        "colour2": ""
    },
	"part_type_colour_rgb": {
        "desc": "",
        "ind": "",
        "rmin": "",
        "rmax": "",
        "gmin": "",
        "gmax": "",
        "bmin": "",
        "bmax": ""
    },
	"part_type_create": {
        "desc": ""
    },
	"part_type_death": {
        "desc": "",
        "ind": "",
        "death_number": "",
        "death_type": ""
    },
	"part_type_destroy": {
        "desc": "",
        "ind": ""
    },
	"part_type_direction": {
        "desc": "",
        "ind": "",
        "dir_min": "",
        "dir_max": "",
        "dir_incr": "",
        "dir_wiggle": ""
    },
	"part_type_exists": {
        "desc": "",
        "ind": ""
    },
	"part_type_gravity": {
        "desc": "",
        "ind": "",
        "grav_amount": "",
        "grav_dir": ""
    },
	"part_type_life": {
        "desc": "",
        "ind": "",
        "life_min": "",
        "life_max": ""
    },
	"part_type_orientation": {
        "desc": "",
        "ind": "",
        "ang_min": "",
        "ang_max": "",
        "ang_incr": "",
        "ang_wiggle": "",
        "ang_relative": ""
    },
	"part_type_scale": {
        "desc": "",
        "ind": "",
        "xscale": "",
        "yscale": ""
    },
	"part_type_shape": {
        "desc": "",
        "ind": "",
        "shape": ""
    },
	"part_type_size": {
        "desc": "",
        "ind": "",
        "size_min": "",
        "size_max": "",
        "size_incr": "",
        "size_wiggle": ""
    },
	"part_type_speed": {
        "desc": "",
        "ind": "",
        "speed_min": "",
        "speed_max": "",
        "speed_incr": "",
        "speed_wiggle": ""
    },
	"part_type_sprite": {
        "desc": "",
        "ind": "",
        "sprite": "",
        "animat": "",
        "stretch": "",
        "random": ""
    },
	"part_type_step": {
        "desc": "",
        "ind": "",
        "step_number": "",
        "step_type": ""
    },
	"path_add": {
        "desc": ""
    },
	"path_add_point": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "speed": ""
    },
	"path_append": {
        "desc": "",
        "ind": "",
        "path": ""
    },
	"path_assign": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "speed": ""
    },
	"path_change_point": {
        "desc": "",
        "ind": "",
        "n": "",
        "x": "",
        "y": "",
        "speed": ""
    },
	"path_clear_points": {
        "desc": "",
        "ind": ""
    },
	"path_delete": {
        "desc": "",
        "ind": ""
    },
	"path_delete_point": {
        "desc": "",
        "ind": "",
        "n": ""
    },
	"path_duplicate": {
        "desc": "",
        "ind": ""
    },
	"path_end": {
        "desc": ""
    },
	"path_exists": {
        "desc": "",
        "ind": ""
    },
	"path_flip": {
        "desc": "",
        "ind": ""
    },
	"path_get_closed": {
        "desc": "",
        "ind": ""
    },
	"path_get_kind": {
        "desc": "",
        "ind": ""
    },
	"path_get_length": {
        "desc": "",
        "ind": ""
    },
	"path_get_name": {
        "desc": "",
        "ind": ""
    },
	"path_get_number": {
        "desc": "",
        "ind": ""
    },
	"path_get_point_speed": {
        "desc": "",
        "ind": "",
        "n": ""
    },
	"path_get_point_x": {
        "desc": "",
        "ind": "",
        "n": ""
    },
	"path_get_point_y": {
        "desc": "",
        "ind": "",
        "n": ""
    },
	"path_get_precision": {
        "desc": "",
        "ind": ""
    },
	"path_get_speed": {
        "desc": "",
        "ind": "",
        "pos": ""
    },
	"path_get_time": {
        "desc": "",
        "ind": "",
        "speed": ""
    },
	"path_get_x": {
        "desc": "",
        "ind": "",
        "pos": ""
    },
	"path_get_y": {
        "desc": "",
        "ind": "",
        "pos": ""
    },
	"path_insert_point": {
        "desc": "",
        "ind": "",
        "n": "",
        "x": "",
        "y": "",
        "speed": ""
    },
	"path_mirror": {
        "desc": "",
        "ind": ""
    },
	"path_rescale": {
        "desc": "",
        "ind": "",
        "xscale": "",
        "yscale": ""
    },
	"path_reverse": {
        "desc": "",
        "ind": ""
    },
	"path_rotate": {
        "desc": "",
        "ind": "",
        "angle": ""
    },
	"path_set_closed": {
        "desc": "",
        "ind": "",
        "closed": ""
    },
	"path_set_kind": {
        "desc": "",
        "ind": "",
        "kind": ""
    },
	"path_set_precision": {
        "desc": "",
        "ind": "",
        "prec": ""
    },
	"path_shift": {
        "desc": "",
        "ind": "",
        "xshift": "",
        "yshift": ""
    },
	"path_start": {
        "desc": "",
        "path": "",
        "speed": "",
        "endaction": "",
        "absolute": ""
    },
	"physics_apply_angular_impulse": {
        "desc": "",
        "impulse": ""
    },
	"physics_apply_force": {
        "desc": "",
        "xpos": "",
        "ypos": "",
        "xforce": "",
        "yforce": ""
    },
	"physics_apply_impulse": {
        "desc": "",
        "xpos": "",
        "ypos": "",
        "ximpulse": "",
        "yimpulse": ""
    },
	"physics_apply_local_force": {
        "desc": "",
        "xlocal": "",
        "ylocal": "",
        "xforce_local": "",
        "yforce_local": ""
    },
	"physics_apply_local_impulse": {
        "desc": "",
        "xlocal": "",
        "ylocal": "",
        "ximpulse_local": "",
        "yimpulse_local": ""
    },
	"physics_apply_torque": {
        "desc": "",
        "torque": ""
    },
	"physics_draw_debug": {
        "desc": ""
    },
	"physics_fixture_add_point": {
        "desc": "",
        "fixture": "",
        "local_x": "",
        "local_y": ""
    },
	"physics_fixture_bind": {
        "desc": "",
        "fixture": "",
        "obj": ""
    },
	"physics_fixture_bind_ext": {
        "desc": "",
        "fixture": "",
        "obj": "",
        "xo": "",
        "yo": ""
    },
	"physics_fixture_create": {
        "desc": ""
    },
	"physics_fixture_delete": {
        "desc": "",
        "fixture": ""
    },
	"physics_fixture_set_angular_damping": {
        "desc": "",
        "fixture": "",
        "damping": ""
    },
	"physics_fixture_set_awake": {
        "desc": "",
        "fixture": "",
        "flag": ""
    },
	"physics_fixture_set_box_shape": {
        "desc": "",
        "fixture": "",
        "halfWidth": "",
        "halfHeight": ""
    },
	"physics_fixture_set_chain_shape": {
        "desc": "",
        "fixture": "",
        "loop": ""
    },
	"physics_fixture_set_circle_shape": {
        "desc": "",
        "fixture": "",
        "circleRadius": ""
    },
	"physics_fixture_set_collision_group": {
        "desc": "",
        "fixture": "",
        "group": ""
    },
	"physics_fixture_set_density": {
        "desc": "",
        "fixture": "",
        "density": ""
    },
	"physics_fixture_set_edge_shape": {
        "desc": "",
        "fixture": "",
        "local_x1": "",
        "local_y1": "",
        "local_x2": "",
        "local_y2": ""
    },
	"physics_fixture_set_friction": {
        "desc": "",
        "fixture": "",
        "friction": ""
    },
	"physics_fixture_set_kinematic": {
        "desc": "",
        "fixture": ""
    },
	"physics_fixture_set_linear_damping": {
        "desc": "",
        "fixture": "",
        "damping": ""
    },
	"physics_fixture_set_polygon_shape": {
        "desc": "",
        "fixture": ""
    },
	"physics_fixture_set_restitution": {
        "desc": "",
        "fixture": "",
        "restitution": ""
    },
	"physics_fixture_set_sensor": {
        "desc": "",
        "fixture": "",
        "sensorState": ""
    },
	"physics_get_density": {
        "desc": "",
        "fixture": ""
    },
	"physics_get_friction": {
        "desc": "",
        "fixture": ""
    },
	"physics_get_restitution": {
        "desc": "",
        "fixture": ""
    },
	"physics_joint_delete": {
        "desc": "",
        "joint": ""
    },
	"physics_joint_distance_create": {
        "desc": "",
        "inst1": "",
        "inst2": "",
        "anchor_1_x": "",
        "anchor_1_y": "",
        "anchor_2_x": "",
        "anchor_2_y": "",
        "collideinstances": ""
    },
	"physics_joint_enable_motor": {
        "desc": "",
        "joint": "",
        "motorState": ""
    },
	"physics_joint_friction_create": {
        "desc": "",
        "inst1": "",
        "inst2": "",
        "anchor_x": "",
        "anchor_y": "",
        "max_force": "",
        "max_torque": "",
        "collideinstances": ""
    },
	"physics_joint_gear_create": {
        "desc": "",
        "inst1": "",
        "inst2": "",
        "revoluteJoint": "",
        "prismaticJoint": "",
        "ratio": ""
    },
	"physics_joint_get_value": {
        "desc": "",
        "joint": "",
        "field": ""
    },
	"physics_joint_prismatic_create": {
        "desc": "",
        "inst1": "",
        "inst2": "",
        "anchor_x": "",
        "anchor_y": "",
        "axis_x": "",
        "axis_y": "",
        "lower_translation_limit": "",
        "upper_translation_limit": "",
        "enable_limit": "",
        "max_motor_force": "",
        "motor_speed": "",
        "enable_motor": "",
        "collideinstances": ""
    },
	"physics_joint_pulley_create": {
        "desc": "",
        "inst1": "",
        "inst2": "",
        "anchor_1_x": "",
        "anchor_1_y": "",
        "anchor_2_x": "",
        "anchor_2_y": "",
        "local_anchor_1_x": "",
        "local_anchor_1_y": "",
        "local_anchor_2_x": "",
        "local_anchor_2_y": "",
        "ratio": "",
        "collideinstances": ""
    },
	"physics_joint_revolute_create": {
        "desc": "",
        "inst1": "",
        "inst2": "",
        "anchor_x": "",
        "anchor_y": "",
        "lower_translation_limit": "",
        "upper_translation_limit": "",
        "enable_limit": "",
        "max_motor_force": "",
        "motor_speed": "",
        "enable_motor": "",
        "collideinstances": ""
    },
	"physics_joint_rope_create": {
        "desc": "",
        "inst1": "",
        "inst2": "",
        "anchor_1_x": "",
        "anchor_1_y": "",
        "anchor_2_x": "",
        "anchor_2_y": "",
        "maxLength": "",
        "collideinstances": ""
    },
	"physics_joint_set_value": {
        "desc": "",
        "joint": "",
        "field": "",
        "value": ""
    },
	"physics_joint_weld_create": {
        "desc": "",
        "inst1": "",
        "inst2": "",
        "anchor_x": "",
        "anchor_y": "",
        "ref_angle": "",
        "freq_hz": "",
        "damping_ratio": "",
        "collideinstances": ""
    },
	"physics_joint_wheel_create": {
        "desc": "",
        "inst1": "",
        "inst2": "",
        "anchor_x": "",
        "anchor_y": "",
        "axis_x": "",
        "axis_y": "",
        "enableMotor": "",
        "max_motor_torque": "",
        "motor_speed": "",
        "freq_hz": "",
        "damping_ratio": "",
        "collideinstances": ""
    },
	"physics_mass_properties": {
        "desc": "",
        "mass": "",
        "local_centre_of_mass_x": "",
        "local_centre_of_mass_y": "",
        "inertia": ""
    },
	"physics_particle_count": {
        "desc": ""
    },
	"physics_particle_create": {
        "desc": "",
        "typeflags": "",
        "x": "",
        "y": "",
        "xv": "",
        "yv": "",
        "col": "",
        "alpha": "",
        "category": ""
    },
	"physics_particle_delete": {
        "desc": "",
        "ind": ""
    },
	"physics_particle_delete_region_box": {
        "desc": "",
        "x": "",
        "y": "",
        "halfWidth": "",
        "halfHeight": ""
    },
	"physics_particle_delete_region_circle": {
        "desc": "",
        "x": "",
        "y": "",
        "radius": ""
    },
	"physics_particle_delete_region_poly": {
        "desc": "",
        "pointList": ""
    },
	"physics_particle_draw": {
        "desc": "",
        "typemask": "",
        "category": "",
        "sprite": "",
        "subimg": ""
    },
	"physics_particle_draw_ext": {
        "desc": "",
        "typemask": "",
        "category": "",
        "sprite": "",
        "subimg": "",
        "xscale": "",
        "yscale": "",
        "angle": "",
        "col": "",
        "alpha": ""
    },
	"physics_particle_get_damping": {
        "desc": ""
    },
	"physics_particle_get_data": {
        "desc": "",
        "buffer": "",
        "dataFlags": ""
    },
	"physics_particle_get_data_particle": {
        "desc": "",
        "ind": "",
        "buffer": "",
        "dataFlags": ""
    },
	"physics_particle_get_density": {
        "desc": ""
    },
	"physics_particle_get_gravity_scale": {
        "desc": ""
    },
	"physics_particle_get_group_flags": {
        "desc": "",
        "group": ""
    },
	"physics_particle_get_max_count": {
        "desc": ""
    },
	"physics_particle_get_radius": {
        "desc": ""
    },
	"physics_particle_group_add_point": {
        "desc": "",
        "x": "",
        "y": ""
    },
	"physics_particle_group_begin": {
        "desc": "",
        "typeflags": "",
        "groupflag": "",
        "x": "",
        "y": "",
        "ang": "",
        "xv": "",
        "yv": "",
        "angVelocity": "",
        "col": "",
        "alpha": "",
        "strength": "",
        "category": ""
    },
	"physics_particle_group_box": {
        "desc": "",
        "halfWidth": "",
        "halfHeight": ""
    },
	"physics_particle_group_circle": {
        "desc": "",
        "radius": ""
    },
	"physics_particle_group_count": {
        "desc": "",
        "group": ""
    },
	"physics_particle_group_delete": {
        "desc": "",
        "ind": ""
    },
	"physics_particle_group_end": {
        "desc": ""
    },
	"physics_particle_group_get_angle": {
        "desc": "",
        "group": ""
    },
	"physics_particle_group_get_ang_vel": {
        "desc": "",
        "group": ""
    },
	"physics_particle_group_get_centre_x": {
        "desc": "",
        "group": ""
    },
	"physics_particle_group_get_centre_y": {
        "desc": "",
        "group": ""
    },
	"physics_particle_group_get_data": {
        "desc": "",
        "group": "",
        "buffer": "",
        "dataFlags": ""
    },
	"physics_particle_group_get_inertia": {
        "desc": "",
        "group": ""
    },
	"physics_particle_group_get_mass": {
        "desc": "",
        "group": ""
    },
	"physics_particle_group_get_vel_x": {
        "desc": "",
        "group": ""
    },
	"physics_particle_group_get_vel_y": {
        "desc": "",
        "group": ""
    },
	"physics_particle_group_get_x": {
        "desc": "",
        "group": ""
    },
	"physics_particle_group_get_y": {
        "desc": "",
        "group": ""
    },
	"physics_particle_group_join": {
        "desc": "",
        "to": "",
        "from": ""
    },
	"physics_particle_group_polygon": {
        "desc": ""
    },
	"physics_particle_set_category_flags": {
        "desc": "",
        "catagory": "",
        "typeflags": ""
    },
	"physics_particle_set_damping": {
        "desc": "",
        "damping": ""
    },
	"physics_particle_set_density": {
        "desc": "",
        "density": ""
    },
	"physics_particle_set_flags": {
        "desc": "",
        "ind": "",
        "typeflags": ""
    },
	"physics_particle_set_gravity_scale": {
        "desc": "",
        "scale": ""
    },
	"physics_particle_set_group_flags": {
        "desc": "",
        "group": "",
        "groupflags": ""
    },
	"physics_particle_set_max_count": {
        "desc": "",
        "count": ""
    },
	"physics_particle_set_radius": {
        "desc": "",
        "radius": ""
    },
	"physics_pause_enable": {
        "desc": "",
        "pause": ""
    },
	"physics_remove_fixture": {
        "desc": "",
        "inst": "",
        "id": ""
    },
	"physics_set_density": {
        "desc": "",
        "fixture": "",
        "density": ""
    },
	"physics_set_friction": {
        "desc": "",
        "fixture": "",
        "friction": ""
    },
	"physics_set_restitution": {
        "desc": "",
        "fixture": "",
        "restitution": ""
    },
	"physics_test_overlap": {
        "desc": "",
        "x": "",
        "y": "",
        "angle": "",
        "obj": ""
    },
	"physics_world_create": {
        "desc": "",
        "PixelToMetreScale": ""
    },
	"physics_world_draw_debug": {
        "desc": "",
        "draw_flags": ""
    },
	"physics_world_gravity": {
        "desc": "",
        "gx": "",
        "gy": ""
    },
	"physics_world_update_iterations": {
        "desc": "",
        "iterations": ""
    },
	"physics_world_update_speed": {
        "desc": "",
        "speed": ""
    },
	"place_empty": {
        "desc": "",
        "x": "",
        "y": ""
    },
	"place_free": {
        "desc": "",
        "x": "",
        "y": ""
    },
	"place_meeting": {
        "desc": "",
        "x": "",
        "y": "",
        "obj": ""
    },
	"place_snapped": {
        "desc": "",
        "hsnap": "",
        "vsnap": ""
    },
	"point_direction": {
        "desc": "",
        "x1": "",
        "y1": "",
        "x2": "",
        "y2": ""
    },
	"point_distance": {
        "desc": "",
        "x1": "",
        "y1": "",
        "x2": "",
        "y2": ""
    },
	"point_distance_3d": {
        "desc": "",
        "x1": "",
        "y1": "",
        "z1": "",
        "x2": "",
        "y2": "",
        "z2": ""
    },
	"point_in_circle": {
        "desc": "",
        "px": "",
        "py": "",
        "cx": "",
        "cy": "",
        "rad": ""
    },
	"point_in_rectangle": {
        "desc": "",
        "px": "",
        "py": "",
        "x1": "",
        "y1": "",
        "x2": "",
        "y2": ""
    },
	"point_in_triangle": {
        "desc": "",
        "px": "",
        "py": "",
        "x1": "",
        "y1": "",
        "z1": "",
        "x2": "",
        "y2": "",
        "z2": ""
    },
	"position_change": {
        "desc": "",
        "x": "",
        "y": "",
        "obj": "",
        "performevents": ""
    },
	"position_destroy": {
        "desc": "",
        "x": "",
        "y": ""
    },
	"position_empty": {
        "desc": "",
        "x": "",
        "y": ""
    },
	"position_meeting": {
        "desc": "",
        "x": "",
        "y": "",
        "obj": ""
    },
	"power": {
        "desc": "",
        "x": "",
        "n": ""
    },
	"ptr": {
        "desc": "",
        "val": ""
    },
	"push_cancel_local_notification": {
        "desc": "",
        "id": ""
    },
	"push_get_first_local_notification": {
        "desc": "",
        "ds_map": ""
    },
	"push_get_next_local_notification": {
        "desc": "",
        "ds_map": ""
    },
	"push_local_notification": {
        "desc": "",
        "fire_time": "",
        "title": "",
        "message": "",
        "data": ""
    },
	"radtodeg": {
        "desc": "",
        "x": ""
    },
	"random": {
        "desc": "",
        "x": ""
    },
	"randomize": {
        "desc": ""
    },
	"random_get_seed": {
        "desc": ""
    },
	"random_old": {
        "desc": "",
        "x": ""
    },
	"random_range": {
        "desc": "",
        "x1": "",
        "x2": ""
    },
	"random_range_old": {
        "desc": "",
        "x1": "",
        "x2": ""
    },
	"random_set_seed": {
        "desc": "",
        "seed": ""
    },
	"random_use_old_version": {
        "desc": "",
        "trueFalse": ""
    },
	"real": {
        "desc": "",
        "val": ""
    },
	"rectangle_in_circle": {
        "desc": "",
        "sx1": "",
        "sy1": "",
        "sx2": "",
        "sy2": "",
        "cx": "",
        "cy": "",
        "rad": ""
    },
	"rectangle_in_rectangle": {
        "desc": "",
        "sx1": "",
        "sy1": "",
        "sx2": "",
        "sy2": "",
        "dx1": "",
        "dy1": "",
        "dx2": "",
        "dy2": ""
    },
	"rectangle_in_triangle": {
        "desc": "",
        "sx1": "",
        "sy1": "",
        "sx2": "",
        "sy2": "",
        "x1": "",
        "y1": "",
        "x2": "",
        "y2": "",
        "x3": "",
        "y3": ""
    },
	"room_add": {
        "desc": ""
    },
	"room_assign": {
        "desc": "",
        "ind": "",
        "source": ""
    },
	"room_duplicate": {
        "desc": "",
        "ind": ""
    },
	"room_exists": {
        "desc": "",
        "ind": ""
    },
	"room_get_name": {
        "desc": "",
        "ind": ""
    },
	"room_goto": {
        "desc": "",
        "numb": ""
    },
	"room_goto_next": {
        "desc": ""
    },
	"room_goto_previous": {
        "desc": ""
    },
	"room_instance_add": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "obj": ""
    },
	"room_instance_clear": {
        "desc": "",
        "ind": ""
    },
	"room_next": {
        "desc": "",
        "numb": ""
    },
	"room_previous": {
        "desc": "",
        "numb": ""
    },
	"room_restart": {
        "desc": ""
    },
	"room_set_background_color": {
        "desc": "",
        "ind": "",
        "col": "",
        "show": ""
    },
	"room_set_background_colour": {
        "desc": "",
        "ind": "",
        "col": "",
        "show": ""
    },
	"room_set_height": {
        "desc": "",
        "ind": "",
        "h": ""
    },
	"room_set_persistent": {
        "desc": "",
        "ind": "",
        "pers": ""
    },
	"room_set_view_enabled": {
        "desc": "",
        "ind": "",
        "val": ""
    },
	"room_set_width": {
        "desc": "",
        "ind": "",
        "w": ""
    },
	"round": {
        "desc": "",
        "x": ""
    },
	"screen_save": {
        "desc": "",
        "fname": ""
    },
	"screen_save_part": {
        "desc": "",
        "fname": "",
        "x": "",
        "y": "",
        "w": "",
        "h": ""
    },
	"script_execute": {
        "desc": "",
        "ind": "",
        "arg0": "",
        "arg1": "",
        "more": ""
    },
	"script_exists": {
        "desc": "",
        "ind": ""
    },
	"script_get_name": {
        "desc": "",
        "ind": ""
    },
	"sha1_file": {
        "desc": "",
        "fname": ""
    },
	"sha1_string_unicode": {
        "desc": "",
        "string": ""
    },
	"sha1_string_utf8": {
        "desc": "",
        "string": ""
    },
	"shaders_are_supported": {
        "desc": ""
    },
	"shader_enable_corner_id": {
        "desc": "",
        "enable": ""
    },
	"shader_get_sampler_index": {
        "desc": "",
        "shader": "",
        "uniform_name": ""
    },
	"shader_get_uniform": {
        "desc": "",
        "shader": "",
        "uniform_name": ""
    },
	"shader_is_compiled": {
        "desc": "",
        "shader": ""
    },
	"shader_reset": {
        "desc": ""
    },
	"shader_set": {
        "desc": "",
        "shader": ""
    },
	"shader_set_uniform_f": {
        "desc": "",
        "uniform_id": "",
        "val": "",
        "more": ""
    },
	"shader_set_uniform_f_array": {
        "desc": "",
        "uniform_id": "",
        "array": ""
    },
	"shader_set_uniform_i": {
        "desc": "",
        "uniform_id": "",
        "val": "",
        "more": ""
    },
	"shader_set_uniform_i_array": {
        "desc": "",
        "uniform_id": "",
        "array": ""
    },
	"shader_set_uniform_matrix": {
        "desc": "",
        "uniform_id": ""
    },
	"shader_set_uniform_matrix_array": {
        "desc": "",
        "uniform_id": "",
        "array": ""
    },
	"shop_leave_rating": {
        "desc": "",
        "text_string": "",
        "yes_string": "",
        "no_string": "",
        "url": ""
    },
	"show_debug_message": {
        "desc": "",
        "str": ""
    },
	"show_debug_overlay": {
        "desc": "",
        "bool": ""
    },
	"show_error": {
        "desc": "",
        "str": "",
        "abort": ""
    },
	"show_message": {
        "desc": "",
        "str": ""
    },
	"show_message_async": {
        "desc": "",
        "str": ""
    },
	"show_question": {
        "desc": "",
        "str": ""
    },
	"show_question_async": {
        "desc": "",
        "str": ""
    },
	"sign": {
        "desc": "",
        "x": ""
    },
	"sin": {
        "desc": "",
        "radian_angle": ""
    },
	"skeleton_animation_clear": {
        "desc": "",
        "track": ""
    },
	"skeleton_animation_get": {
        "desc": ""
    },
	"skeleton_animation_get_duration": {
        "desc": "",
        "anim_name": ""
    },
	"skeleton_animation_get_ext": {
        "desc": "",
        "track": ""
    },
	"skeleton_animation_get_frames": {
        "desc": "",
        "anim_name": ""
    },
	"skeleton_animation_list": {
        "desc": "",
        "sprite": "",
        "list": ""
    },
	"skeleton_animation_mix": {
        "desc": "",
        "anim_from": "",
        "anim_to": "",
        "duration": ""
    },
	"skeleton_animation_set": {
        "desc": "",
        "anim_name": ""
    },
	"skeleton_animation_set_ext": {
        "desc": "",
        "anim_name": "",
        "track": ""
    },
	"skeleton_attachment_create": {
        "desc": "",
        "name": "",
        "sprite": "",
        "ind": "",
        "xo": "",
        "yo": "",
        "xs": "",
        "ys": "",
        "ro": ""
    },
	"skeleton_attachment_get": {
        "desc": "",
        "slot": ""
    },
	"skeleton_attachment_set": {
        "desc": "",
        "slot": "",
        "attachment": ""
    },
	"skeleton_bone_data_get": {
        "desc": "",
        "bone": "",
        "map": ""
    },
	"skeleton_bone_data_set": {
        "desc": "",
        "bone": "",
        "map": ""
    },
	"skeleton_bone_state_get": {
        "desc": "",
        "bone": "",
        "map": ""
    },
	"skeleton_bone_state_set": {
        "desc": "",
        "bone": "",
        "map": ""
    },
	"skeleton_collision_draw_set": {
        "desc": "",
        "val": ""
    },
	"skeleton_get_bounds": {
        "desc": "",
        "index": ""
    },
	"skeleton_get_minmax": {
        "desc": ""
    },
	"skeleton_get_num_bounds": {
        "desc": ""
    },
	"skeleton_skin_get": {
        "desc": ""
    },
	"skeleton_skin_list": {
        "desc": "",
        "sprite": "",
        "list": ""
    },
	"skeleton_skin_set": {
        "desc": "",
        "skin_name": ""
    },
	"skeleton_slot_data": {
        "desc": "",
        "sprite": "",
        "list": ""
    },
	"sprite_add": {
        "desc": "",
        "fname": "",
        "imgnumb": "",
        "removeback": "",
        "smooth": "",
        "xorig": "",
        "yorig": ""
    },
	"sprite_add_from_surface": {
        "desc": "",
        "ind": "",
        "id": "",
        "x": "",
        "y": "",
        "w": "",
        "h": "",
        "removeback": "",
        "smooth": ""
    },
	"sprite_assign": {
        "desc": "",
        "ind": "",
        "source": ""
    },
	"sprite_collision_mask": {
        "desc": "",
        "ind": "",
        "sepmasks": "",
        "bboxmode": "",
        "bbleft": "",
        "bbtop": "",
        "bbright": "",
        "bbbottom": "",
        "kind": "",
        "tolerance": ""
    },
	"sprite_create_from_surface": {
        "desc": "",
        "id": "",
        "x": "",
        "y": "",
        "w": "",
        "h": "",
        "removeback": "",
        "smooth": "",
        "xorig": "",
        "yorig": ""
    },
	"sprite_delete": {
        "desc": "",
        "ind": ""
    },
	"sprite_duplicate": {
        "desc": "",
        "ind": ""
    },
	"sprite_exists": {
        "desc": "",
        "ind": ""
    },
	"sprite_flush": {
        "desc": "",
        "ind": ""
    },
	"sprite_flush_multi": {
        "desc": "",
        "indarray": ""
    },
	"sprite_get_bbox_bottom": {
        "desc": "",
        "ind": ""
    },
	"sprite_get_bbox_left": {
        "desc": "",
        "ind": ""
    },
	"sprite_get_bbox_right": {
        "desc": "",
        "ind": ""
    },
	"sprite_get_bbox_top": {
        "desc": "",
        "ind": ""
    },
	"sprite_get_height": {
        "desc": "",
        "ind": ""
    },
	"sprite_get_name": {
        "desc": "",
        "ind": ""
    },
	"sprite_get_number": {
        "desc": "",
        "ind": ""
    },
	"sprite_get_texture": {
        "desc": "",
        "spr": "",
        "subimg": ""
    },
	"sprite_get_tpe": {
        "desc": "",
        "index": "",
        "subindex": ""
    },
	"sprite_get_uvs": {
        "desc": "",
        "spr": "",
        "subimg": ""
    },
	"sprite_get_width": {
        "desc": "",
        "ind": ""
    },
	"sprite_get_xoffset": {
        "desc": "",
        "ind": ""
    },
	"sprite_get_yoffset": {
        "desc": "",
        "ind": ""
    },
	"sprite_merge": {
        "desc": "",
        "ind1": "",
        "ind2": ""
    },
	"sprite_prefetch": {
        "desc": "",
        "ind": ""
    },
	"sprite_prefetch_multi": {
        "desc": "",
        "indarray": ""
    },
	"sprite_replace": {
        "desc": "",
        "ind": "",
        "fname": "",
        "imgnumb": "",
        "removeback": "",
        "smooth": "",
        "xorig": "",
        "yorig": ""
    },
	"sprite_save": {
        "desc": "",
        "ind": "",
        "subimg": "",
        "fname": ""
    },
	"sprite_save_strip": {
        "desc": "",
        "ind": "",
        "fname": ""
    },
	"sprite_set_alpha_from_sprite": {
        "desc": "",
        "ind": "",
        "spr": ""
    },
	"sprite_set_cache_size": {
        "desc": "",
        "ind": "",
        "max": ""
    },
	"sprite_set_cache_size_ext": {
        "desc": "",
        "ind": "",
        "image": "",
        "max": ""
    },
	"sprite_set_offset": {
        "desc": "",
        "ind": "",
        "xoff": "",
        "yoff": ""
    },
	"sqr": {
        "desc": "",
        "x": ""
    },
	"sqrt": {
        "desc": "",
        "x": ""
    },
	"steam_activate_overlay": {
        "desc": "",
        "overlayIndex": ""
    },
	"steam_activate_overlay_browser": {
        "desc": "",
        "url": ""
    },
	"steam_activate_overlay_store": {
        "desc": "",
        "app_id": ""
    },
	"steam_activate_overlay_user": {
        "desc": "",
        "dialog_name": "",
        "steamid": ""
    },
	"steam_available_languages": {
        "desc": ""
    },
	"steam_clear_achievement": {
        "desc": "",
        "ach_name": ""
    },
	"steam_create_leaderboard": {
        "desc": "",
        "lb_name": "",
        "sort_method": "",
        "display_type": ""
    },
	"steam_current_game_language": {
        "desc": ""
    },
	"steam_download_friends_scores": {
        "desc": "",
        "lb_name": ""
    },
	"steam_download_scores": {
        "desc": "",
        "lb_name": "",
        "start_idx": "",
        "end_idx": ""
    },
	"steam_download_scores_around_user": {
        "desc": "",
        "lb_name": "",
        "range_start": "",
        "range_end": ""
    },
	"steam_file_delete": {
        "desc": "",
        "filename": ""
    },
	"steam_file_exists": {
        "desc": "",
        "filename": ""
    },
	"steam_file_persisted": {
        "desc": "",
        "filename": ""
    },
	"steam_file_read": {
        "desc": "",
        "filename": ""
    },
	"steam_file_share": {
        "desc": "",
        "filename": ""
    },
	"steam_file_size": {
        "desc": "",
        "filename": ""
    },
	"steam_file_write": {
        "desc": "",
        "steam_filename": "",
        "data": "",
        "size": ""
    },
	"steam_file_write_file": {
        "desc": "",
        "steam_filename": "",
        "local_filename": ""
    },
	"steam_get_achievement": {
        "desc": "",
        "ach_name": ""
    },
	"steam_get_app_id": {
        "desc": ""
    },
	"steam_get_persona_name": {
        "desc": ""
    },
	"steam_get_quota_free": {
        "desc": ""
    },
	"steam_get_quota_total": {
        "desc": ""
    },
	"steam_get_stat_avg_rate": {
        "desc": "",
        "stat_name": ""
    },
	"steam_get_stat_float": {
        "desc": "",
        "stat_name": ""
    },
	"steam_get_stat_int": {
        "desc": "",
        "stat_name": ""
    },
	"steam_get_user_account_id": {
        "desc": ""
    },
	"steam_get_user_persona_name": {
        "desc": "",
        "steam_id": ""
    },
	"steam_get_user_steam_id": {
        "desc": ""
    },
	"steam_initialised": {
        "desc": ""
    },
	"steam_is_cloud_enabled_for_account": {
        "desc": ""
    },
	"steam_is_cloud_enabled_for_app": {
        "desc": ""
    },
	"steam_is_overlay_activated": {
        "desc": ""
    },
	"steam_is_overlay_enabled": {
        "desc": ""
    },
	"steam_is_screenshot_requested": {
        "desc": ""
    },
	"steam_is_user_logged_on": {
        "desc": ""
    },
	"steam_publish_workshop_file": {
        "desc": "",
        "filename": "",
        "previewImage": "",
        "title": "",
        "description": ""
    },
	"steam_reset_all_stats": {
        "desc": ""
    },
	"steam_reset_all_stats_achievements": {
        "desc": ""
    },
	"steam_send_screenshot": {
        "desc": "",
        "filename": "",
        "width": "",
        "height": ""
    },
	"steam_set_achievement": {
        "desc": "",
        "ach_name": ""
    },
	"steam_set_stat_avg_rate": {
        "desc": "",
        "stat_name": "",
        "session_count": "",
        "session_length": ""
    },
	"steam_set_stat_float": {
        "desc": "",
        "stat_name": "",
        "value": ""
    },
	"steam_set_stat_int": {
        "desc": "",
        "stat_name": "",
        "value": ""
    },
	"steam_stats_ready": {
        "desc": ""
    },
	"steam_ugc_create_item": {
        "desc": "",
        "consumer_app_id": "",
        "file_type": ""
    },
	"steam_ugc_create_query_all": {
        "desc": "",
        "query_type": "",
        "match_type": "",
        "page": ""
    },
	"steam_ugc_create_query_all_ex": {
        "desc": "",
        "query_type": "",
        "match_type": "",
        "page": "",
        "creator_app_id": "",
        "consumer_app_id": ""
    },
	"steam_ugc_create_query_user": {
        "desc": "",
        "list_type": "",
        "match_type": "",
        "sort_order": "",
        "page": ""
    },
	"steam_ugc_create_query_user_ex": {
        "desc": "",
        "list_type": "",
        "match_type": "",
        "sort_order": "",
        "page": "",
        "account_id": "",
        "creator_app_id": "",
        "consumer_app_id": ""
    },
	"steam_ugc_download": {
        "desc": "",
        "ugc_handle": "",
        "dest_filename": ""
    },
	"steam_ugc_get_item_install_info": {
        "desc": "",
        "published_file_id": "",
        "info_map": ""
    },
	"steam_ugc_get_item_update_info": {
        "desc": "",
        "published_file_id": "",
        "info_map": ""
    },
	"steam_ugc_get_item_update_progress": {
        "desc": "",
        "ugc_update_handle": "",
        "info_map": ""
    },
	"steam_ugc_get_subscribed_items": {
        "desc": "",
        "info_map": ""
    },
	"steam_ugc_num_subscribed_items": {
        "desc": ""
    },
	"steam_ugc_query_add_excluded_tag": {
        "desc": "",
        "ugc_query_handle": "",
        "tag_name": ""
    },
	"steam_ugc_query_add_required_tag": {
        "desc": "",
        "ugc_query_handle": "",
        "tag_name": ""
    },
	"steam_ugc_query_set_allow_cached_response": {
        "desc": "",
        "ugc_query_handle": "",
        "max_age_seconds": ""
    },
	"steam_ugc_query_set_cloud_filename_filter": {
        "desc": "",
        "ugc_query_handle": "",
        "match_cloud_filename": ""
    },
	"steam_ugc_query_set_match_any_tag": {
        "desc": "",
        "ugc_query_handle": "",
        "match_any_tag": ""
    },
	"steam_ugc_query_set_ranked_by_trend_days": {
        "desc": "",
        "ugc_query_handle": "",
        "days": ""
    },
	"steam_ugc_query_set_return_long_description": {
        "desc": "",
        "ugc_query_handle": "",
        "return_long_desc": ""
    },
	"steam_ugc_query_set_return_total_only": {
        "desc": "",
        "ugc_query_handle": "",
        "return_total_only": ""
    },
	"steam_ugc_query_set_search_text": {
        "desc": "",
        "ugc_query_handle": "",
        "search_text": ""
    },
	"steam_ugc_request_item_details": {
        "desc": "",
        "published_file_id": "",
        "max_age_seconds": ""
    },
	"steam_ugc_send_query": {
        "desc": "",
        "ugc_query_handle": ""
    },
	"steam_ugc_set_item_content": {
        "desc": "",
        "ugc_update_handle": "",
        "directory": ""
    },
	"steam_ugc_set_item_description": {
        "desc": "",
        "ugc_update_handle": "",
        "description": ""
    },
	"steam_ugc_set_item_preview": {
        "desc": "",
        "ugc_update_handle": "",
        "image_path": ""
    },
	"steam_ugc_set_item_tags": {
        "desc": "",
        "ugc_update_handle": "",
        "tag_array": ""
    },
	"steam_ugc_set_item_title": {
        "desc": "",
        "ugc_update_handle": "",
        "title": ""
    },
	"steam_ugc_set_item_visibility": {
        "desc": "",
        "ugc_update_handle": "",
        "visibility": ""
    },
	"steam_ugc_start_item_update": {
        "desc": "",
        "consumer_app_id": "",
        "published_file_id": ""
    },
	"steam_ugc_submit_item_update": {
        "desc": "",
        "ugc_update_handle": "",
        "change_note": ""
    },
	"steam_ugc_subscribe_item": {
        "desc": "",
        "published_file_id": ""
    },
	"steam_ugc_unsubscribe_item": {
        "desc": "",
        "published_file_id": ""
    },
	"steam_upload_score": {
        "desc": "",
        "lb_name": "",
        "score": ""
    },
	"steam_upload_score_buffer": {
        "desc": "",
        "lb_name": "",
        "score": "",
        "buffer_id": ""
    },
	"steam_upload_score_buffer_ext": {
        "desc": "",
        "lb_name": "",
        "score": "",
        "buffer_id": "",
        "forceupdate": ""
    },
	"steam_upload_score_ext": {
        "desc": "",
        "lb_name": "",
        "score": "",
        "forceupdate": ""
    },
	"steam_user_installed_dlc": {
        "desc": "",
        "dlc_id": ""
    },
	"steam_user_owns_dlc": {
        "desc": "",
        "dlc_id": ""
    },
	"string": {
        "desc": "",
        "val": ""
    },
	"string_byte_at": {
        "desc": "",
        "str": "",
        "index": ""
    },
	"string_byte_length": {
        "desc": "",
        "str": ""
    },
	"string_char_at": {
        "desc": "",
        "str": "",
        "index": ""
    },
	"string_copy": {
        "desc": "",
        "str": "",
        "index": "",
        "count": ""
    },
	"string_count": {
        "desc": "",
        "substr": "",
        "str": ""
    },
	"string_delete": {
        "desc": "",
        "str": "",
        "index": "",
        "count": ""
    },
	"string_digits": {
        "desc": "",
        "str": ""
    },
	"string_format": {
        "desc": "",
        "val": "",
        "total": "",
        "dec": ""
    },
	"string_height": {
        "desc": "",
        "string": ""
    },
	"string_height_ext": {
        "desc": "",
        "string": "",
        "sep": "",
        "w": ""
    },
	"string_insert": {
        "desc": "",
        "substr": "",
        "str": "",
        "index": ""
    },
	"string_length": {
        "desc": "",
        "str": ""
    },
	"string_letters": {
        "desc": "",
        "str": ""
    },
	"string_lettersdigits": {
        "desc": "",
        "str": ""
    },
	"string_lower": {
        "desc": "",
        "str": ""
    },
	"string_ord_at": {
        "desc": "",
        "str": "",
        "index": ""
    },
	"string_pos": {
        "desc": "",
        "substr": "",
        "str": ""
    },
	"string_repeat": {
        "desc": "",
        "str": "",
        "count": ""
    },
	"string_replace": {
        "desc": "",
        "str": "",
        "substr": "",
        "newstr": ""
    },
	"string_replace_all": {
        "desc": "",
        "str": "",
        "substr": "",
        "newstr": ""
    },
	"string_set_byte_at": {
        "desc": "",
        "str": "",
        "index": "",
        "val": ""
    },
	"string_upper": {
        "desc": "",
        "str": ""
    },
	"string_width": {
        "desc": "",
        "string": ""
    },
	"string_width_ext": {
        "desc": "",
        "string": "",
        "sep": "",
        "w": ""
    },
	"surface_copy": {
        "desc": "",
        "destination": "",
        "x": "",
        "y": "",
        "source": ""
    },
	"surface_copy_part": {
        "desc": "",
        "destination": "",
        "x": "",
        "y": "",
        "source": "",
        "xs": "",
        "ys": "",
        "ws": "",
        "hs": ""
    },
	"surface_create": {
        "desc": "",
        "w": "",
        "h": ""
    },
	"surface_create_ext": {
        "desc": "",
        "name": "",
        "w": "",
        "h": ""
    },
	"surface_exists": {
        "desc": "",
        "id": ""
    },
	"surface_free": {
        "desc": "",
        "id": ""
    },
	"surface_getpixel": {
        "desc": "",
        "id": "",
        "x": "",
        "y": ""
    },
	"surface_getpixel_ext": {
        "desc": "",
        "id": "",
        "x": "",
        "y": ""
    },
	"surface_get_height": {
        "desc": "",
        "id": ""
    },
	"surface_get_texture": {
        "desc": "",
        "id": ""
    },
	"surface_get_width": {
        "desc": "",
        "id": ""
    },
	"surface_reset_target": {
        "desc": ""
    },
	"surface_resize": {
        "desc": "",
        "id": "",
        "width": "",
        "height": ""
    },
	"surface_save": {
        "desc": "",
        "id": "",
        "fname": ""
    },
	"surface_save_part": {
        "desc": "",
        "id": "",
        "fname": "",
        "x": "",
        "y": "",
        "w": "",
        "h": ""
    },
	"surface_set_target": {
        "desc": "",
        "id": ""
    },
	"surface_set_target_ext": {
        "desc": "",
        "index": "",
        "id": ""
    },
	"tan": {
        "desc": "",
        "radian_angle": ""
    },
	"texture_get_height": {
        "desc": "",
        "texid": ""
    },
	"texture_get_texel_height": {
        "desc": "",
        "texture_id": ""
    },
	"texture_get_texel_width": {
        "desc": "",
        "texture_id": ""
    },
	"texture_get_width": {
        "desc": "",
        "texid": ""
    },
	"texture_global_scale": {
        "desc": "",
        "pow2integer": ""
    },
	"texture_set_blending": {
        "desc": "",
        "blend": ""
    },
	"texture_set_interpolation": {
        "desc": "",
        "linear": ""
    },
	"texture_set_interpolation_ext": {
        "desc": "",
        "sampler_id": "",
        "linear": ""
    },
	"texture_set_repeat": {
        "desc": "",
        "repeat": ""
    },
	"texture_set_repeat_ext": {
        "desc": "",
        "sampler_id": "",
        "repeat": ""
    },
	"texture_set_stage": {
        "desc": "",
        "sampler_id": "",
        "texture_id": ""
    },
	"timeline_add": {
        "desc": ""
    },
	"timeline_clear": {
        "desc": "",
        "ind": ""
    },
	"timeline_delete": {
        "desc": "",
        "ind": ""
    },
	"timeline_exists": {
        "desc": "",
        "ind": ""
    },
	"timeline_get_name": {
        "desc": "",
        "ind": ""
    },
	"timeline_max_moment": {
        "desc": "",
        "ind": ""
    },
	"timeline_moment_add_script": {
        "desc": "",
        "id": "",
        "step": "",
        "script": ""
    },
	"timeline_moment_clear": {
        "desc": "",
        "id": "",
        "step": ""
    },
	"timeline_size": {
        "desc": "",
        "ind": ""
    },
	"typeof": {
        "desc": "",
        "val": ""
    },
	"url_get_domain": {
        "desc": ""
    },
	"url_open": {
        "desc": "",
        "url": ""
    },
	"url_open_ext": {
        "desc": "",
        "url": "",
        "target": ""
    },
	"url_open_full": {
        "desc": "",
        "url": "",
        "target": "",
        "options": ""
    },
	"vertex_argb": {
        "desc": "",
        "vbuff": "",
        "argb": ""
    },
	"vertex_begin": {
        "desc": "",
        "vbuff": "",
        "format": ""
    },
	"vertex_color": {
        "desc": "",
        "vbuff": "",
        "color": "",
        "alpha": ""
    },
	"vertex_colour": {
        "desc": "",
        "vbuff": "",
        "colour": "",
        "alpha": ""
    },
	"vertex_create_buffer": {
        "desc": ""
    },
	"vertex_create_buffer_ext": {
        "desc": "",
        "size": ""
    },
	"vertex_create_buffer_from_buffer": {
        "desc": "",
        "src_buffer": "",
        "format": ""
    },
	"vertex_create_buffer_from_buffer_ext": {
        "desc": "",
        "src_buffer": "",
        "format": "",
        "src_offset": "",
        "num_vertices": ""
    },
	"vertex_delete_buffer": {
        "desc": "",
        "vbuff": ""
    },
	"vertex_end": {
        "desc": "",
        "vbuff": ""
    },
	"vertex_float1": {
        "desc": "",
        "vbuff": "",
        "f1": ""
    },
	"vertex_float2": {
        "desc": "",
        "vbuff": "",
        "f1": "",
        "f2": ""
    },
	"vertex_float3": {
        "desc": "",
        "vbuff": "",
        "f1": "",
        "f2": "",
        "f3": ""
    },
	"vertex_float4": {
        "desc": "",
        "vbuff": "",
        "f1": "",
        "f2": "",
        "f3": "",
        "f4": ""
    },
	"vertex_format_add_color": {
        "desc": ""
    },
	"vertex_format_add_colour": {
        "desc": ""
    },
	"vertex_format_add_custom": {
        "desc": "",
        "type": "",
        "usage": ""
    },
	"vertex_format_add_normal": {
        "desc": ""
    },
	"vertex_format_add_position": {
        "desc": ""
    },
	"vertex_format_add_position_3d": {
        "desc": ""
    },
	"vertex_format_add_textcoord": {
        "desc": ""
    },
	"vertex_format_begin": {
        "desc": ""
    },
	"vertex_format_delete": {
        "desc": "",
        "format_id": ""
    },
	"vertex_format_end": {
        "desc": ""
    },
	"vertex_freeze": {
        "desc": "",
        "vbuff": ""
    },
	"vertex_get_buffer_size": {
        "desc": "",
        "vbuff": ""
    },
	"vertex_get_number": {
        "desc": "",
        "vbuff": ""
    },
	"vertex_normal": {
        "desc": "",
        "vbuff": "",
        "nx": "",
        "ny": "",
        "nz": ""
    },
	"vertex_position": {
        "desc": "",
        "vbuff": "",
        "x": "",
        "y": ""
    },
	"vertex_position_3d": {
        "desc": "",
        "vbuff": "",
        "x": "",
        "y": "",
        "z": ""
    },
	"vertex_submit": {
        "desc": "",
        "vbuff": "",
        "prim": "",
        "texture": ""
    },
	"vertex_texcoord": {
        "desc": "",
        "vbuff": "",
        "u": "",
        "v": ""
    },
	"vertex_ubyte4": {
        "desc": "",
        "vbuff": "",
        "b1": "",
        "b2": "",
        "b3": "",
        "b4": ""
    },
	"virtual_key_add": {
        "desc": "",
        "x": "",
        "y": "",
        "w": "",
        "h": "",
        "keycode": ""
    },
	"virtual_key_delete": {
        "desc": "",
        "id": ""
    },
	"virtual_key_hide": {
        "desc": "",
        "id": ""
    },
	"virtual_key_show": {
        "desc": "",
        "id": ""
    },
	"window_center": {
        "desc": ""
    },
	"window_device": {
        "desc": ""
    },
	"window_get_caption": {
        "desc": ""
    },
	"window_get_color": {
        "desc": ""
    },
	"window_get_colour": {
        "desc": ""
    },
	"window_get_cursor": {
        "desc": ""
    },
	"window_get_fullscreen": {
        "desc": ""
    },
	"window_get_height": {
        "desc": ""
    },
	"window_get_visible_rects": {
        "desc": "",
        "x1": "",
        "y1": "",
        "x2": "",
        "y2": ""
    },
	"window_get_width": {
        "desc": ""
    },
	"window_get_x": {
        "desc": ""
    },
	"window_get_y": {
        "desc": ""
    },
	"window_handle": {
        "desc": ""
    },
	"window_has_focus": {
        "desc": ""
    },
	"window_mouse_get_x": {
        "desc": ""
    },
	"window_mouse_get_y": {
        "desc": ""
    },
	"window_mouse_set": {
        "desc": "",
        "x": "",
        "y": ""
    },
	"window_set_caption": {
        "desc": "",
        "caption": ""
    },
	"window_set_color": {
        "desc": "",
        "color": ""
    },
	"window_set_colour": {
        "desc": "",
        "colour": ""
    },
	"window_set_cursor": {
        "desc": "",
        "curs": ""
    },
	"window_set_fullscreen": {
        "desc": "",
        "full": ""
    },
	"window_set_max_height": {
        "desc": "",
        "maxheight": ""
    },
	"window_set_max_width": {
        "desc": "",
        "maxwidth": ""
    },
	"window_set_min_height": {
        "desc": "",
        "minheight": ""
    },
	"window_set_min_width": {
        "desc": "",
        "minwidth": ""
    },
	"window_set_position": {
        "desc": "",
        "x": "",
        "y": ""
    },
	"window_set_rectangle": {
        "desc": "",
        "x": "",
        "y": "",
        "w": "",
        "h": ""
    },
	"window_set_size": {
        "desc": "",
        "w": "",
        "h": ""
    },
	"window_views_mouse_get_x": {
        "desc": ""
    },
	"window_views_mouse_get_y": {
        "desc": ""
    },
	"window_view_mouse_get_x": {
        "desc": "",
        "id": ""
    },
	"window_view_mouse_get_y": {
        "desc": "",
        "id": ""
    },
	"zip_unzip": {
        "desc": "",
        "file": "",
        "destPath": ""
    },

    "variable_global_exists": {
        "desc": "",
        "name": ""
    },
	"variable_global_get": {
        "desc": "",
        "name": ""
    },
	"variable_global_set": {
        "desc": "",
        "name": "",
        "value": ""
    },
	"variable_instance_exists": {
        "desc": "",
        "instance_id": "",
        "name": ""
    },
	"variable_instance_get": {
        "desc": "",
        "instance_id": "",
        "name": ""
    },
	"variable_instance_set": {
        "desc": "",
        "instance_id": "",
        "name": "",
        "val": ""
    },
	"variable_instance_get_names": {
        "desc": "",
        "instance_id": ""
    },

    "pocketchange_display_reward": {
        "desc": ""
    },
	"pocketchange_display_shop": {
        "desc": ""
    },
	"iap_store_status": {
        "desc": ""
    },
	"iap_product_status": {
        "desc": "",
        "product_id": ""
    },
	"iap_is_downloaded": {
        "desc": "",
        "product_id_string": ""
    },
	"iap_files_purchased": {
        "desc": ""
    },
	"iap_product_files": {
        "desc": "",
        "product_id": "",
        "ds_list": ""
    },
	"iap_event_queue": {
        "desc": ""
    },
    "win8_appbar_add_element": {
        "desc": "",
        "type": "",
        "icon": "",
        "label": "",
        "section": "",
        "toolTip": "",
        "callback": ""
    },
	"win8_appbar_enable": {
        "desc": "",
        "flag": ""
    },
	"win8_appbar_remove_element": {
        "desc": "",
        "id": ""
    },
	"win8_device_touchscreen_available": {
        "desc": ""
    },
	"win8_license_initialize_sandbox": {
        "desc": "",
        "licenseString": ""
    },
	"win8_license_trial_version": {
        "desc": ""
    },
	"win8_livetile_badge_clear": {
        "desc": ""
    },
	"win8_livetile_badge_notification": {
        "desc": "",
        "id": ""
    },
	"win8_livetile_notification_begin": {
        "desc": "",
        "template": ""
    },
	"win8_livetile_notification_end": {
        "desc": ""
    },
	"win8_livetile_notification_expiry": {
        "desc": "",
        "expiryTime": ""
    },
	"win8_livetile_notification_image_add": {
        "desc": "",
        "image": ""
    },
	"win8_livetile_notification_secondary_begin": {
        "desc": "",
        "template": "",
        "tileid": ""
    },
	"win8_livetile_notification_tag": {
        "desc": "",
        "tag": ""
    },
	"win8_livetile_notification_text_add": {
        "desc": "",
        "text": ""
    },
	"win8_livetile_queue_enable": {
        "desc": "",
        "flag": ""
    },
	"win8_livetile_tile_clear": {
        "desc": ""
    },
	"win8_livetile_tile_notification": {
        "desc": "",
        "template": "",
        "ds_map": "",
        "expiry": "",
        "tag": ""
    },
	"win8_search_add_suggestions": {
        "desc": "",
        "dslist": ""
    },
	"win8_search_disable": {
        "desc": ""
    },
	"win8_search_enable": {
        "desc": "",
        "selectionCallback": ""
    },
	"win8_secondarytile_badge_notification": {
        "desc": "",
        "id": "",
        "tileid": ""
    },
	"win8_secondarytile_delete": {
        "desc": "",
        "id": ""
    },
	"win8_secondarytile_pin": {
        "desc": "",
        "id": "",
        "shortName": "",
        "displayName": "",
        "cmdLineArgs": "",
        "dsListOptions": "",
        "tileImg": "",
        "wideTileImg": "",
        "textCol": ""
    },
	"win8_settingscharm_add_entry": {
        "desc": "",
        "name": "",
        "callback": ""
    },
	"win8_settingscharm_add_html_entry": {
        "desc": "",
        "id": "",
        "name": "",
        "htmlPath": ""
    },
	"win8_settingscharm_add_xaml_entry": {
        "desc": "",
        "name": "",
        "xamlPath": "",
        "headerRGB": "",
        "callback": "",
        "wideFlyout": ""
    },
	"win8_settingscharm_get_xaml_property": {
        "desc": "",
        "entryName": "",
        "elementName": "",
        "propertyName": ""
    },
	"win8_settingscharm_remove_entry": {
        "desc": "",
        "name": ""
    },
	"win8_settingscharm_set_xaml_property": {
        "desc": "",
        "entryName": "",
        "elementName": "",
        "propertyName": "",
        "newValue": ""
    },
	"win8_share_file": {
        "desc": "",
        "filename": "",
        "title": "",
        "description": "",
        "immediate": ""
    },
	"win8_share_image": {
        "desc": "",
        "image_filename": "",
        "title": "",
        "description": "",
        "immediate": ""
    },
	"win8_share_screenshot": {
        "desc": "",
        "entryName": "",
        "description": "",
        "immediate": ""
    },
	"win8_share_text": {
        "desc": "",
        "text": "",
        "title": "",
        "description": "",
        "immediate": ""
    },
	"win8_share_url": {
        "desc": "",
        "url": "",
        "title": "",
        "description": "",
        "immediate": ""
    },
    "winphone_license_trial_version": {
        "desc": ""
    },
	"winphone_tile_background_color": {
        "desc": "",
        "color": ""
    },
	"winphone_tile_background_colour": {
        "desc": "",
        "colour": ""
    },
	"winphone_tile_back_content": {
        "desc": "",
        "content": ""
    },
	"winphone_tile_back_content_wide": {
        "desc": "",
        "content": ""
    },
	"winphone_tile_back_image": {
        "desc": "",
        "included_filename": ""
    },
	"winphone_tile_back_image_wide": {
        "desc": "",
        "included_filename": ""
    },
	"winphone_tile_back_title": {
        "desc": "",
        "title": ""
    },
	"winphone_tile_count": {
        "desc": "",
        "count": ""
    },
	"winphone_tile_cycle_images": {
        "desc": "",
        "included_filename_1": "",
        "included_filename_2": "",
        "more": ""
    },
	"winphone_tile_front_image": {
        "desc": "",
        "included_filename": ""
    },
	"winphone_tile_front_image_small": {
        "desc": "",
        "included_filename": ""
    },
	"winphone_tile_front_image_wide": {
        "desc": "",
        "included_filename": ""
    },
	"winphone_tile_icon_image": {
        "desc": "",
        "included_filename": ""
    },
	"winphone_tile_small_background_image": {
        "desc": "",
        "included_filename": ""
    },
	"winphone_tile_small_icon_image": {
        "desc": "",
        "included_filename": ""
    },
	"winphone_tile_title": {
        "desc": "",
        "title": ""
    },
	"winphone_tile_wide_content": {
        "desc": "",
        "content": "",
        "index": ""
    },
    "device_ios_get_image": {
        "desc": ""
    },
	"device_ios_get_imagename": {
        "desc": ""
    },
    "sound_delete": {
        "desc": "",
        "ind": ""
    },
    "sound_discard": {
        "desc": "",
        "ind": ""
    },
    "sound_exists": {
        "desc": "",
        "ind": ""
    },
    "sound_get_kind": {
        "desc": "",
        "ind": ""
    },
	"sound_get_name": {
        "desc": "",
        "ind": ""
    },
	"sound_get_preload": {
        "desc": "",
        "ind": ""
    },
    "sound_restore": {
        "desc": "",
        "ind": ""
    },
    "sound_loop": {
        "desc": "",
        "index": ""
    },
    "sound_play": {
        "desc": "",
        "index": ""
    },
    "sound_stop": {
        "desc": "",
        "index": ""
    },
	"sound_stop_all": {
        "desc": ""
    },
	"sound_volume": {
        "desc": "",
        "index": "",
        "value": ""
    },
	"sound_global_volume": {
        "desc": "",
        "value": ""
    },
	"sound_fade": {
        "desc": "",
        "index": "",
        "value": "",
        "time": ""
    },
	"sound_isplaying": {
        "desc": "",
        "index": ""
    },
    "audio_music_is_playing": {
        "desc": ""
    },
    "audio_resume_music": {
        "desc": ""
    },
    "audio_pause_music": {
        "desc": ""
    },
	"audio_play_music": {
        "desc": "",
        "index": "",
        "loops": ""
    },
	"audio_stop_music": {
        "desc": ""
    },
	"audio_music_gain": {
        "desc": "",
        "value": "",
        "time": ""
    },
	"ads_disable": {
        "desc": "",
        "num": ""
	},
	"ads_enable": {
        "desc": "",
        "x": "",
        "y": "",
        "num": ""
	},
	"ads_engagement_active": {
		"desc": ""
	},
	"ads_engagement_available": {
		"desc": ""
	},
	"ads_engagement_launch": {
		"desc": ""
	},
	"ads_event": {
        "desc": "",
        "stringid": ""
	},
	"ads_event_preload": {
        "desc": "",
        "stringid": ""
	},
	"ads_get_display_height": {
        "desc": "",
        "slotnum": ""
	},
	"ads_get_display_width": {
        "desc": "",
        "slotnum": ""
	},
	"ads_interstitial_available": {
		"desc": ""
	},
	"ads_interstitial_display": {
		"desc": ""
	},
	"ads_move": {
        "desc": "",
        "x": "",
        "y": "",
        "slotnum": ""
    },
	"ads_setup": {
        "desc": "",
        "user_uuid": "",
        "ad_app_key": ""
	},
	"ads_set_reward_callback": {
        "desc": "",
        "callback": ""
	},
    "playhaven_add_notification_badge": {
        "desc": "",
        "x": "",
        "y": "",
        "w": "",
        "h": "",
        "ident": ""
    },
	"playhaven_hide_notification_badge": {
        "desc": "",
        "x": "",
        "y": "",
        "w": "",
        "h": "",
        "ident": ""
    },
	"playhaven_position_notification_badge": {
        "desc": "",
        "x": "",
        "y": "",
        "w": "",
        "h": ""
    },
	"playhaven_update_notification_badge": {
        "desc": "",
        "x": "",
        "y": "",
        "w": "",
        "h": ""
    },
    "openfeint_accept_challenge": {
        "desc": ""
    },
	"openfeint_send_challenge": {
        "desc": "",
        "definition_string": "",
        "text_string": "",
        "data_string": ""
    },
	"openfeint_send_invite": {
        "desc": "",
        "definition_string": ""
    },
	"openfeint_send_result": {
        "desc": "",
        "challenge_result": "",
        "definition_string": ""
    },
	"openfeint_send_social": {
        "desc": "",
        "text_string": "",
        "suggested_message": "",
        "image_name": ""
    },
	"openfeint_set_url": {
        "desc": "",
        "url": ""
    },
	"openfeint_start": {
        "desc": ""
    },
	"achievement_map_achievement": {
        "desc": "",
        "gamecenter_string": "",
        "openfeint_string": ""
	},
	"achievement_map_leaderboard": {
        "desc": "",
        "gamecenter_string": "",
        "openfeint_string": "",
        "leaderboard_type": ""
	},
	"achievement_is_online": {
		"desc": ""
    },
    
    "background_add": {
        "desc": "",
        "fname": "",
        "removeback": "",
        "smooth": ""
    },
    "background_assign": {
        "desc": "",
        "ind": "",
        "source": ""
    },
    "background_create_color": {
        "desc": "",
        "w": "",
        "h": "",
        "col": ""
    },
    "background_create_colour": {
        "desc": "",
        "w": "",
        "h": "",
        "col": ""
    },
    "background_create_from_surface": {
        "desc": "",
        "id": "",
        "x": "",
        "y": "",
        "w": "",
        "h": "",
        "removeback": "",
        "smooth": ""
    },
    "background_create_gradient": {
        "desc": "",
        "w": "",
        "h": "",
        "col1": "",
        "col2": "",
        "kind": ""
    },
    "background_delete": {
        "desc": "",
        "ind": ""
    },
    "background_duplicate": {
        "desc": "",
        "ind": ""
    },
    "background_exists": {
        "desc": "",
        "ind": ""
    },
    "background_flush": {
        "desc": "",
        "ind": ""
    },
    "background_flush_multi": {
        "desc": "",
        "indarray": ""
    },
    "background_get_height": {
        "desc": "",
        "ind": ""
    },
    "background_get_name": {
        "desc": "",
        "ind": ""
    },
    "background_get_texture": {
        "desc": "",
        "back": ""
    },
    "background_get_uvs": {
        "desc": "",
        "back": ""
    },
    "background_get_width": {
        "desc": "",
        "ind": ""
    },
    "background_prefetch": {
        "desc": "",
        "ind": ""
    },
    "background_prefetch_multi": {
        "desc": "",
        "indarray": ""
    },
    "background_replace": {
        "desc": "",
        "ind": "",
        "fname": "",
        "removeback": "",
        "smooth": ""
    },
    "background_replace_background": {
        "desc": "",
        "ind": "",
        "fname": ""
    },
    "background_save": {
        "desc": "",
        "ind": "",
        "fname": ""
    },
    "background_set_alpha_from_background": {
        "desc": "",
        "ind": "",
        "alpha": ""
    },
    "draw_background": {
        "desc": "",
        "back": "",
        "x": "",
        "y": ""
    },
    "draw_background_ext": {
        "desc": "",
        "back": "",
        "x": "",
        "y": "",
        "xscale": "",
        "yscale": "",
        "rot": "",
        "colour": "",
        "alpha": ""
    },
    "draw_background_general": {
        "desc": "",
        "back": "",
        "left": "",
        "top": "",
        "width": "",
        "height": "",
        "x": "",
        "y": "",
        "xscale": "",
        "yscale": "",
        "rot": "",
        "c1": "",
        "c2": "",
        "c3": "",
        "c4": "",
        "alpha": ""
    },
    "draw_background_part": {
        "desc": "",
        "back": "",
        "left": "",
        "top": "",
        "width": "",
        "height": "",
        "x": "",
        "y": ""
    },
    "draw_background_part_ext": {
        "desc": "",
        "back": "",
        "left": "",
        "top": "",
        "width": "",
        "height": "",
        "x": "",
        "y": "",
        "xscale": "",
        "yscale": "",
        "colour": "",
        "alpha": ""
    },
    "draw_background_stretched": {
        "desc": "",
        "back": "",
        "x": "",
        "y": "",
        "w": "",
        "h": ""
    },
    "draw_background_stretched_ext": {
        "desc": "",
        "back": "",
        "x": "",
        "y": "",
        "w": "",
        "h": "",
        "colour": "",
        "alpha": ""
    },
    "draw_background_tiled": {
        "desc": "",
        "back": "",
        "x": "",
        "y": ""
    },
    "draw_background_tiled_ext": {
        "desc": "",
        "back": "",
        "x": "",
        "y": "",
        "xscale": "",
        "yscale": "",
        "colour": "",
        "alpha": ""
    },
    "room_set_background": {
        "desc": "",
        "ind": "",
        "bind": "",
        "vis": "",
        "fore": "",
        "back": "",
        "x": "",
        "y": "",
        "htiled": "",
        "vtiled": "",
        "hspeed": "",
        "vspeed": "",
        "alpha": ""
    },
    "room_tile_add": {
        "desc": "",
        "ind": "",
        "back": "",
        "left": "",
        "top": "",
        "width": "",
        "hieght": "",
        "x": "",
        "y": "",
        "depth": ""
    },
    "room_tile_add_ext": {
        "desc": "",
        "ind": "",
        "back": "",
        "left": "",
        "top": "",
        "width": "",
        "hieght": "",
        "x": "",
        "y": "",
        "depth": "",
        "xscale": "",
        "yscale": "",
        "alpha": ""
    },
    "room_tile_clear": {
        "desc": "",
        "ind": ""
    },
    "tile_add": {
        "desc": "",
        "background": "",
        "left": "",
        "top": "",
        "width": "",
        "height": "",
        "x": "",
        "y": "",
        "depth": ""
    },
    "tile_delete": {
        "desc": "",
        "id": ""
    },
    "tile_exists": {
        "desc": "",
        "id": ""
    },
    "tile_get_alpha": {
        "desc": "",
        "id": ""
    },
    "tile_get_background": {
        "desc": "",
        "id": ""
    },
    "tile_get_blend": {
        "desc": "",
        "id": ""
    },
    "tile_get_count": {
        "desc": ""
    },
    "tile_get_depth": {
        "desc": "",
        "id": ""
    },
    "tile_get_height": {
        "desc": "",
        "id": ""
    },
    "tile_get_id": {
        "desc": "",
        "index": ""
    },
    "tile_get_ids": {
        "desc": ""
    },
    "tile_get_ids_at_depth": {
        "desc": "",
        "depth": ""
    },
    "tile_get_left": {
        "desc": "",
        "id": ""
    },
    "tile_get_top": {
        "desc": "",
        "id": ""
    },
    "tile_get_visible": {
        "desc": "",
        "id": ""
    },
    "tile_get_width": {
        "desc": "",
        "id": ""
    },
    "tile_get_x": {
        "desc": "",
        "id": ""
    },
    "tile_get_xscale": {
        "desc": "",
        "id": ""
    },
    "tile_get_y": {
        "desc": "",
        "id": ""
    },
    "tile_get_yscale": {
        "desc": "",
        "id": ""
    },
    "tile_layer_delete": {
        "desc": "",
        "depth": ""
    },
    "tile_layer_delete_at": {
        "desc": "",
        "depth": "",
        "x": "",
        "y": ""
    },
    "tile_layer_depth": {
        "desc": "",
        "depth": "",
        "newdepth": ""
    },
    "tile_layer_find": {
        "desc": "",
        "depth": "",
        "x": "",
        "y": ""
    },
    "tile_layer_hide": {
        "desc": "",
        "depth": ""
    },
    "tile_layer_shift": {
        "desc": "",
        "depth": "",
        "x": "",
        "y": ""
    },
    "tile_layer_show": {
        "desc": "",
        "depth": ""
    },
    "tile_set_alpha": {
        "desc": "",
        "id": "",
        "alpha": ""
    },
    "tile_set_background": {
        "desc": "",
        "id": "",
        "background": ""
    },
    "tile_set_blend": {
        "desc": "",
        "id": "",
        "colour": ""
    },
    "tile_set_depth": {
        "desc": "",
        "id": "",
        "depth": ""
    },
    "tile_set_position": {
        "desc": "",
        "id": "",
        "x": "",
        "y": ""
    },
    "tile_set_region": {
        "desc": "",
        "id": "",
        "left": "",
        "top": "",
        "width": "",
        "height": ""
    },
    "tile_set_scale": {
        "desc": "",
        "id": "",
        "xscale": "",
        "yscale": ""
    },
    "tile_set_visible": {
        "desc": "",
        "id": "",
        "visible": ""
    },
    "object_get_depth": {
        "desc": "",
        "ind": ""
    },
    "object_set_depth": {
        "desc": "",
        "ind": "",
        "depth": ""
    },
    "d3d_draw_block": {
        "desc": "",
        "x1": "",
        "y1": "",
        "z1": "",
        "x2": "",
        "y2": "",
        "z2": "",
        "texid": "",
        "hrepeat": "",
        "vrepeat": ""
    },
    "d3d_draw_cone": {
        "desc": "",
        "x1": "",
        "y1": "",
        "z1": "",
        "x2": "",
        "y2": "",
        "z2": "",
        "texid": "",
        "hrepeat": "",
        "vrepeat": "",
        "closed": "",
        "steps": ""
    },
    "d3d_draw_cylinder": {
        "desc": "",
        "x1": "",
        "y1": "",
        "z1": "",
        "x2": "",
        "y2": "",
        "z2": "",
        "texid": "",
        "hrepeat": "",
        "vrepeat": "",
        "closed": "",
        "steps": ""
    },
    "d3d_draw_ellipsoid": {
        "desc": "",
        "x1": "",
        "y1": "",
        "z1": "",
        "x2": "",
        "y2": "",
        "z2": "",
        "texid": "",
        "hrepeat": "",
        "vrepeat": "",
        "closed": "",
        "steps": ""
    },
    "d3d_draw_floor": {
        "desc": "",
        "x1": "",
        "y1": "",
        "z1": "",
        "x2": "",
        "y2": "",
        "z2": "",
        "texid": "",
        "hrepeat": "",
        "vrepeat": ""
    },
    "d3d_draw_wall": {
        "desc": "",
        "x1": "",
        "y1": "",
        "z1": "",
        "x2": "",
        "y2": "",
        "z2": "",
        "texid": "",
        "hrepeat": "",
        "vrepeat": ""
    },
    "d3d_end": {
        "desc": ""
    },
    "d3d_light_define_ambient": {
        "desc": "",
        "col": ""
    },
    "d3d_light_define_direction": {
        "desc": "",
        "ind": "",
        "dx": "",
        "dy": "",
        "dz": "",
        "col": ""
    },
    "d3d_light_define_point": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "z": "",
        "range": "",
        "col": ""
    },
    "d3d_light_enable": {
        "desc": "",
        "ind": "",
        "enable": ""
    },
    "d3d_model_block": {
        "desc": "",
        "ind": "",
        "x1": "",
        "y1": "",
        "z1": "",
        "x2": "",
        "y2": "",
        "z2": "",
        "hrepeat": "",
        "vrepeat": ""
    },
    "d3d_model_clear": {
        "desc": "",
        "ind": ""
    },
    "d3d_model_cone": {
        "desc": "",
        "ind": "",
        "x1": "",
        "y1": "",
        "z1": "",
        "x2": "",
        "y2": "",
        "z2": "",
        "hrepeat": "",
        "vrepeat": "",
        "closed": "",
        "steps": ""
    },
    "d3d_model_create": {
        "desc": ""
    },
    "d3d_model_cylinder": {
        "desc": "",
        "ind": "",
        "x1": "",
        "y1": "",
        "z1": "",
        "x2": "",
        "y2": "",
        "z2": "",
        "hrepeat": "",
        "vrepeat": "",
        "closed": "",
        "steps": ""
    },
    "d3d_model_destroy": {
        "desc": ""
    },
    "d3d_model_draw": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "z": "",
        "texid": ""
    },
    "d3d_model_ellipsoid": {
        "desc": "",
        "ind": "",
        "x1": "",
        "y1": "",
        "z1": "",
        "x2": "",
        "y2": "",
        "z2": "",
        "hrepeat": "",
        "vrepeat": "",
        "closed": ""
    },
    "d3d_model_floor": {
        "desc": "",
        "ind": "",
        "x1": "",
        "y1": "",
        "z1": "",
        "x2": "",
        "y2": "",
        "z2": "",
        "hrepeat": "",
        "vrepeat": ""
    },
    "d3d_model_load": {
        "desc": "",
        "ind": "",
        "fname": ""
    },
    "d3d_model_primitive_begin": {
        "desc": "",
        "ind": "",
        "kind": ""
    },
    "d3d_model_primitive_end": {
        "desc": "",
        "ind": ""
    },
    "d3d_model_save": {
        "desc": "",
        "ind": "",
        "fname": ""
    },
    "d3d_model_vertex": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "z": ""
    },
    "d3d_model_vertex_color": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "z": "",
        "col": "",
        "alpha": ""
    },
    "d3d_model_vertex_colour": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "z": "",
        "col": "",
        "alpha": ""
    },
    "d3d_model_vertex_normal": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "z": "",
        "nx": "",
        "ny": "",
        "nz": ""
    },
    "d3d_model_vertex_normal_color": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "z": "",
        "nx": "",
        "ny": "",
        "nz": "",
        "col": "",
        "alpha": ""
    },
    "d3d_model_vertex_normal_colour": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "z": "",
        "nx": "",
        "ny": "",
        "nz": "",
        "col": "",
        "alpha": ""
    },
    "d3d_model_vertex_normal_texture": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "z": "",
        "nx": "",
        "ny": "",
        "nz": "",
        "xtex": "",
        "ytex": ""
    },
    "d3d_model_vertex_normal_texture_color": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "z": "",
        "nx": "",
        "ny": "",
        "nz": "",
        "xtex": "",
        "ytex": "",
        "col": "",
        "alpha": ""
    },
    "d3d_model_vertex_normal_texture_colour": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "z": "",
        "nx": "",
        "ny": "",
        "nz": "",
        "xtex": "",
        "ytex": "",
        "col": "",
        "alpha": ""
    },
    "d3d_model_vertex_texture": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "z": "",
        "xtex": "",
        "ytex": ""
    },
    "d3d_model_vertex_texture_color": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "z": "",
        "xtex": "",
        "ytex": "",
        "col": "",
        "alpha": ""
    },
    "d3d_model_vertex_texture_colour": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "z": "",
        "xtex": "",
        "ytex": "",
        "col": "",
        "alpha": ""
    },
    "d3d_model_wall": {
        "desc": "",
        "ind": "",
        "x1": "",
        "y1": "",
        "z1": "",
        "x2": "",
        "y2": "",
        "z2": "",
        "hrepeat": "",
        "vrepeat": ""
    },
    "d3d_primitive_begin": {
        "desc": "",
        "kind": ""
    },
    "d3d_primitive_begin_texture": {
        "desc": "",
        "kind": "",
        "texid": ""
    },
    "d3d_primitive_end": {
        "desc": ""
    },
    "d3d_set_culling": {
        "desc": "",
        "cull": ""
    },
    "d3d_set_depth": {
        "desc": "",
        "depth": ""
    },
    "d3d_set_fog": {
        "desc": "",
        "enable": "",
        "colour": "",
        "start": "",
        "end": ""
    },
    "d3d_set_hidden": {
        "desc": "",
        "hidden": ""
    },
    "d3d_set_lighting": {
        "desc": "",
        "enable": ""
    },
    "d3d_set_perspective": {
        "desc": "",
        "enable": ""
    },
    "d3d_set_projection": {
        "desc": "",
        "xfrom": "",
        "yfrom": "",
        "zfrom": "",
        "xto": "",
        "yto": "",
        "zto": "",
        "xup": "",
        "yup": "",
        "zup": ""
    },
    "d3d_set_projection_ext": {
        "desc": "",
        "xfrom": "",
        "yfrom": "",
        "zfrom": "",
        "xto": "",
        "yto": "",
        "zto": "",
        "xup": "",
        "yup": "",
        "zup": "",
        "angle": "",
        "aspect": "",
        "znear": "",
        "zfar": ""
    },
    "d3d_set_projection_ortho": {
        "desc": "",
        "x": "",
        "y": "",
        "w": "",
        "h": "",
        "angle": ""
    },
    "d3d_set_projection_perspective": {
        "desc": "",
        "x": "",
        "y": "",
        "w": "",
        "h": "",
        "angle": ""
    },
    "d3d_set_shading": {
        "desc": "",
        "smooth": ""
    },
    "d3d_set_zwriteenable": {
        "desc": "",
        "on_off": ""
    },
    "d3d_start": {
        "desc": ""
    },
    "d3d_transform_add_rotation_axis": {
        "desc": "",
        "xa": "",
        "ya": "",
        "za": "",
        "angle": ""
    },
    "d3d_transform_add_rotation_x": {
        "desc": "",
        "angle": ""
    },
    "d3d_transform_add_rotation_y": {
        "desc": "",
        "angle": ""
    },
    "d3d_transform_add_rotation_z": {
        "desc": "",
        "angle": ""
    },
    "d3d_transform_add_scaling": {
        "desc": "",
        "xs": "",
        "ys": "",
        "zs": ""
    },
    "d3d_transform_add_translation": {
        "desc": "",
        "xt": "",
        "yt": "",
        "zt": ""
    },
    "d3d_transform_set_identity": {
        "desc": ""
    },
    "d3d_transform_set_rotation_axis": {
        "desc": "",
        "xa": "",
        "ya": "",
        "za": "",
        "angle": ""
    },
    "d3d_transform_set_rotation_x": {
        "desc": "",
        "angle": ""
    },
    "d3d_transform_set_rotation_y": {
        "desc": "",
        "angle": ""
    },
    "d3d_transform_set_rotation_z": {
        "desc": "",
        "angle": ""
    },
    "d3d_transform_set_scaling": {
        "desc": "",
        "xs": "",
        "ys": "",
        "zs": ""
    },
    "d3d_transform_set_translation": {
        "desc": "",
        "xt": "",
        "yt": "",
        "zt": ""
    },
    "d3d_transform_stack_clear": {
        "desc": ""
    },
    "d3d_transform_stack_discard": {
        "desc": ""
    },
    "d3d_transform_stack_empty": {
        "desc": ""
    },
    "d3d_transform_stack_pop": {
        "desc": ""
    },
    "d3d_transform_stack_push": {
        "desc": ""
    },
    "d3d_transform_stack_top": {
        "desc": ""
    },
    "d3d_transform_vertex": {
        "desc": "",
        "x": "",
        "y": "",
        "z": ""
    },
    "d3d_vertex": {
        "desc": "",
        "x": "",
        "y": "",
        "z": ""
    },
    "d3d_vertex_color": {
        "desc": "",
        "x": "",
        "y": "",
        "z": "",
        "col": "",
        "alpha": ""
    },
    "d3d_vertex_colour": {
        "desc": "",
        "x": "",
        "y": "",
        "z": "",
        "col": "",
        "alpha": ""
    },
    "d3d_vertex_normal": {
        "desc": "",
        "x": "",
        "y": "",
        "z": "",
        "nx": "",
        "ny": "",
        "nz": ""
    },
    "d3d_vertex_normal_color": {
        "desc": "",
        "x": "",
        "y": "",
        "z": "",
        "nx": "",
        "ny": "",
        "nz": "",
        "col": "",
        "alpha": ""
    },
    "d3d_vertex_normal_colour": {
        "desc": "",
        "x": "",
        "y": "",
        "z": "",
        "nx": "",
        "ny": "",
        "nz": "",
        "col": "",
        "alpha": ""
    },
    "d3d_vertex_normal_texture": {
        "desc": "",
        "x": "",
        "y": "",
        "z": "",
        "nx": "",
        "ny": "",
        "nz": "",
        "xtex": "",
        "ytex": ""
    },
    "d3d_vertex_normal_texture_color": {
        "desc": "",
        "x": "",
        "y": "",
        "z": "",
        "nx": "",
        "ny": "",
        "nz": "",
        "xtex": "",
        "ytex": "",
        "col": "",
        "alpha": ""
    },
    "d3d_vertex_normal_texture_colour": {
        "desc": "",
        "x": "",
        "y": "",
        "z": "",
        "nx": "",
        "ny": "",
        "nz": "",
        "xtex": "",
        "ytex": "",
        "col": "",
        "alpha": ""
    },
    "d3d_vertex_texture": {
        "desc": "",
        "x": "",
        "y": "",
        "z": "",
        "xtex": "",
        "ytex": ""
    },
    "d3d_vertex_texture_color": {
        "desc": "",
        "x": "",
        "y": "",
        "z": "",
        "xtex": "",
        "ytex": "",
        "col": "",
        "alpha": ""
    },
    "d3d_vertex_texture_colour": {
        "desc": "",
        "x": "",
        "y": "",
        "z": "",
        "xtex": "",
        "ytex": "",
        "col": "",
        "alpha": ""
    },
    "display_set_windows_vertex_buffer_method": {
        "desc": "",
        "method": ""
    },
    "display_get_windows_vertex_buffer_method": {
        "desc": ""
    },
    "display_set_windows_alternate_sync": {
        "desc": "",
        "enable": ""
    },
    "display_get_windows_alternate_sync": {
        "desc": ""
    },
    "room_set_view": {
        "desc": "",
        "ind": "",
        "vind": "",
        "vis": "",
        "xview": "",
        "yview": "",
        "wview": "",
        "hview": "",
        "xport": "",
        "yport": "",
        "wport": "",
        "hport": "",
        "hborder": "",
        "vborder": "",
        "hspeed": "",
        "vspeed": "",
        "obj": ""
    },
    "immersion_play_effect": {
        "desc": "",
        "effect": ""
    },
    "immersion_stop": {
        "desc": ""
    },
    "analytics_event": {
        "desc": "",
        "string": ""
    },
    "analytics_event_ext": {
        "desc": "",
        "string": "",
        "string_param_name1": "",
        "number_value1": "",
        "...": ""
    },

    "background_add_background": {
        "desc": "",
        "fname": ""
    },
    "background_create_from_screen": {
        "desc": "",
        "x": "",
        "y": "",
        "w": "",
        "h": "",
        "removeback": "",
        "smooth": ""
    },
    "cd_close_door": {
        "desc": ""
    },
	"cd_init": {
        "desc": ""
    },
    "cd_length": {
        "desc": ""
    },
	"cd_number": {
        "desc": ""
    },
	"cd_open_door": {
        "desc": ""
    },
	"cd_pause": {
        "desc": ""
    },
	"cd_paused": {
        "desc": ""
    },
	"cd_play": {
        "desc": "",
        "first": "",
        "last": ""
    },
	"cd_playing": {
        "desc": ""
    },
	"cd_position": {
        "desc": ""
    },
	"cd_present": {
        "desc": ""
    },
	"cd_resume": {
        "desc": ""
    },
	"cd_set_position": {
        "desc": "",
        "pos": ""
    },
	"cd_set_track_position": {
        "desc": "",
        "pos": ""
    },
	"cd_stop": {
        "desc": ""
    },
	"cd_track": {
        "desc": ""
    },
	"cd_track_length": {
        "desc": "",
        "n": ""
    },
	"cd_track_position": {
        "desc": ""
    },
    "date_create_date": {
        "desc": "",
        "year": "",
        "month": "",
        "day": ""
    },
    "date_create_time": {
        "desc": "",
        "hour": "",
        "minute": "",
        "second": ""
    },
	"date_current_date": {
        "desc": ""
    },
    "date_current_time": {
        "desc": ""
    },
    "date_valid_date": {
        "desc": "",
        "year": "",
        "month": "",
        "day": ""
    },
    "date_valid_time": {
        "desc": "",
        "hour": "",
        "minute": "",
        "second": ""
    },
    "discard_include_file": {
        "desc": "",
        "fname": ""
    },
	"disk_free": {
        "desc": "",
        "drive": ""
    },
	"disk_size": {
        "desc": "",
        "drive": ""
    },
	"display_set_all": {
        "desc": "",
        "w": "",
        "h": "",
        "frequency": "",
        "coldepth": ""
    },
	"display_set_colordepth": {
        "desc": "",
        "coldepth": ""
    },
	"display_set_frequency": {
        "desc": "",
        "frequency": ""
    },
	"display_set_size": {
        "desc": "",
        "w": "",
        "h": ""
    },
	"display_test_all": {
        "desc": "",
        "w": "",
        "h": "",
        "frequency": "",
        "coldepth": ""
    },
    "execute_file": {
        "desc": "",
        "fname": "",
        "arg0": "",
        "arg1": "",
        "...": ""
    },
    "execute_program": {
        "desc": "",
        "fname": "",
        "arg": "",
        "wait": ""
    },
	"execute_shell": {
        "desc": "",
        "fname": "",
        "arg": ""
    },
    "execute_string": {
        "desc": "",
        "str": "",
        "arg0": "",
        "arg1": "",
        "...": ""
    },
	"export_include_file": {
        "desc": "",
        "fname": ""
    },
	"export_include_file_location": {
        "desc": "",
        "fname": "",
        "location": ""
    },
    "get_color": {
        "desc": "",
        "defcol": ""
    },
	"get_directory": {
        "desc": "",
        "dname": ""
    },
	"get_directory_alt": {
        "desc": "",
        "capt": "",
        "root": ""
    },
    "highscore_add_current": {
        "desc": ""
    },
    "highscore_set_background": {
        "desc": "",
        "back": ""
    },
	"highscore_set_border": {
        "desc": "",
        "show": ""
    },
	"highscore_set_colors": {
        "desc": "",
        "back": "",
        "new": "",
        "other": ""
    },
	"highscore_set_font": {
        "desc": "",
        "name": "",
        "size": "",
        "style": ""
    },
	"highscore_set_strings": {
        "desc": "",
        "caption": "",
        "nobody": "",
        "escape": ""
    },
	"highscore_show": {
        "desc": "",
        "numb": ""
    },
	"highscore_show_ext": {
        "desc": "",
        "numb": "",
        "back": "",
        "border": "",
        "col1": "",
        "col2": "",
        "name": "",
        "size": ""
    },
    "io_handle": {
        "desc": ""
    },
    "keyboard_wait": {
        "desc": ""
    },
	"MCI_command": {
        "desc": "",
        "str": ""
    },
	"message_alpha": {
        "desc": "",
        "alpha": ""
    },
	"message_background": {
        "desc": "",
        "back": ""
    },
	"message_button": {
        "desc": "",
        "sprite": ""
    },
	"message_button_font": {
        "desc": "",
        "name": "",
        "size": "",
        "colour": "",
        "style": ""
    },
	"message_caption": {
        "desc": "",
        "show": "",
        "str": ""
    },
	"message_input_color": {
        "desc": "",
        "col": ""
    },
	"message_input_font": {
        "desc": "",
        "name": "",
        "size": "",
        "colour": "",
        "style": ""
    },
	"message_mouse_color": {
        "desc": "",
        "col": ""
    },
	"message_position": {
        "desc": "",
        "x": "",
        "y": ""
    },
	"message_size": {
        "desc": "",
        "w": "",
        "h": ""
    },
	"message_text_charset": {
        "desc": "",
        "type": "",
        "charset_id": ""
    },
	"message_text_font": {
        "desc": "",
        "name": "",
        "size": "",
        "colour": "",
        "style": ""
    },
    "mouse_wait": {
        "desc": ""
    },
    "object_add": {
        "desc": ""
    },
	"object_delete": {
        "desc": "",
        "ind": ""
    },
	"object_event_add": {
        "desc": "",
        "ind": "",
        "evtype": "",
        "evnumb": "",
        "codestr": ""
    },
	"object_event_clear": {
        "desc": "",
        "ind": "",
        "evtype": "",
        "evnumb": ""
    },
	"part_attractor_clear": {
        "desc": "",
        "ps": "",
        "ind": ""
    },
	"part_attractor_create": {
        "desc": "",
        "ps": ""
    },
	"part_attractor_destroy": {
        "desc": "",
        "ps": "",
        "ind": ""
    },
	"part_attractor_destroy_all": {
        "desc": "",
        "ps": ""
    },
	"part_attractor_exists": {
        "desc": "",
        "ps": "",
        "ind": ""
    },
	"part_attractor_force": {
        "desc": "",
        "ps": "",
        "ind": "",
        "force": "",
        "dist": "",
        "kind": "",
        "additive": ""
    },
	"part_attractor_position": {
        "desc": "",
        "ps": "",
        "ind": "",
        "x": "",
        "y": ""
    },
	"part_changer_clear": {
        "desc": "",
        "ps": "",
        "ind": ""
    },
	"part_changer_create": {
        "desc": "",
        "ps": ""
    },
	"part_changer_destroy": {
        "desc": "",
        "ps": "",
        "ind": ""
    },
	"part_changer_destroy_all": {
        "desc": "",
        "ps": ""
    },
	"part_changer_exists": {
        "desc": "",
        "ps": "",
        "ind": ""
    },
	"part_changer_kind": {
        "desc": "",
        "ps": "",
        "ind": "",
        "kind": ""
    },
	"part_changer_region": {
        "desc": "",
        "ps": "",
        "ind": "",
        "xmin": "",
        "xmax": "",
        "ymin": "",
        "ymax": "",
        "shape": ""
    },
	"part_changer_types": {
        "desc": "",
        "ps": "",
        "ind": "",
        "parttype1": "",
        "parttype2": ""
    },
	"part_deflector_clear": {
        "desc": "",
        "ps": "",
        "ind": ""
    },
	"part_deflector_create": {
        "desc": "",
        "ps": ""
    },
	"part_deflector_destroy": {
        "desc": "",
        "ps": "",
        "ind": ""
    },
	"part_deflector_destroy_all": {
        "desc": "",
        "ps": ""
    },
	"part_deflector_exists": {
        "desc": "",
        "ps": "",
        "ind": ""
    },
	"part_deflector_friction": {
        "desc": "",
        "ps": "",
        "ind": "",
        "amount": ""
    },
	"part_deflector_kind": {
        "desc": "",
        "ps": "",
        "ind": "",
        "kind": ""
    },
	"part_deflector_region": {
        "desc": "",
        "ps": "",
        "ind": "",
        "xmin": "",
        "xmax": "",
        "ymin": "",
        "ymax": ""
    },
	"part_destroyer_clear": {
        "desc": "",
        "ps": "",
        "ind": ""
    },
	"part_destroyer_create": {
        "desc": "",
        "ps": ""
    },
	"part_destroyer_destroy": {
        "desc": "",
        "ps": "",
        "ind": ""
    },
	"part_destroyer_destroy_all": {
        "desc": "",
        "ps": ""
    },
	"part_destroyer_exists": {
        "desc": "",
        "ps": "",
        "ind": ""
    },
	"part_destroyer_region": {
        "desc": "",
        "ps": "",
        "ind": "",
        "xmin": "",
        "xmax": "",
        "ymin": "",
        "ymax": "",
        "shape": ""
    },
    "registry_exists": {
        "desc": "",
        "name": ""
    },
	"registry_exists_ext": {
        "desc": "",
        "key": "",
        "name": ""
    },
	"registry_read_real": {
        "desc": "",
        "name": ""
    },
	"registry_read_real_ext": {
        "desc": "",
        "key": "",
        "name": ""
    },
	"registry_read_string": {
        "desc": "",
        "name": ""
    },
	"registry_read_string_ext": {
        "desc": "",
        "key": "",
        "name": ""
    },
	"registry_set_root": {
        "desc": "",
        "root": ""
    },
	"registry_write_real": {
        "desc": "",
        "name": "",
        "value": ""
    },
	"registry_write_real_ext": {
        "desc": "",
        "key": "",
        "name": "",
        "value": ""
    },
	"registry_write_string": {
        "desc": "",
        "name": "",
        "str": ""
    },
	"registry_write_string_ext": {
        "desc": "",
        "key": "",
        "name": "",
        "str": ""
    },
    "room_set_caption": {
        "desc": "",
        "ind": "",
        "str": ""
    },
	"room_set_code": {
        "desc": "",
        "ind": "",
        "codestr": ""
    },
    "screen_redraw": {
        "desc": ""
    },
    "screen_refresh": {
        "desc": ""
    },
    "screen_wait_vsync": {
        "desc": ""
    },
    "script_get_text": {
        "desc": "",
        "ind": ""
    },
	"set_application_title": {
        "desc": "",
        "title": ""
    },
	"set_automatic_draw": {
        "desc": "",
        "value": ""
    },
	"set_program_priority": {
        "desc": "",
        "priority": ""
    },
	"set_synchronization": {
        "desc": "",
        "value": ""
    },
    "show_menu": {
        "desc": "",
        "str": "",
        "def": ""
    },
	"show_menu_pos": {
        "desc": "",
        "x": "",
        "y": "",
        "str": "",
        "def": ""
    },
    "show_message_ext": {
        "desc": "",
        "str": "",
        "but1": "",
        "but2": "",
        "but3": ""
    },
    "sleep": {
        "desc": "",
        "millisec": ""
    },
	"sound_3d_set_sound_cone": {
        "desc": "",
        "snd": "",
        "x": "",
        "y": "",
        "z": "",
        "anglein": "",
        "angleout": "",
        "voloutside": ""
    },
	"sound_3d_set_sound_distance": {
        "desc": "",
        "snd": "",
        "mindist": "",
        "maxdist": ""
    },
	"sound_3d_set_sound_position": {
        "desc": "",
        "snd": "",
        "x": "",
        "y": "",
        "z": ""
    },
	"sound_3d_set_sound_velocity": {
        "desc": "",
        "snd": "",
        "x": "",
        "y": "",
        "z": ""
    },
	"sound_add": {
        "desc": "",
        "fname": "",
        "kind": "",
        "preload": ""
    },
	"sound_background_tempo": {
        "desc": "",
        "factor": ""
    },
	"sound_effect_chorus": {
        "desc": "",
        "snd": "",
        "wetdry": "",
        "depth": "",
        "feedback": "",
        "frequency": "",
        "wave": "",
        "delay": "",
        "phase": ""
    },
	"sound_effect_compressor": {
        "desc": "",
        "snd": "",
        "gain": "",
        "attack": "",
        "release": "",
        "threshold": "",
        "ratio": "",
        "delay": ""
    },
	"sound_effect_echo": {
        "desc": "",
        "snd": "",
        "wetdry": "",
        "feedback": "",
        "leftdelay": "",
        "rightdelay": "",
        "pandelay": ""
    },
	"sound_effect_equalizer": {
        "desc": "",
        "snd": "",
        "center": "",
        "bandwidth": "",
        "gain": ""
    },
	"sound_effect_flanger": {
        "desc": "",
        "snd": "",
        "wetdry": "",
        "depth": "",
        "feedback": "",
        "frequency": "",
        "wave": "",
        "delay": "",
        "phase": ""
    },
	"sound_effect_gargle": {
        "desc": "",
        "snd": "",
        "rate": "",
        "wave": ""
    },
	"sound_effect_reverb": {
        "desc": "",
        "snd": "",
        "gain": "",
        "mix": "",
        "time": "",
        "ratio": ""
    },
	"sound_effect_set": {
        "desc": "",
        "snd": "",
        "effect": ""
    },
	"sound_pan": {
        "desc": "",
        "index": "",
        "value": ""
    },
	"sound_replace": {
        "desc": "",
        "ind": "",
        "fname": "",
        "kind": "",
        "preload": ""
    },
	"sound_set_search_directory": {
        "desc": "",
        "dir": ""
    },
	"splash_set_adapt": {
        "desc": "",
        "adapt": ""
    },
	"splash_set_border": {
        "desc": "",
        "border": ""
    },
	"splash_set_caption": {
        "desc": "",
        "cap": ""
    },
	"splash_set_close_button": {
        "desc": "",
        "show": ""
    },
	"splash_set_color": {
        "desc": "",
        "col": ""
    },
	"splash_set_cursor": {
        "desc": "",
        "vis": ""
    },
	"splash_set_fullscreen": {
        "desc": "",
        "full": ""
    },
	"splash_set_interrupt": {
        "desc": "",
        "interrupt": ""
    },
	"splash_set_main": {
        "desc": "",
        "main": ""
    },
	"splash_set_position": {
        "desc": "",
        "x": "",
        "y": ""
    },
	"splash_set_scale": {
        "desc": "",
        "scale": ""
    },
	"splash_set_size": {
        "desc": "",
        "w": "",
        "h": ""
    },
	"splash_set_stop_key": {
        "desc": "",
        "stop": ""
    },
	"splash_set_stop_mouse": {
        "desc": "",
        "stop": ""
    },
	"splash_set_top": {
        "desc": "",
        "top": ""
    },
	"splash_show_image": {
        "desc": "",
        "fname": "",
        "delay": ""
    },
	"splash_show_text": {
        "desc": "",
        "fname": "",
        "delay": ""
    },
	"splash_show_video": {
        "desc": "",
        "fname": "",
        "loop": ""
    },
	"splash_show_web": {
        "desc": "",
        "url": "",
        "delay": ""
    },
    "sprite_add_from_screen": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "w": "",
        "h": "",
        "removeback": "",
        "smooth": ""
    },
    "sprite_add_sprite": {
        "desc": "",
        "fname": ""
    },
    "sprite_create_from_screen": {
        "desc": "",
        "x": "",
        "y": "",
        "w": "",
        "h": "",
        "removeback": "",
        "smooth": "",
        "xorig": "",
        "yorig": ""
    },
    "sprite_replace_sprite": {
        "desc": "",
        "ind": "",
        "fname": ""
    },
    "timeline_moment_add": {
        "desc": "",
        "ind": "",
        "step": "",
        "codestr": ""
    },
    "transition_define": {
        "desc": "",
        "kind": "",
        "name": ""
    },
	"transition_exists": {
        "desc": "",
        "kind": ""
    },
	"variable_global_array2_get": {
        "desc": "",
        "name": "",
        "ind1": "",
        "ind2": ""
    },
	"variable_global_array2_set": {
        "desc": "",
        "name": "",
        "ind1": "",
        "ind2": "",
        "value": ""
    },
	"variable_global_array_get": {
        "desc": "",
        "name": "",
        "ind": ""
    },
	"variable_global_array_set": {
        "desc": "",
        "name": "",
        "ind": "",
        "value": ""
    },
    "variable_local_array2_get": {
        "desc": "",
        "name": "",
        "ind1": "",
        "ind2": ""
    },
	"variable_local_array2_set": {
        "desc": "",
        "name": "",
        "ind1": "",
        "ind2": "",
        "value": ""
    },
	"variable_local_array_get": {
        "desc": "",
        "name": "",
        "ind": ""
    },
	"variable_local_array_set": {
        "desc": "",
        "name": "",
        "ind": "",
        "value": ""
    },
	"variable_local_exists": {
        "desc": "",
        "name": ""
    },
	"variable_local_get": {
        "desc": "",
        "name": ""
    },
	"variable_local_set": {
        "desc": "",
        "name": "",
        "value": ""
    },
    "window_default": {
        "desc": ""
    },
    "window_get_region_height": {
        "desc": ""
    },
	"window_get_region_scale": {
        "desc": ""
    },
	"window_get_region_width": {
        "desc": ""
    },
	"window_get_showborder": {
        "desc": ""
    },
	"window_get_showicons": {
        "desc": ""
    },
	"window_get_sizeable": {
        "desc": ""
    },
	"window_get_stayontop": {
        "desc": ""
    },
    "window_get_visible": {
        "desc": ""
    },
    "window_set_region_scale": {
        "desc": "",
        "scale": "",
        "adaptwindow": ""
    },
	"window_set_region_size": {
        "desc": "",
        "w": "",
        "h": "",
        "adaptwindow": ""
    },
	"window_set_showborder": {
        "desc": "",
        "show": ""
    },
	"window_set_showicons": {
        "desc": "",
        "show": ""
    },
	"window_set_sizeable": {
        "desc": "",
        "sizeable": ""
    },
	"window_set_stayontop": {
        "desc": "",
        "stay": ""
    },
	"window_set_visible": {
        "desc": "",
        "visible": ""
    },
	"window_views_mouse_set": {
        "desc": "",
        "x": "",
        "y": ""
    },
	"window_view_mouse_set": {
        "desc": "",
        "id": "",
        "x": "",
        "y": ""
    },
    "texture_preload": {
        "desc": "",
        "texid": ""
    },
    "texture_set_priority": {
        "desc": "",
        "texid": "",
        "prio": ""
    },
    "display_get_colourdepth": {
        "desc": ""
    },
    "display_get_frequency": {
        "desc": ""
    },
    "show_info": {
        "desc": ""
    },
    "load_info": {
        "desc": "",
        "fname": ""
    },

    "string_hash_to_newline": {
        "desc": "",
        "str": ""
    },
	"game_set_speed": {
        "desc": "",
        "value": "",
        "type": ""
    },
	"game_get_speed": {
        "desc": "",
        "type": ""
    },
	"sprite_set_speed": {
        "desc": "",
        "ind": "",
        "speed": "",
        "type": ""
    },
	"sprite_get_speed_type": {
        "desc": "",
        "ind": ""
    },
	"sprite_get_speed": {
        "desc": "",
        "ind": ""
    },
	"texture_get_uvs": {
        "desc": "",
        "texid": ""
    },
	"room_get_camera": {
        "desc": "",
        "ind": "",
        "vind": ""
    },
	"room_set_camera": {
        "desc": "",
        "ind": "",
        "vind": "",
        "camera": ""
    },
	"room_get_viewport": {
        "desc": "",
        "vind": ""
    },
	"room_set_viewport": {
        "desc": "",
        "ind": "",
        "vind": "",
        "vis": "",
        "xport": "",
        "yport": "",
        "wport": "",
        "hport": ""
    },
	"ds_list_set": {
        "desc": "This function can be used to set a previously added list entry. You give the list ID (as returned when you created the list) and the position within the list to set as well as the value to set it to. Note that if the entry being set is outside the bounds of the list (ie, you set list entry 20 but the current list only contains 10 entries) then the list will be filled to the given position and each entry will be set to 0.",
        "id": "The id of the list to add to.",
        "pos": "The position within the list to set.",
        "value": "The value to add to the list."
    },
	"ds_map_set": {
        "desc": "",
        "id": "",
        "key": "",
        "value": ""
    },
	"part_system_create_layer": {
        "desc": "",
        "layer": "",
        "persistent": ""
    },
	"part_system_get_layer": {
        "desc": "",
        "ind": ""
    },
	"part_system_layer": {
        "desc": "",
        "ind": "",
        "layer": ""
    },
	"matrix_build_identity": {
        "desc": ""
    },
	"matrix_build_lookat": {
        "desc": "",
        "xfrom": "",
        "yfrom": "",
        "zfrom": "",
        "xto": "",
        "yto": "",
        "zto": "",
        "xup": "",
        "yup": "",
        "zup": ""
    },
	"matrix_build_projection_ortho": {
        "desc": "",
        "width": "",
        "height": "",
        "znear": "",
        "zfar": ""
    },
	"matrix_build_projection_perspective": {
        "desc": "",
        "width": "",
        "height": "",
        "znear": "",
        "zfar": ""
    },
	"matrix_build_projection_perspective_fov": {
        "desc": "",
        "fov_y": "",
        "height": "",
        "znear": "",
        "zfar": ""
    },
	"matrix_transform_vertex": {
        "desc": "",
        "matrix": "",
        "x": "",
        "y": "",
        "z": ""
    },
	"matrix_stack_push": {
        "desc": "",
        "...": ""
    },
	"matrix_stack_pop": {
        "desc": ""
    },
	"matrix_stack_set": {
        "desc": "",
        "matrix": ""
    },
	"matrix_stack_clear": {
        "desc": ""
    },
	"matrix_stack_top": {
        "desc": ""
    },
	"matrix_stack_is_empty": {
        "desc": ""
    },
	"gpu_set_blendenable": {
        "desc": "",
        "enable": ""
    },
	"gpu_set_ztestenable": {
        "desc": "",
        "enable": ""
    },
	"gpu_set_zfunc": {
        "desc": "",
        "enable": ""
    },
	"gpu_set_zwriteenable": {
        "desc": "",
        "enable": ""
    },
	"gpu_set_fog": {
        "desc": "",
        "enable": "",
        "col": "",
        "start": "",
        "end": ""
    },
	"gpu_set_cullmode": {
        "desc": "",
        "cullmode": ""
    },
	"gpu_set_blendmode": {
        "desc": "",
        "mode": ""
    },
	"gpu_set_blendmode_ext": {
        "desc": "",
        "src": "",
        "dest": ""
    },
	"gpu_set_blendmode_ext_sepalpha": {
        "desc": "",
        "src": "",
        "dest": "",
        "srcalpha": "",
        "destalpha": ""
    },
	"gpu_set_colorwriteenable": {
        "desc": "",
        "red": "",
        "green": "",
        "blue": "",
        "alpha": ""
    },
	"gpu_set_colourwriteenable": {
        "desc": "",
        "red": "",
        "green": "",
        "blue": "",
        "alpha": ""
    },
	"gpu_set_alphatestenable": {
        "desc": "",
        "enable": ""
    },
	"gpu_set_alphatestref": {
        "desc": "",
        "value": ""
    },
	"gpu_set_alphatestfunc": {
        "desc": "",
        "cmp_func": ""
    },
	"gpu_set_texfilter": {
        "desc": "",
        "linear": ""
    },
	"gpu_set_texfilter_ext": {
        "desc": "",
        "sampler_id": "",
        "linear": ""
    },
	"gpu_set_texrepeat": {
        "desc": "",
        "repeat": ""
    },
	"gpu_set_texrepeat_ext": {
        "desc": "",
        "sampler_id": "",
        "repeat": ""
    },
	"gpu_set_tex_filter": {
        "desc": "",
        "linear": ""
    },
	"gpu_set_tex_filter_ext": {
        "desc": "",
        "sampler_id": "",
        "linear": ""
    },
	"gpu_set_tex_repeat": {
        "desc": "",
        "repeat": ""
    },
	"gpu_set_tex_repeat_ext": {
        "desc": "",
        "sampler_id": "",
        "repeat": ""
    },
	"gpu_set_tex_mip_filter": {
        "desc": "",
        "filter": ""
    },
	"gpu_set_tex_mip_filter_ext": {
        "desc": "",
        "sampler_id": "",
        "filter": ""
    },
	"gpu_set_tex_mip_bias": {
        "desc": "",
        "bias": ""
    },
	"gpu_set_tex_mip_bias_ext": {
        "desc": "",
        "sampler_id": "",
        "bias": ""
    },
	"gpu_set_tex_min_mip": {
        "desc": "",
        "minmip": ""
    },
	"gpu_set_tex_min_mip_ext": {
        "desc": "",
        "sampler_id": "",
        "minmip": ""
    },
	"gpu_set_tex_max_mip": {
        "desc": "",
        "maxmip": ""
    },
	"gpu_set_tex_max_mip_ext": {
        "desc": "",
        "sampler_id": "",
        "maxmip": ""
    },
	"gpu_set_tex_max_aniso": {
        "desc": "",
        "maxaniso": ""
    },
	"gpu_set_tex_max_aniso_ext": {
        "desc": "",
        "sampler_id": "",
        "maxaniso": ""
    },
	"gpu_set_tex_mip_enable": {
        "desc": "",
        "setting": ""
    },
	"gpu_set_tex_mip_enable_ext": {
        "desc": "",
        "sampler_id": "",
        "setting": ""
    },
	"gpu_get_blendenable": {
        "desc": ""
    },
	"gpu_get_ztestenable": {
        "desc": ""
    },
	"gpu_get_zfunc": {
        "desc": ""
    },
	"gpu_get_zwriteenable": {
        "desc": ""
    },
	"gpu_get_fog": {
        "desc": ""
    },
	"gpu_get_cullmode": {
        "desc": ""
    },
	"gpu_get_blendmode": {
        "desc": ""
    },
	"gpu_get_blendmode_ext": {
        "desc": ""
    },
	"gpu_get_blendmode_ext_sepalpha": {
        "desc": ""
    },
	"gpu_get_blendmode_src": {
        "desc": ""
    },
	"gpu_get_blendmode_dest": {
        "desc": ""
    },
	"gpu_get_blendmode_srcalpha": {
        "desc": ""
    },
	"gpu_get_blendmode_destalpha": {
        "desc": ""
    },
	"gpu_get_colorwriteenable": {
        "desc": ""
    },
	"gpu_get_colourwriteenable": {
        "desc": ""
    },
	"gpu_get_alphatestenable": {
        "desc": ""
    },
	"gpu_get_alphatestref": {
        "desc": ""
    },
	"gpu_get_alphatestfunc": {
        "desc": ""
    },
	"gpu_get_texfilter": {
        "desc": ""
    },
	"gpu_get_texfilter_ext": {
        "desc": "",
        "sampler_id": ""
    },
	"gpu_get_texrepeat": {
        "desc": ""
    },
	"gpu_get_texrepeat_ext": {
        "desc": "",
        "sampler_id": ""
    },
	"gpu_get_tex_filter": {
        "desc": ""
    },
	"gpu_get_tex_filter_ext": {
        "desc": "",
        "sampler_id": ""
    },
	"gpu_get_tex_repeat": {
        "desc": ""
    },
	"gpu_get_tex_repeat_ext": {
        "desc": "",
        "sampler_id": ""
    },
	"gpu_get_tex_mip_filter": {
        "desc": ""
    },
	"gpu_get_tex_mip_filter_ext": {
        "desc": "",
        "sampler_id": ""
    },
	"gpu_get_tex_mip_bias": {
        "desc": ""
    },
	"gpu_get_tex_mip_bias_ext": {
        "desc": "",
        "sampler_id": ""
    },
	"gpu_get_tex_min_mip": {
        "desc": ""
    },
	"gpu_get_tex_min_mip_ext": {
        "desc": "",
        "sampler_id": ""
    },
	"gpu_get_tex_max_mip": {
        "desc": ""
    },
	"gpu_get_tex_max_mip_ext": {
        "desc": "",
        "sampler_id": ""
    },
	"gpu_get_tex_max_aniso": {
        "desc": ""
    },
	"gpu_get_tex_max_aniso_ext": {
        "desc": "",
        "sampler_id": ""
    },
	"gpu_get_tex_mip_enable": {
        "desc": ""
    },
	"gpu_get_tex_mip_enable_ext": {
        "desc": "",
        "sampler_id": ""
    },
	"gpu_push_state": {
        "desc": ""
    },
	"gpu_pop_state": {
        "desc": ""
    },
	"gpu_get_state": {
        "desc": ""
    },
	"gpu_set_state": {
        "desc": "",
        "map": ""
    },
	"draw_light_define_ambient": {
        "desc": "",
        "col": ""
    },
	"draw_light_define_direction": {
        "desc": "",
        "ind": "",
        "dx": "",
        "dy": "",
        "dz": "",
        "col": ""
    },
	"draw_light_define_point": {
        "desc": "",
        "ind": "",
        "x": "",
        "y": "",
        "z": "",
        "range": "",
        "col": ""
    },
	"draw_light_enable": {
        "desc": "",
        "ind": "",
        "enable": ""
    },
	"draw_set_lighting": {
        "desc": "",
        "enable": ""
    },
	"draw_light_get_ambient": {
        "desc": ""
    },
	"draw_light_get": {
        "desc": "",
        "ind": ""
    },
	"draw_get_lighting": {
        "desc": ""
    },
	"load_csv": {
        "desc": "",
        "filename": ""
    },
    "skeleton_animation_get_frame": {
        "desc": "",
        "track": ""
    },
	"skeleton_animation_set_frame": {
        "desc": "",
        "track": "",
        "index": ""
    },
	"layer_get_id": {
        "desc": "",
        "layer_name": ""
    },
	"layer_get_id_at_depth": {
        "desc": "",
        "depth": ""
    },
	"layer_get_depth": {
        "desc": "",
        "layer_id": ""
    },
	"layer_create": {
        "desc": "",
        "depth": "",
        "name": "",
        "...": ""
    },
	"layer_destroy": {
        "desc": "",
        "layer_id": ""
    },
	"layer_destroy_instances": {
        "desc": "",
        "layer_id": ""
    },
	"layer_add_instance": {
        "desc": "",
        "layer_id": "",
        "instance": ""
    },
	"layer_has_instance": {
        "desc": "",
        "layer_id": "",
        "instance": ""
    },
	"layer_set_visible": {
        "desc": "",
        "layer_id": "",
        "visible": ""
    },
	"layer_get_visible": {
        "desc": "",
        "layer_id": ""
    },
	"layer_exists": {
        "desc": "",
        "layer_id": ""
    },
	"layer_x": {
        "desc": "",
        "layer_id": "",
        "x": ""
    },
	"layer_y": {
        "desc": "",
        "layer_id": "",
        "y": ""
    },
	"layer_get_x": {
        "desc": "",
        "layer_id": ""
    },
	"layer_get_y": {
        "desc": "",
        "layer_id": ""
    },
	"layer_hspeed": {
        "desc": "",
        "layer_id": "",
        "speed": ""
    },
	"layer_vspeed": {
        "desc": "",
        "layer_id": "",
        "speed": ""
    },
	"layer_get_hspeed": {
        "desc": "",
        "layer_id": ""
    },
	"layer_get_vspeed": {
        "desc": "",
        "layer_id": ""
    },
	"layer_script_begin": {
        "desc": "",
        "layer_id": "",
        "script": ""
    },
	"layer_script_end": {
        "desc": "",
        "layer_id": "",
        "script": ""
    },
	"layer_shader": {
        "desc": "",
        "layer_id": "",
        "shader": ""
    },
	"layer_get_script_begin": {
        "desc": "",
        "layer_id": ""
    },
	"layer_get_script_end": {
        "desc": "",
        "layer_id": ""
    },
	"layer_get_shader": {
        "desc": "",
        "layer_id": ""
    },
	"layer_set_target_room": {
        "desc": "",
        "room": ""
    },
	"layer_get_target_room": {
        "desc": ""
    },
	"layer_reset_target_room": {
        "desc": ""
    },
	"layer_get_all": {
        "desc": ""
    },
	"layer_get_all_elements": {
        "desc": "",
        "layer_id": ""
    },
	"layer_get_name": {
        "desc": "",
        "layer_id": ""
    },
	"layer_depth": {
        "desc": "",
        "layer_id": "",
        "depth": ""
    },
	"layer_get_element_layer": {
        "desc": "",
        "element_id": ""
    },
	"layer_get_element_type": {
        "desc": "",
        "element_id": ""
    },
	"layer_element_move": {
        "desc": "",
        "element_id": "",
        "layer_id": ""
    },
	"layer_force_draw_depth": {
        "desc": "",
        "force": "",
        "depth": ""
    },
	"layer_is_draw_depth_forced": {
        "desc": ""
    },
	"layer_get_forced_depth": {
        "desc": ""
    },
	"layer_background_get_id": {
        "desc": "",
        "layer_id": ""
    },
	"layer_background_exists": {
        "desc": "",
        "layer_id": "",
        "background_element_id": ""
    },
	"layer_background_create": {
        "desc": "",
        "layer_id": "",
        "sprite": ""
    },
	"layer_background_destroy": {
        "desc": "",
        "background_element_id": ""
    },
	"layer_background_visible": {
        "desc": "",
        "background_element_id": "",
        "visible": ""
    },
	"layer_background_change": {
        "desc": "",
        "background_element_id": "",
        "sprite": ""
    },
	"layer_background_sprite": {
        "desc": "",
        "background_element_id": "",
        "sprite": ""
    },
	"layer_background_htiled": {
        "desc": "",
        "background_element_id": "",
        "tiled": ""
    },
	"layer_background_vtiled": {
        "desc": "",
        "background_element_id": "",
        "tiled": ""
    },
	"layer_background_stretch": {
        "desc": "",
        "background_element_id": "",
        "stretch": ""
    },
	"layer_background_yscale": {
        "desc": "",
        "background_element_id": "",
        "yscale": ""
    },
	"layer_background_xscale": {
        "desc": "",
        "background_element_id": "",
        "xscale": ""
    },
	"layer_background_blend": {
        "desc": "",
        "background_element_id": "",
        "col": ""
    },
	"layer_background_alpha": {
        "desc": "",
        "background_element_id": "",
        "alpha": ""
    },
	"layer_background_index": {
        "desc": "",
        "background_element_id": "",
        "image_index": ""
    },
	"layer_background_speed": {
        "desc": "",
        "background_element_id": "",
        "image_speed": ""
    },
	"layer_background_get_visible": {
        "desc": "",
        "background_element_id": ""
    },
	"layer_background_get_sprite": {
        "desc": "",
        "background_element_id": ""
    },
	"layer_background_get_htiled": {
        "desc": "",
        "background_element_id": ""
    },
	"layer_background_get_vtiled": {
        "desc": "",
        "background_element_id": ""
    },
	"layer_background_get_stretch": {
        "desc": "",
        "background_element_id": ""
    },
	"layer_background_get_yscale": {
        "desc": "",
        "background_element_id": ""
    },
	"layer_background_get_xscale": {
        "desc": "",
        "background_element_id": ""
    },
	"layer_background_get_blend": {
        "desc": "",
        "background_element_id": ""
    },
	"layer_background_get_alpha": {
        "desc": "",
        "background_element_id": ""
    },
	"layer_background_get_index": {
        "desc": "",
        "background_element_id": ""
    },
	"layer_background_get_speed": {
        "desc": "",
        "background_element_id": ""
    },
	"layer_sprite_get_id": {
        "desc": "",
        "layer_id": "",
        "sprite_element_name": ""
    },
	"layer_sprite_exists": {
        "desc": "",
        "layer_id": "",
        "sprite_element_id": ""
    },
	"layer_sprite_create": {
        "desc": "",
        "layer_id": "",
        "x": "",
        "y": "",
        "sprite": ""
    },
	"layer_sprite_destroy": {
        "desc": "",
        "sprite_element_id": ""
    },
	"layer_sprite_change": {
        "desc": "",
        "sprite_element_id": "",
        "sprite": ""
    },
	"layer_sprite_index": {
        "desc": "",
        "sprite_element_id": "",
        "image_index": ""
    },
	"layer_sprite_speed": {
        "desc": "",
        "sprite_element_id": "",
        "image_speed": ""
    },
	"layer_sprite_xscale": {
        "desc": "",
        "sprite_element_id": "",
        "xscale": ""
    },
	"layer_sprite_yscale": {
        "desc": "",
        "sprite_element_id": "",
        "yscale": ""
    },
	"layer_sprite_angle": {
        "desc": "",
        "sprite_element_id": "",
        "angle": ""
    },
	"layer_sprite_blend": {
        "desc": "",
        "sprite_element_id": "",
        "col": ""
    },
	"layer_sprite_alpha": {
        "desc": "",
        "sprite_element_id": "",
        "alpha": ""
    },
	"layer_sprite_x": {
        "desc": "",
        "sprite_element_id": "",
        "x": ""
    },
	"layer_sprite_y": {
        "desc": "",
        "sprite_element_id": "",
        "y": ""
    },
	"layer_sprite_get_sprite": {
        "desc": "",
        "sprite_element_id": ""
    },
	"layer_sprite_get_index": {
        "desc": "",
        "sprite_element_id": ""
    },
	"layer_sprite_get_speed": {
        "desc": "",
        "sprite_element_id": ""
    },
	"layer_sprite_get_xscale": {
        "desc": "",
        "sprite_element_id": ""
    },
	"layer_sprite_get_yscale": {
        "desc": "",
        "sprite_element_id": ""
    },
	"layer_sprite_get_angle": {
        "desc": "",
        "sprite_element_id": ""
    },
	"layer_sprite_get_blend": {
        "desc": "",
        "sprite_element_id": ""
    },
	"layer_sprite_get_alpha": {
        "desc": "",
        "sprite_element_id": ""
    },
	"layer_sprite_get_x": {
        "desc": "",
        "sprite_element_id": ""
    },
	"layer_sprite_get_y": {
        "desc": "",
        "sprite_element_id": ""
    },
	"layer_tilemap_get_id": {
        "desc": "",
        "layer_id": ""
    },
	"layer_tilemap_exists": {
        "desc": "",
        "layer_id": "",
        "tilemap_element_id": ""
    },
	"layer_tilemap_create": {
        "desc": "",
        "layer_id": "",
        "x": "",
        "y": "",
        "tileset": "",
        "width": "",
        "height": ""
    },
	"layer_tilemap_destroy": {
        "desc": "",
        "tilemap_element_id": ""
    },
	"tilemap_tileset": {
        "desc": "",
        "tilemap_element_id": "",
        "tileset": ""
    },
	"tilemap_x": {
        "desc": "",
        "tilemap_element_id": "",
        "x": ""
    },
	"tilemap_y": {
        "desc": "",
        "tilemap_element_id": "",
        "y": ""
    },
	"tilemap_set": {
        "desc": "",
        "tilemap_element_id": "",
        "tiledata": "",
        "cell_x": "",
        "cell_y": ""
    },
	"tilemap_set_at_pixel": {
        "desc": "",
        "tilemap_element_id": "",
        "tiledata": "",
        "x": "",
        "y": ""
    },
	"tilemap_get_tileset": {
        "desc": "",
        "tilemap_element_id": ""
    },
	"tilemap_get_tile_width": {
        "desc": "",
        "tilemap_element_id": ""
    },
	"tilemap_get_tile_height": {
        "desc": "",
        "tilemap_element_id": ""
    },
	"tilemap_get_width": {
        "desc": "",
        "tilemap_element_id": ""
    },
	"tilemap_get_height": {
        "desc": "",
        "tilemap_element_id": ""
    },
	"tilemap_get_x": {
        "desc": "",
        "tilemap_element_id": ""
    },
	"tilemap_get_y": {
        "desc": "",
        "tilemap_element_id": ""
    },
	"tilemap_get": {
        "desc": "",
        "tilemap_element_id": "",
        "cell_x": "",
        "cell_y": ""
    },
	"tilemap_get_at_pixel": {
        "desc": "",
        "tilemap_element_id": "",
        "x": "",
        "y": ""
    },
	"tilemap_get_cell_x_at_pixel": {
        "desc": "",
        "tilemap_element_id": "",
        "x": "",
        "y": ""
    },
	"tilemap_get_cell_y_at_pixel": {
        "desc": "",
        "tilemap_element_id": "",
        "x": "",
        "y": ""
    },
	"tilemap_clear": {
        "desc": "",
        "tilemap_element_id": "",
        "tiledata": ""
    },
	"draw_tilemap": {
        "desc": "",
        "tilemap_element_id": "",
        "x": "",
        "y": ""
    },
	"draw_tile": {
        "desc": "",
        "tileset": "",
        "tiledata": "",
        "frame": "",
        "x": "",
        "y": ""
    },
	"tilemap_set_global_mask": {
        "desc": "",
        "mask": ""
    },
	"tilemap_get_global_mask": {
        "desc": ""
    },
	"tilemap_set_mask": {
        "desc": "",
        "tilemap_element_id": "",
        "mask": ""
    },
	"tilemap_get_mask": {
        "desc": "",
        "tilemap_element_id": ""
    },
	"tilemap_get_frame": {
        "desc": "",
        "tilemap_element_id": ""
    },
	"tile_set_empty": {
        "desc": "",
        "tiledata": ""
    },
	"tile_set_index": {
        "desc": "",
        "tiledata": "",
        "tileindex": ""
    },
	"tile_set_flip": {
        "desc": "",
        "tiledata": "",
        "flip": ""
    },
	"tile_set_mirror": {
        "desc": "",
        "tiledata": "",
        "mirror": ""
    },
	"tile_set_rotate": {
        "desc": "",
        "tiledata": "",
        "rotate": ""
    },
	"tile_get_empty": {
        "desc": "",
        "tiledata": ""
    },
	"tile_get_index": {
        "desc": "",
        "tiledata": ""
    },
	"tile_get_flip": {
        "desc": "",
        "tiledata": ""
    },
	"tile_get_mirror": {
        "desc": "",
        "tiledata": ""
    },
	"tile_get_rotate": {
        "desc": "",
        "tiledata": ""
    },
	"layer_tile_exists": {
        "desc": "",
        "layer_id": "",
        "tile_element_id": "",
        "...": ""
    },
	"layer_tile_create": {
        "desc": "",
        "layer_id": "",
        "x": "",
        "y": "",
        "tileset": "",
        "left": "",
        "top": "",
        "width": "",
        "height": ""
    },
	"layer_tile_destroy": {
        "desc": "",
        "tile_element_id": ""
    },
	"layer_tile_change": {
        "desc": "",
        "tile_element_id": "",
        "sprite": ""
    },
	"layer_tile_xscale": {
        "desc": "",
        "tile_element_id": "",
        "xscale": ""
    },
	"layer_tile_yscale": {
        "desc": "",
        "tile_element_id": "",
        "yscale": ""
    },
	"layer_tile_blend": {
        "desc": "",
        "tile_element_id": "",
        "col": ""
    },
	"layer_tile_alpha": {
        "desc": "",
        "tile_element_id": "",
        "alpha": ""
    },
	"layer_tile_x": {
        "desc": "",
        "tile_element_id": "",
        "x": ""
    },
	"layer_tile_y": {
        "desc": "",
        "tile_element_id": "",
        "y": ""
    },
	"layer_tile_region": {
        "desc": "",
        "tile_element_id": "",
        "left": "",
        "top": "",
        "width": "",
        "height": ""
    },
	"layer_tile_visible": {
        "desc": "",
        "tile_element_id": "",
        "visible": ""
    },
	"layer_tile_get_sprite": {
        "desc": "",
        "tile_element_id": ""
    },
	"layer_tile_get_xscale": {
        "desc": "",
        "tile_element_id": ""
    },
	"layer_tile_get_yscale": {
        "desc": "",
        "tile_element_id": ""
    },
	"layer_tile_get_blend": {
        "desc": "",
        "tile_element_id": ""
    },
	"layer_tile_get_alpha": {
        "desc": "",
        "tile_element_id": ""
    },
	"layer_tile_get_x": {
        "desc": "",
        "tile_element_id": ""
    },
	"layer_tile_get_y": {
        "desc": "",
        "tile_element_id": ""
    },
	"layer_tile_get_region": {
        "desc": "",
        "tile_element_id": ""
    },
	"layer_tile_get_visible": {
        "desc": "",
        "tile_element_id": ""
    },
	"layer_instance_get_instance": {
        "desc": "",
        "instance_element_id": ""
    },
	 "instance_activate_layer": {
        "desc": "",
        "layer_id": ""
    },
	 "instance_deactivate_layer": {
        "desc": "",
        "layer_id": ""
    },
	"camera_create": {
        "desc": ""
    },
	"camera_create_view": {
        "desc": "",
        "room_x": "",
        "room_y": "",
        "width": "",
        "height": "",
        "angle": "",
        "object": "",
        "x_speed": "",
        "y_speed": "",
        "x_border": "",
        "y_border": ""
    },
	"camera_destroy": {
        "desc": "",
        "camera": ""
    },
	"camera_apply": {
        "desc": "",
        "camera": ""
    },
	"camera_get_active": {
        "desc": ""
    },
	"camera_get_default": {
        "desc": ""
    },
	"camera_set_default": {
        "desc": "",
        "camera": ""
    },
	"camera_set_view_mat": {
        "desc": "",
        "camera": "",
        "matrix": ""
    },
	"camera_set_proj_mat": {
        "desc": "",
        "camera": "",
        "matrix": ""
    },
	"camera_set_update_script": {
        "desc": "",
        "camera": "",
        "script": ""
    },
	"camera_set_begin_script": {
        "desc": "",
        "camera": "",
        "script": ""
    },
	"camera_set_end_script": {
        "desc": "",
        "camera": "",
        "script": ""
    },
	"camera_set_view_pos": {
        "desc": "",
        "camera": "",
        "x": "",
        "y": ""
    },
	"camera_set_view_size": {
        "desc": "",
        "camera": "",
        "width": "",
        "height": ""
    },
	"camera_set_view_speed": {
        "desc": "",
        "camera": "",
        "x_speed": "",
        "y_speed": ""
    },
	"camera_set_view_border": {
        "desc": "",
        "camera": "",
        "x_border": "",
        "y_border": ""
    },
	"camera_set_view_angle": {
        "desc": "",
        "camera": "",
        "angle": ""
    },
	"camera_set_view_target": {
        "desc": "",
        "camera": "",
        "object": ""
    },
	"camera_get_view_mat": {
        "desc": "",
        "camera": ""
    },
	"camera_get_proj_mat": {
        "desc": "",
        "camera": ""
    },
	"camera_get_update_script": {
        "desc": "",
        "camera": ""
    },
	"camera_get_begin_script": {
        "desc": "",
        "camera": ""
    },
	"camera_get_end_script": {
        "desc": "",
        "camera": ""
    },
	"camera_get_view_x": {
        "desc": "",
        "camera": ""
    },
	"camera_get_view_y": {
        "desc": "",
        "camera": ""
    },
	"camera_get_view_width": {
        "desc": "",
        "camera": ""
    },
	"camera_get_view_height": {
        "desc": "",
        "camera": ""
    },
	"camera_get_view_speed_x": {
        "desc": "",
        "camera": ""
    },
	"camera_get_view_speed_y": {
        "desc": "",
        "camera": ""
    },
	"camera_get_view_border_x": {
        "desc": "",
        "camera": ""
    },
	"camera_get_view_border_y": {
        "desc": "",
        "camera": ""
    },
	"camera_get_view_angle": {
        "desc": "",
        "camera": ""
    },
	"camera_get_view_target": {
        "desc": "",
        "camera": ""
    },
	"view_get_camera": {
        "desc": "",
        "view": ""
    },
	"view_get_visible": {
        "desc": "",
        "view": ""
    },
	"view_get_xport": {
        "desc": "",
        "view": ""
    },
	"view_get_yport": {
        "desc": "",
        "view": ""
    },
	"view_get_wport": {
        "desc": "",
        "view": ""
    },
	"view_get_hport": {
        "desc": "",
        "view": ""
    },
	"view_get_surface_id": {
        "desc": "",
        "view": ""
    },
	"view_set_camera": {
        "desc": "",
        "view": "",
        "camera": ""
    },
	"view_set_visible": {
        "desc": "",
        "view": "",
        "visible": ""
    },
	"view_set_xport": {
        "desc": "",
        "view": "",
        "xport": ""
    },
	"view_set_yport": {
        "desc": "",
        "view": "",
        "yport": ""
    },
	"view_set_wport": {
        "desc": "",
        "view": "",
        "wport": ""
    },
	"view_set_hport": {
        "desc": "",
        "view": "",
        "hport": ""
    },
	"view_set_surface_id": {
        "desc": "",
        "view": "",
        "surface_id": ""
    },
	"gesture_drag_time": {
        "desc": "",
        "time": ""
    },
	"gesture_drag_distance": {
        "desc": "",
        "distance": ""
    },
	"gesture_flick_speed": {
        "desc": "",
        "speed": ""
    },
	"gesture_double_tap_time": {
        "desc": "",
        "time": ""
    },
	"gesture_double_tap_distance": {
        "desc": "",
        "distance": ""
    },
	"gesture_pinch_distance": {
        "desc": "",
        "distance": ""
    },
	"gesture_pinch_angle_towards": {
        "desc": "",
        "angle": ""
    },
	"gesture_pinch_angle_away": {
        "desc": "",
        "angle": ""
    },
	"gesture_rotate_time": {
        "desc": "",
        "time": ""
    },
	"gesture_rotate_angle": {
        "desc": "",
        "angle": ""
    },
	"gesture_tap_count": {
        "desc": "",
        "enable": ""
    },
	"gesture_get_drag_time": {
        "desc": ""
    },
	"gesture_get_drag_distance": {
        "desc": ""
    },
	"gesture_get_flick_speed": {
        "desc": ""
    },
	"gesture_get_double_tap_time": {
        "desc": ""
    },
	"gesture_get_double_tap_distance": {
        "desc": ""
    },
	"gesture_get_pinch_distance": {
        "desc": ""
    },
	"gesture_get_pinch_angle_towards": {
        "desc": ""
    },
	"gesture_get_pinch_angle_away": {
        "desc": ""
    },
	"gesture_get_rotate_time": {
        "desc": ""
    },
	"gesture_get_rotate_angle": {
        "desc": ""
    },
	"gesture_get_tap_count": {
		"desc": ""
	}
}